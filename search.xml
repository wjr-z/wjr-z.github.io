<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Codeforces Round 682 (Div.2) A~D</title>
    <url>/CodeforcesR682/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div id="cnblogs_post_body" class="blogpost-body">
    <p>（<span style="text-decoration: line-through">题外话：本来要上紫了的,结果unrated...</span>）</p>

<span id="more"></span>
<h2>A. Specific Tastes of Andre</h2>
<p><span style="font-size: 18px"><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLm1sL2NvbnRlc3QvMTQzOC9wcm9ibGVtL0E=">题目链接<i class="fa fa-external-link-alt"></i></span></span></p>
<p><span style="font-size: 18px">题目大意：让你构造一个长度为n的数组，其所有元素之和为n的倍数</span></p>
<p><span style="font-size: 18px">题解：直接输出n个1即可</span></p>
<h2>B. Valerii Against Everyone</h2>
<p><span style="font-size: 18px"><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLm1sL2NvbnRlc3QvMTQzOC9wcm9ibGVtL0I=">题目链接<i class="fa fa-external-link-alt"></i></span></span></p>
<p><span style="font-size: 18px">题目大意：给定数组 b ,a<sub>i</sub>=2<sup>b<sub>i</sub></sup><sub>&nbsp;</sub>,问<strong>是否存在两个不相同的a的子数组和相同</strong></span></p>
<p><span style="font-size: 18px">题解：</span></p>
<ul>
<li><span style="font-size: 18px">对于b数组若存在 (i,j) 使得 b<sub>i&nbsp;</sub>= b<sub>j</sub>，则必定存在。</span></li>
<li><span style="font-size: 18px">若b数组互不相同，则从二进制来看，则不同的a的子数组至少有一位二进制不同，所以必定不存在（每一位仅有一个a可以取得，若两个数相同，则子数组必相等）</span></li>
</ul>
<p><span style="font-size: 18px">故题目转化为<strong>判断b数组是否有相同的数</strong>。</span></p>
<h2>C. Engineer Artem</h2>
<p><span style="font-size: 18px"><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLm1sL2NvbnRlc3QvMTQzOC9wcm9ibGVtL0M=">题目链接<i class="fa fa-external-link-alt"></i></span></span></p>
<p><span style="font-size: 18px">题目大意：给定一个n*m的二维数组，第 i 行第 j 列是 a[i][j] ，请你构造出二维数组 b , b[i][j] = a[i][j] or a[i][j] + 1 ,<strong>并且相邻的数不相同</strong></span></p>
<p><span style="font-size: 18px">题解：</span></p>
<p><em><span style="font-size: 18px">类似于二分图染色</span></em></p>
<p><em><span style="font-size: 18px">对于 (i+j)%2 的点必定互不相邻</span></em></p>
<p><span style="font-size: 18px">我们对于所有 a[i][j] = x 的数，将 (i+j+x)%2 为 0 的数 + 1，因为对于 a[i][j] = x + 1 的数 (i+j+x+1)%2 为 0 的 +1 ，则只剩下 (i+j+x)%2 为 0 的，那么 x+1 只存在 (i+j+x)%2 为 0 的，必定不相邻</span></p>
<p><span style="font-size: 18px">根据数学归纳，可以得知所有的数如此操作后必定能满足条件。</span></p>
<h2>D. Powerful Ksenia</h2>
<p><span style="font-size: 18px"><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLm1sL2NvbnRlc3QvMTQzOC9wcm9ibGVtL0Q=">题目链接<i class="fa fa-external-link-alt"></i></span></span></p>
<p><span style="font-size: 18px">题目大意：给定长度为n的数组，每次可以选择 (i,j,k) ，令 a<sub>i&nbsp;</sub>= a<sub>j&nbsp;</sub>= a<sub>k&nbsp;</sub>= a<sub>i</sub>^a<sub>j</sub>^a<sub>k&nbsp;&nbsp;</sub>，在最多n次操作内使得所有数相同</span></p>
<p><span style="font-size: 18px">题解：</span></p>
<ul>
<li><em><span style="font-size: 18px">对于任意三个数，可以通过一次操作使其变成相同</span></em></li>
<li><em><span style="font-size: 18px">对于两个相同的数和 x ，可以通过一次操作使其变为 x&nbsp;</span></em></li>
<li><span style="font-size: 18px"><em>操作并不改变异或和</em></span></li>
</ul>
<p><span style="font-size: 18px">然后我们<strong>考虑令所有数 = a<sub>1</sub>^a<sub>2</sub>^...^a<sub>n</sub></strong>（<span style="text-decoration: line-through">常用套路</span>）</span></p>
<p><span style="font-size: 18px"><strong>首先将前三个数变为相同</strong>，接着后面每两个数((4,5),(6,7)....)和前面一个数进行一次操作</span></p>
<p><span style="font-size: 18px">这样因为前三个数是 a<sub>1</sub>^a<sub>2</sub>^a<sub>3&nbsp;</sub>,第三个和第四个第五个异或成 a<sub>1</sub>^a<sub>2</sub>^a<sub>3</sub>^a<sub>4</sub>^a<sub>5&nbsp;</sub></span></p>
<p><span style="font-size: 18px">后面同理</span></p>
<p><span style="font-size: 18px"><strong>如果 (n-3)%2 为 0</strong> ，则 a<sub>n&nbsp;</sub>即为 a<sub>1</sub>^a<sub>2</sub>^...^a<sub>n&nbsp;</sub>，且前面均为两个一组的相同的数，每次操作将两个一组的相同的数和n进行异或</span></p>
<p><span style="font-size: 18px"><strong>如果 (n-3)%2 不为 0</strong> ，则还剩一个数 a<sub>n&nbsp;</sub>，这里我们证明下为什么这种情况 a<sub>1</sub>^a<sub>2</sub>^...^a<sub>n&nbsp;</sub>不为 0 的时候无解，若 (n-3)%2==1 ，则 n=3+2k+1=4+2k 为偶数</span></p>
<p><span style="font-size: 18px">对于相同的数如果有 k 个，可以将其化简为 k%2 个，因为 2 个相同的数一定可以和 x 变为 x ，所以可以等价为每个数最多只有一个，且仍然是偶数个</span></p>
<p><span style="font-size: 18px">若最后可以化为所有数相同，则所有数异或和为 0 ，<strong>因为操作并不会导致异或和改变，因此这种情况当且仅当所有数异或和为 0 有解。</strong></span></p>
<p><span style="font-size: 18px">当有解时同第一种情况一样做就行了。</span></p>
<p>操作次数为很显然符合题意</p>
<h2>E.Yurii Can Do Everything</h2>
<p>我不会qwq</p>
</div>
<div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">


</div>
]]></content>
      <tags>
        <tag>cf比赛</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>2018-2019 ACM-ICPC EC Final I - Misunderstood … Missing</title>
    <url>/2018-2019-ACM-ICPC-EC-Final-I-Misunderstood-%E2%80%A6-Missing/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这题正解是反着DP，不过我用模拟退火就过了。</p>
<p>因此分享下模拟退火做法</p>
<span id="more"></span>
<p>关于模拟退火的讲解可以看下<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vZmxhc2hodS9wLzg4ODQxMzIuaHRtbA==">这一篇博客<i class="fa fa-external-link-alt"></i></span></p>
<p>这题的话实际上就是很基础的模拟退火应用了</p>
<p>我令$k[i]$代表第$i$次是哪个操作</p>
<p>每次随机找到一个$x$，将$k[x]$改为一个随机数$y$（$1\leq y\leq 3$）</p>
<p>然后如果更优直接修改，如果更劣，则有一定概率接受，具体概率见那篇博客。</p>
<p>然后这样其实不太保险，因为还是可能陷入局部最优解，注意到这题$n$很小，所以我们可以在外层继续套循环</p>
<p>如果我们一次掉入了局部最优解，我们下一次开始重新模拟退火，就有可能跳出该局部最优解，跑个几千次还在局部最优解的概率就很低了。</p>
<p>对了，随机化最好用$mt_rand$，会快很多，并且更加随机。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">105</span>;</span><br><span class="line"><span class="keyword">int</span> a[N], b[N], c[N];</span><br><span class="line"><span class="keyword">int</span> k[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> A, D;</span><br><span class="line">    A = D = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        A += D;</span><br><span class="line">        <span class="keyword">switch</span> (k[i]) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:ans += A + a[i]; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:D += b[i]; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:A += c[i]; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ansk[N];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> tmp = <span class="number">0.99</span>, e = <span class="number">2.714</span>;</span><br><span class="line"><span class="keyword">double</span> R[<span class="number">1000</span>], temp[<span class="number">1000</span>];</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">qpow</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> s = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)s *= a;</span><br><span class="line">        a *= a;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> Maxd;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i)</span><br><span class="line">        Maxd |= (<span class="number">1u</span> &lt;&lt; i);</span><br><span class="line">    <span class="function">mt19937 <span class="title">mt_rand</span><span class="params">(time(<span class="number">0</span>))</span></span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    temp[<span class="number">1</span>] = <span class="number">1</span>; R[<span class="number">1</span>] = <span class="built_in">pow</span>(e, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">500</span>; ++i) &#123;</span><br><span class="line">        temp[i] = temp[i - <span class="number">1</span>] * tmp;</span><br><span class="line">        R[i] = <span class="built_in">pow</span>(e, <span class="number">-1.0</span> / temp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a[i], &amp;b[i], &amp;c[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)ansk[i] = k[i] = mt_rand() % <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> Mans = work();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> kase = <span class="number">1</span>; kase &lt;= <span class="number">15</span> * n; ++kase) &#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> ans = work();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> Case = <span class="number">1</span>; Case &lt;= <span class="number">5</span> * n; ++Case) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = mt_rand() % n + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> y = mt_rand() % <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> nowk = k[x];</span><br><span class="line">                <span class="keyword">if</span>(y==k[x])<span class="keyword">continue</span>;</span><br><span class="line">                k[x] = y;</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> kans = work();</span><br><span class="line">                <span class="keyword">if</span> (kans &gt;= ans)</span><br><span class="line">                    ans = kans;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">double</span> zz = qpow(R[Case], ans - kans);</span><br><span class="line">                    <span class="keyword">if</span> (mt_rand() &lt;= zz * Maxd) &#123;</span><br><span class="line">                        ans = kans;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> k[x] = nowk;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ans &gt; Mans)</span><br><span class="line">                Mans = ans, <span class="built_in">memcpy</span>(ansk, k, <span class="keyword">sizeof</span>(k));</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">memcpy</span>(k, ansk, <span class="keyword">sizeof</span>(k));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, Mans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参数啥的都可以调调，如果求稳，就把循环调大点，如果速度慢了，求把循环调小点。</p>
<p>这个复杂度是$O(75*n^3)$</p>
<p>然后跑的还挺快，实际上把参数调小点，可以达到最快大概$O(12*n^3)$，不过就是正确率低了点。</p>
<p>这个代码正确率还挺高的。</p>
]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>模拟退火</tag>
      </tags>
  </entry>
  <entry>
    <title>2020-2021 ICPC Brazil比赛</title>
    <url>/2020-2021%20ICPC%20Brazil%E6%AF%94%E8%B5%9B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLm1sL2d5bS8xMDI4NjE=">题目链接<i class="fa fa-external-link-alt"></i></span></p>
<span id="more"></span>
<h2 id="A-Sticker-Album"><a href="#A-Sticker-Album" class="headerlink" title="A.Sticker Album"></a>A.Sticker Album</h2><p>题目描述：<br>买卡包，每包里有卡片[A,B]张，获得每个卡片的概率都相同，问买多少卡包能组成N张卡片的期望。</p>
<p>题解：<br>细节题。<br>我们令dp[i]表示n-i张卡片所需卡包的期望值。（避免出现下标为负数）<br>对于A!=0有<br>$dp[i]=\frac{\sum_{j=i+A}^{i+B}dp[j]}{R-L+1}+1$</p>
<p>对于A==0有<br>$dp[i]=\frac{\sum_{j=i}^{i+B}dp[j]+dp[i]}{p}+1$</p>
<p>化简可得<br>$dp[i]=\frac{\sum_{j=i}^{i+B}dp[j]+p}{p-1}$</p>
<p>然后就可以线性递推了。</p>
<details>
    <summary>参考代码</summary>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">double</span> dp[N];</span><br><span class="line"><span class="comment">//dp[i]表示n-i的期望卡包数量</span></span><br><span class="line"><span class="keyword">int</span> n,L,R;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;L,&amp;R);</span><br><span class="line">    <span class="keyword">double</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> p=(<span class="keyword">double</span>)(R-L+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(L)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">            dp[i]=sum/p+<span class="number">1</span>;</span><br><span class="line">            sum-=dp[i+R];</span><br><span class="line">            sum+=dp[i+L<span class="number">-1</span>];</span><br><span class="line">        &#125;<span class="built_in">printf</span>(<span class="string">&quot;%.5f\n&quot;</span>,dp[<span class="number">0</span>]);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">            dp[i]=(sum+p)/(p<span class="number">-1</span>);</span><br><span class="line">            sum-=dp[i+R];</span><br><span class="line">            sum+=dp[i];</span><br><span class="line">        &#125;<span class="built_in">printf</span>(<span class="string">&quot;%.5f\n&quot;</span>,dp[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<h2 id="B-Battleship"><a href="#B-Battleship" class="headerlink" title="B.Battleship"></a>B.Battleship</h2><p>题目描述：<br>给出若干个船的朝向和初始位置，且网格为10*10，问初始位置是否合理。</p>
<p>题解：<br>水题。直接模拟就行了，将每艘船占据的位置打上标记，以后每一艘进来判断是否已经存在即可。</p>
<details>
    <summary>参考代码</summary>
    <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">bool</span> f[<span class="number">12</span>][<span class="number">12</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">ck</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;<span class="number">10</span>||j&lt;<span class="number">1</span>||j&gt;<span class="number">10</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(f[i][j])<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">int</span> D,R,C,L;</span><br><span class="line">    <span class="keyword">bool</span> g=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;D,&amp;L,&amp;R,&amp;C);</span><br><span class="line">        <span class="keyword">if</span>(!D)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=L;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!ck(R,C+j<span class="number">-1</span>))&#123;</span><br><span class="line">                    g=<span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;f[R][C+j<span class="number">-1</span>]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=L;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!ck(R+j<span class="number">-1</span>,C))&#123;</span><br><span class="line">                    g=<span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;f[R+j<span class="number">-1</span>][C]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">if</span>(g)<span class="built_in">printf</span>(<span class="string">&quot;Y\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;N\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<h2 id="C-Concatenating-Teams"><a href="#C-Concatenating-Teams" class="headerlink" title="C.Concatenating Teams"></a>C.Concatenating Teams</h2><h2 id="D-Divisibility-Dance"><a href="#D-Divisibility-Dance" class="headerlink" title="D.Divisibility Dance"></a>D.Divisibility Dance</h2><h2 id="E-Party-Company"><a href="#E-Party-Company" class="headerlink" title="E.Party Company"></a>E.Party Company</h2><p>题目描述：<br><del>题面什么东西，看半天没看懂</del></p>
<p>给定一棵树，每个点i有一个权值<script type="math/tex">a_i</script>，现有m次派对<script type="math/tex">(O_j,L_j,R_j)</script>，第j次参加派对的为含O的连通块，且连通块内所有点权值在<script type="math/tex">[L,R]</script>之间(数据保证<script type="math/tex">L_j \leq a_{O_j} \leq R_j</script>)</p>
<h2 id="F-Fastminton"><a href="#F-Fastminton" class="headerlink" title="F.Fastminton"></a>F.Fastminton</h2><h2 id="G-Game-Show"><a href="#G-Game-Show" class="headerlink" title="G.Game Show!"></a>G.Game Show!</h2><p>题目描述：<br>给了你100块钱和n个a[i]，你可以拿前面连续的若干个，问最后最多你还有多少钱。</p>
<p>题解：<br>水题。找出最大的前缀和即可。</p>
<details>
    <summary>参考代码</summary>
    <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">105</span>;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        a[i]+=a[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">100</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        ans=max(ans,a[i]+<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<h2 id="H-SBC’s-Hangar"><a href="#H-SBC’s-Hangar" class="headerlink" title="H.SBC’s Hangar"></a>H.SBC’s Hangar</h2><h2 id="I-Interactivity"><a href="#I-Interactivity" class="headerlink" title="I.Interactivity"></a>I.Interactivity</h2><h2 id="J-Collecting-Data"><a href="#J-Collecting-Data" class="headerlink" title="J.Collecting Data"></a>J.Collecting Data</h2><h2 id="K-Between-Us"><a href="#K-Between-Us" class="headerlink" title="K.Between Us"></a>K.Between Us</h2><h2 id="L-Lavaspar"><a href="#L-Lavaspar" class="headerlink" title="L.Lavaspar"></a>L.Lavaspar</h2><p>题目描述：<br>给你L*C(我用的n*m表示的)的图，每个点有一个字符，给定N个字符串，可以横着、竖着、斜着在图上匹配，只要每个字符出现次数相同即可，问有多少个点可以匹配至少两个字符串。<br><img data-src="https://subdomains.codeforces.ml/espresso/cd90e2adbd43c9079e295c1f91d07f83881d83a5.png" alt=""><br>例如上图，每种颜色框表示不同字符串匹配，黄色代表的是特殊位置即他们至少能匹配两个字符串。</p>
<p>题解：<br>水题。每个字符串找出所有和他匹配的所有点，然后更新每个点可以匹配字符串数目即可。</p>
<details>
<summary>参考代码</summary>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">45</span>;</span><br><span class="line"><span class="keyword">int</span> cnt[N][N],now_cnt[N][N];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> Q;</span><br><span class="line"><span class="keyword">int</span> py[<span class="number">4</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">-1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">char</span> s[N][N],p[N];</span><br><span class="line"><span class="keyword">int</span> c[<span class="number">30</span>],d[<span class="number">30</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">ck</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>||j&lt;<span class="number">1</span>||i&gt;n||j&gt;m)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s[i]+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;Q);</span><br><span class="line">    <span class="keyword">while</span>(Q--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,p+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> K=<span class="built_in">strlen</span>(p+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="keyword">sizeof</span>(d));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=K;++i)</span><br><span class="line">            ++d[p[i]-<span class="string">&#x27;A&#x27;</span>];</span><br><span class="line">        <span class="built_in">memset</span>(now_cnt,<span class="number">0</span>,<span class="keyword">sizeof</span>(now_cnt));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;++j)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">4</span>;++k)&#123;</span><br><span class="line">                    <span class="keyword">int</span> x=i,y=j;</span><br><span class="line">                    <span class="keyword">bool</span> is=<span class="number">1</span>;</span><br><span class="line">                    <span class="built_in">memcpy</span>(c,d,<span class="keyword">sizeof</span>(c));</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> step=<span class="number">1</span>;step&lt;=K;++step)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(!ck(x,y))&#123;</span><br><span class="line">                            is=<span class="number">0</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(--c[s[x][y]-<span class="string">&#x27;A&#x27;</span>]&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                            is=<span class="number">0</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        x+=py[k][<span class="number">0</span>],y+=py[k][<span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(is)&#123;</span><br><span class="line">                        x=i,y=j;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> step=<span class="number">1</span>;step&lt;=K;++step)&#123;</span><br><span class="line">                            ++now_cnt[x][y];</span><br><span class="line">                            x+=py[k][<span class="number">0</span>],y+=py[k][<span class="number">1</span>];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;++j)</span><br><span class="line">                cnt[i][j]+=now_cnt[i][j]&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;++j)</span><br><span class="line">            ans+=cnt[i][j]&gt;=<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<h2 id="M-Machine-Gun"><a href="#M-Machine-Gun" class="headerlink" title="M.Machine Gun"></a>M.Machine Gun</h2><h2 id="N-Number-Multiplication"><a href="#N-Number-Multiplication" class="headerlink" title="N.Number Multiplication"></a>N.Number Multiplication</h2><p>题目描述：<br>数学题，自己看描述吧。</p>
<p>题解：<br>因为a是递增的，且我们知道对于$n$最多只存在一个$\sqrt{n}$以上的质因数，因此这题就好做了。</p>
<p>我们找到第一个满足条件的质数a[i]即可开始找a[i+1]，因为如果存在多种满足条件的a[i]，我们只能选择最小的一个，否则最后肯定不满足条件，因为a数组是递增的，如果当前不取最小的，则后面都无法取到。</p>
<p>且我们对于一个质数只用判断一个相连的b[j]是否满足即可，如果我们当前不选prime，则后面无论怎么选都无法满足条件(b[j]总会剩下若干个prime的乘积)。</p>
<p>然后对于大于$10^{7.5}$的a[i]直接令他等于与他相连的b[j]即可，因为最多只存在一个嘛，上面说了的。</p>
<details>
<summary>参考代码</summary>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,K;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e3</span>+<span class="number">10</span>,M=<span class="number">1e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> b[N],a[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> index,d;</span><br><span class="line">    node(<span class="keyword">int</span> a=<span class="number">0</span>,<span class="keyword">int</span> b=<span class="number">0</span>)&#123;index=a,d=b;&#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> node&amp;other)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index&lt;other.index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;node&gt;q[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">qpow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> s=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)s*=a;</span><br><span class="line">        a*=a;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Max=<span class="built_in">sqrt</span>(<span class="number">1e15</span>)+<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;K);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;b[i]);</span><br><span class="line">    <span class="keyword">int</span> u,v,d;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=K;++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;u,&amp;v,&amp;d);</span><br><span class="line">        q[u].push_back(node(v,d));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> Min_pr=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> c=q[i].size();</span><br><span class="line">        <span class="keyword">for</span>(++Min_pr;Min_pr&lt;=Max;++Min_pr)&#123;</span><br><span class="line">            <span class="keyword">bool</span> g=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1</span>;++j)&#123;</span><br><span class="line">                node now=q[i][j];</span><br><span class="line">                <span class="keyword">if</span>(b[now.index]%qpow(Min_pr,now.d))</span><br><span class="line">                    g=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(g)&#123;</span><br><span class="line">                a[i]=Min_pr;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;c;++j)&#123;</span><br><span class="line">                    node now=q[i][j];</span><br><span class="line">                    b[now.index]/=qpow(Min_pr,now.d);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Min_pr&gt;Max)<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(;i&lt;=n;++i)</span><br><span class="line">        a[i]=b[q[i][<span class="number">0</span>].index];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>,a[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<h2 id="O-Venusian-Shuttle"><a href="#O-Venusian-Shuttle" class="headerlink" title="O.Venusian Shuttle"></a>O.Venusian Shuttle</h2>]]></content>
      <tags>
        <tag>ICPC</tag>
      </tags>
  </entry>
  <entry>
    <title>2020 ICPC Asia East Continent Final J.Circle 题解</title>
    <url>/2020-ICPC-Asia-East-Continent-Final-J-Circle-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>给出$n$个半径相同的圆，求出$n$个圆的公共面积。</p>
<span id="more"></span>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>将每个圆按照相同方法近似成正$C$边形，然后对于$C*n$条边进行半平面交，但很显然这样做$C$取大了会TLE，取小了会精度不够WA。  </p>
<p>我们取三角形上$C$个点，这$C$个点均匀分布，第$i$个点$P_i$为<script type="math/tex">(r*cos(\frac{2*\pi*i}{C}), r * sin (\frac{2*\pi*i}{C})) , i\in [0,C)</script>，第$i$条线段即<script type="math/tex">\vec{p_{i}p_{i+1}},i\in [0,C)</script></p>
<p>这样对于每个圆上的第$i$条线段其极角相同，对于极角相同且直线也重合的两个圆，可以推出这条线段对于答案没有贡献（画个图很容易看出），可以不用考虑。  </p>
<p>则对于$n$个圆上的第$i$条线段，因为极角均相同，实际上只有一个圆的第$i$条线段可以对答案产生贡献。  </p>
<p>因此实际上$n$个圆总共只用取出$C$条线段均可。    </p>
<p>假设有一条线段是$(0,1)$，那么这条线段很显然是圆心坐标最小的圆的最右侧最优，如果是$(0,-1)$，是圆心左边最大的圆的左侧最优。  </p>
<p>题目还好心的给了我们圆心的凸包，因为半径相同，所以可以将问题转化为比较圆心的相对位置（如果半径不同，则比较麻烦，但我感觉还是可以用数据结构进行查找）    </p>
<p>第一条线段我们先找到一个圆心坐标最小的圆$t$，我们设$vec=\vec{O_{t+1}O{t}}$，如果$\vec{p_{i}p_{i+1}}$在$vec$左侧，说明下一个圆更优，直到找到一个最优的圆。就有点像是旋转卡壳。可以画两个圆理解一下，其实很简单。    </p>
<p>然后就可以半平面交求面积了。    </p>
<p>不过因为我们用了线段去切圆，所以最后需要加一些弓形面积进行矫正，可以直接求出答案多边形边数乘以每一个小弓形面积（均相同）或者对于答案凸包的每条线段求出小弓形面积（不一定相同），$C$取4000就可以过这题。  </p>
<p>不过这题因为可能出现测试点很多，$n$很小的情况，此时固定取点并不太好，可以使用暴力。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">double</span> r;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> C = <span class="number">4000</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vec</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">    vec() &#123;&#125;</span><br><span class="line">    vec(<span class="keyword">double</span> a, <span class="keyword">double</span> b) &#123; x = a, y = b; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">len</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">sqrt</span>(dot(*<span class="keyword">this</span>, *<span class="keyword">this</span>)); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">double</span> <span class="title">dot</span><span class="params">(vec a, vec b)</span> </span>&#123; <span class="keyword">return</span> a.x * b.x + a.y * b.y; &#125;</span><br><span class="line">    <span class="function">vec <span class="title">rotate</span><span class="params">(<span class="keyword">double</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vec(x * <span class="built_in">cos</span>(a) - y * <span class="built_in">sin</span>(a), x * <span class="built_in">sin</span>(a) + y * <span class="built_in">cos</span>(a));</span><br><span class="line">    &#125;</span><br><span class="line">    vec <span class="keyword">operator</span>-(vec a) &#123; <span class="keyword">return</span> vec(x - a.x, y - a.y); &#125;</span><br><span class="line">    vec <span class="keyword">operator</span>+(vec a) &#123; <span class="keyword">return</span> vec(x + a.x, y + a.y); &#125;</span><br><span class="line">    vec <span class="keyword">operator</span>*(<span class="keyword">double</span> a) &#123; <span class="keyword">return</span> vec(x * a, y * a); &#125;</span><br><span class="line">    vec <span class="keyword">operator</span>/(<span class="keyword">double</span> a) &#123; <span class="keyword">return</span> vec(x / a, y / a); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">ang</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">atan2</span>(y, x); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">double</span> <span class="title">cross</span><span class="params">(vec a, vec b)</span> </span>&#123; <span class="keyword">return</span> a.x * b.y - a.y * b.x; &#125;</span><br><span class="line">&#125; p[C + <span class="number">10</span>];</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">line</span> &#123;</span></span><br><span class="line">    vec s, e;</span><br><span class="line">    <span class="keyword">double</span> ang;</span><br><span class="line">    line() &#123;&#125;</span><br><span class="line">    line(vec a, vec b) &#123; s = a, e = b; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> vec <span class="title">inter</span><span class="params">(line a, line b)</span> </span>&#123;  <span class="comment">// 直线交点解方程</span></span><br><span class="line">        <span class="keyword">double</span> s1 = cross(a.e - b.s, a.s - b.s);</span><br><span class="line">        <span class="keyword">double</span> s2 = cross(b.e - a.e, a.s - a.e);</span><br><span class="line">        <span class="keyword">return</span> (b.s * s2 + b.e * s1) / (s1 + s2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">bool</span> <span class="title">cut</span><span class="params">(line a, line b, line c)</span> </span>&#123;  <span class="comment">// 若ab交点在c右侧则删除</span></span><br><span class="line">        <span class="keyword">return</span> cross(c.e - c.s, inter(a, b) - c.s) &lt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; l[C + <span class="number">10</span>];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nxt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> (x + <span class="number">1</span>) % n; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">half_plane</span><span class="params">(line* l, vec* p, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = n;</span><br><span class="line">    <span class="keyword">int</span> head = <span class="number">0</span>, tail = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (head &lt; tail &amp;&amp; cut(l[tail - <span class="number">1</span>], l[tail], l[i]))</span><br><span class="line">            tail--;  <span class="comment">// i对上一个的影响</span></span><br><span class="line">        <span class="keyword">while</span> (head &lt; tail &amp;&amp; cut(l[head], l[head + <span class="number">1</span>], l[i]))</span><br><span class="line">            head++;  <span class="comment">// i对第一个的影响</span></span><br><span class="line">        l[++tail] = l[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (head &lt; tail &amp;&amp; cut(l[tail - <span class="number">1</span>], l[tail], l[head]))</span><br><span class="line">        tail--;  <span class="comment">//删除最后多加的边</span></span><br><span class="line">    l[++tail] = l[head];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tail - head; i++) &#123;</span><br><span class="line">        p[i] = inter(l[head + i], l[head + i + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tail - head;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">size</span><span class="params">(vec* p, <span class="keyword">int</span> n)</span> </span>&#123;  <span class="comment">//多边形边面积s</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> ans = <span class="number">0</span>;</span><br><span class="line">    p[n] = p[<span class="number">0</span>], p[n + <span class="number">1</span>] = p[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) ans += p[i + <span class="number">1</span>].y * (p[i].x - p[i + <span class="number">2</span>].x);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fabs</span>(ans / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这下面是暴力</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">100000007</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Ty&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Ty <span class="title">sqr</span><span class="params">(<span class="keyword">const</span> Ty&amp; x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">double</span> area[N];</span><br><span class="line"><span class="keyword">double</span> R;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dcmp</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; -eps)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> x &gt; eps;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> f = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = <span class="literal">false</span>;</span><br><span class="line">        c = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (c - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        c = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f ? x : -x;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cp</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y, r, angle;</span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line">    cp() &#123;&#125;</span><br><span class="line">    cp(<span class="keyword">const</span> <span class="keyword">double</span>&amp; xx, <span class="keyword">const</span> <span class="keyword">double</span>&amp; yy, <span class="keyword">const</span> <span class="keyword">double</span>&amp; ang = <span class="number">0</span>, <span class="keyword">int</span> t = <span class="number">0</span>) &#123;</span><br><span class="line">        x = xx;</span><br><span class="line">        y = yy;</span><br><span class="line">        angle = ang;</span><br><span class="line">        d = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        x = read();</span><br><span class="line">        y = read();</span><br><span class="line"> </span><br><span class="line">        r = R;</span><br><span class="line">        d = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; cir[N], tp[N * <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dis</span><span class="params">(<span class="keyword">const</span> cp&amp; a, <span class="keyword">const</span> cp&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(sqr(a.x - b.x) + sqr(a.y - b.y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cross</span><span class="params">(<span class="keyword">const</span> cp&amp; p0, <span class="keyword">const</span> cp&amp; p1, <span class="keyword">const</span> cp&amp; p2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (p1.x - p0.x) * (p2.y - p0.y) - (p1.y - p0.y) * (p2.x - p0.x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CirCrossCir</span><span class="params">(<span class="keyword">const</span> cp&amp; p1, <span class="keyword">const</span> <span class="keyword">double</span>&amp; r1, <span class="keyword">const</span> cp&amp; p2, <span class="keyword">const</span> <span class="keyword">double</span>&amp; r2,</span></span></span><br><span class="line"><span class="function"><span class="params">                cp&amp; cp1, cp&amp; cp2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> mx = p2.x - p1.x, sx = p2.x + p1.x, mx2 = mx * mx;</span><br><span class="line">    <span class="keyword">double</span> my = p2.y - p1.y, sy = p2.y + p1.y, my2 = my * my;</span><br><span class="line">    <span class="keyword">double</span> sq = mx2 + my2, d = -(sq - sqr(r1 - r2)) * (sq - sqr(r1 + r2));</span><br><span class="line">    <span class="keyword">if</span> (d + eps &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    d = d &lt; eps ? <span class="number">0</span> : <span class="built_in">sqrt</span>(d);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">double</span> x = mx * ((r1 + r2) * (r1 - r2) + mx * sx) + sx * my2;</span><br><span class="line">    <span class="keyword">double</span> y = my * ((r1 + r2) * (r1 - r2) + my * sy) + sy * mx2;</span><br><span class="line">    <span class="keyword">double</span> dx = mx * d, dy = my * d;</span><br><span class="line">    sq *= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">double</span> g = <span class="number">1.0</span> / sq;</span><br><span class="line">    cp1.x = (x - dy) * g;</span><br><span class="line">    cp1.y = (y + dx) * g;</span><br><span class="line">    cp2.x = (x + dy) * g;</span><br><span class="line">    cp2.y = (y - dx) * g;</span><br><span class="line">    <span class="keyword">return</span> d &gt; eps ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">circmp</span><span class="params">(<span class="keyword">const</span> cp&amp; u, <span class="keyword">const</span> cp&amp; v)</span> </span>&#123; <span class="keyword">return</span> dcmp(u.r - v.r) &lt; <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> cp&amp; u, <span class="keyword">const</span> cp&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dcmp(u.angle - v.angle)) <span class="keyword">return</span> u.angle &lt; v.angle;</span><br><span class="line">    <span class="keyword">return</span> u.d &gt; v.d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">calc</span><span class="params">(cp cir, cp cp1, cp cp2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> ans = (cp2.angle - cp1.angle) * sqr(cir.r) - cross(cir, cp1, cp2) +</span><br><span class="line">                 cross(cp(<span class="number">0</span>, <span class="number">0</span>), cp1, cp2);</span><br><span class="line">    <span class="keyword">return</span> ans * <span class="number">0.5</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CirUnion</span><span class="params">(cp cir[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    cp cp1, cp2;</span><br><span class="line">    sort(cir, cir + n, circmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j)</span><br><span class="line">            <span class="keyword">if</span> (dcmp(dis(cir[i], cir[j]) + cir[i].r - cir[j].r) &lt;= <span class="number">0</span>)</span><br><span class="line">                cir[i].d++;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> tn = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == j) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (CirCrossCir(cir[i], cir[i].r, cir[j], cir[j].r, cp2, cp1) &lt; <span class="number">2</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            cp1.angle = <span class="built_in">atan2</span>(cp1.y - cir[i].y, cp1.x - cir[i].x);</span><br><span class="line">            cp2.angle = <span class="built_in">atan2</span>(cp2.y - cir[i].y, cp2.x - cir[i].x);</span><br><span class="line">            cp1.d = <span class="number">1</span>;</span><br><span class="line">            tp[tn++] = cp1;</span><br><span class="line">            cp2.d = <span class="number">-1</span>;</span><br><span class="line">            tp[tn++] = cp2;</span><br><span class="line">            <span class="keyword">if</span> (dcmp(cp1.angle - cp2.angle) &gt; <span class="number">0</span>) cnt++;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        tp[tn++] = cp(cir[i].x - cir[i].r, cir[i].y, PI, -cnt);</span><br><span class="line">        tp[tn++] = cp(cir[i].x - cir[i].r, cir[i].y, -PI, cnt);</span><br><span class="line">        sort(tp, tp + tn, cmp);</span><br><span class="line">        <span class="keyword">int</span> p, s = cir[i].d + tp[<span class="number">0</span>].d;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; tn; ++j) &#123;</span><br><span class="line">            p = s;</span><br><span class="line">            s += tp[j].d;</span><br><span class="line">            area[p] += calc(cir[i], tp[j - <span class="number">1</span>], tp[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    R = r;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) cir[i].get();</span><br><span class="line">    <span class="built_in">memset</span>(area, <span class="number">0</span>, <span class="keyword">sizeof</span>(area));</span><br><span class="line">    CirUnion(cir, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)  <span class="comment">//去掉重复计算的</span></span><br><span class="line">        area[i] -= area[i + <span class="number">1</span>];   <span class="comment">// area[i]为重叠了i次的面积</span></span><br><span class="line">    <span class="keyword">double</span> tot = <span class="number">0</span>;               <span class="comment">// tot 为总面积</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) tot += area[i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.11lf\n&quot;</span>, area[n]);</span><br><span class="line">    <span class="comment">// printf(&quot;%f\n&quot;, tot);  //这句就是求总面积</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以上是暴力</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%lf&quot;</span>, &amp;n, &amp;r);</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">40</span>) &#123;</span><br><span class="line">            solve();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>, tt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lf%lf&quot;</span>, &amp;p[i].x, &amp;p[i].y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p[i].x &lt; p[t].x || p[i].x == p[t].x &amp;&amp; p[i].y &lt; p[t].y) t = i;</span><br><span class="line">            <span class="comment">//初始选点</span></span><br><span class="line">        &#125;</span><br><span class="line">        tt = nxt(t);</span><br><span class="line">        <span class="keyword">double</span> theta = <span class="number">2</span> * pi / C;</span><br><span class="line">        <span class="keyword">double</span> tql = r * r / <span class="number">2</span> * (theta - <span class="built_in">sin</span>(theta));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; C; i++) &#123;</span><br><span class="line">            <span class="keyword">double</span> q = <span class="number">2</span> * pi * i / C;</span><br><span class="line">            vec x = vec(r * <span class="built_in">cos</span>(q), r * <span class="built_in">sin</span>(q));</span><br><span class="line">            vec y = x.rotate(theta);</span><br><span class="line">            <span class="keyword">while</span> (dcmp(cross(y - x, p[t] - p[tt])) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                t = tt;</span><br><span class="line">                tt = nxt(t);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//找到最优圆</span></span><br><span class="line"> </span><br><span class="line">            l[i] = line(x + p[t], y + p[t]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = half_plane(l, p, C);</span><br><span class="line">        <span class="keyword">double</span> ans = size(p, m);</span><br><span class="line">        <span class="keyword">if</span> (m &gt; <span class="number">2</span>)<span class="comment">//误差矫正</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                <span class="keyword">double</span> x = (p[i + <span class="number">1</span>] - p[i]).len();</span><br><span class="line">                <span class="keyword">double</span> y = <span class="built_in">asin</span>(x / (r * <span class="number">2</span>)) * <span class="number">2</span>;</span><br><span class="line">                ans += (y - <span class="built_in">sin</span>(y)) * r * r / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.12f\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round 703 (Div. 2)</title>
    <url>/CodeforcesR703/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>达成寒假目标：codeforces 2000分！<br>这场比赛题目还比较有趣的</p>
<span id="more"></span>
<h2 id="A-Shifting-Stacks"><a href="#A-Shifting-Stacks" class="headerlink" title="A. Shifting Stacks"></a>A. Shifting Stacks</h2><h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>有 n 堆石子，每堆石子数量为 $h_i$ ($0\leq h_i \leq 10^9$)，每次可以将第 i 堆石子中的一颗石子移动到第 i + 1 堆（ i &lt; n ) ，请问是否可以让石子高度严格递增。</p>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>其实很简单，最好的情况是第 1 堆全部移给第 2 堆，如果第 2 堆至少为 1 则继续，否则说明不能满足题意；然后让第 2 堆石子高度为 1 ，其余的给第 3 堆 ，如果第 3 堆至少为 2 则继续，否则说明不能满足题意…<br>不难发现这样其实对于每一个 i 都要满足 $\sum_{j=1}^{i}h_j \geq \frac{i*(i-1)}{2}$ <br/></p>
<p>参考代码如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T,n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sum;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> f=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123; </span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x),sum+=x;</span><br><span class="line">            <span class="keyword">if</span>(sum&lt;(i*<span class="number">1ll</span>*(i<span class="number">-1</span>)/<span class="number">2</span>))f=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(f)<span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="B-Eastern-Exhibition"><a href="#B-Eastern-Exhibition" class="headerlink" title="B. Eastern Exhibition"></a>B. Eastern Exhibition</h2><h3 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给出 n 个平面上的点，两点间距离为 $|x_1-x_2|+|y_1-y_2|$ ，求出该平面有多少个点可以使得该点到 n 个点的距离之和最小。</p>
<h3 id="题解：-1"><a href="#题解：-1" class="headerlink" title="题解："></a>题解：</h3><p>我们可以将二维点映射成一维点来看<br>距离之和 = $\sum_{i=1}^{n}|X-x_i|+\sum_{i=1}^{n}|Y-y_i|$<br/><br>则，仅对于 x 坐标，求出有多少个 X 满足 $\sum_{i=1}^{n}|X-x_i|$最小，和对于 y 坐标，求出有多少个 Y 满足 $\sum_{i=1}^{n}|Y-y_i|$最小，两者相乘即可。<br/></p>
<ul>
<li>如果 n 为奇数，则很显然为 1</li>
<li>如果 n 为偶数，假设已经按照 x 排好序，则有 $x_{\frac{n}{2}+1}-x_{\frac{n}{2}}+1$ 个 X 满足，Y 求法类似。</li>
</ul>
<p>参考代码如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> T,n;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">&#125;a[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp1</span><span class="params">(node a,node b)</span></span>&#123;<span class="keyword">return</span> a.x&lt;b.x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp2</span><span class="params">(node a,node b)</span></span>&#123;<span class="keyword">return</span> a.y&lt;b.y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a[i].x,&amp;a[i].y);</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;1\n&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            sort(a+<span class="number">1</span>,a+<span class="number">1</span>+n,cmp1);</span><br><span class="line">            <span class="keyword">int</span> mid=n&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> X=a[mid+<span class="number">1</span>].x-a[mid].x+<span class="number">1</span>;</span><br><span class="line">            sort(a+<span class="number">1</span>,a+<span class="number">1</span>+n,cmp2);</span><br><span class="line">            <span class="keyword">int</span> Y=a[mid+<span class="number">1</span>].y-a[mid].y+<span class="number">1</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,X*<span class="number">1ll</span>*Y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="C-Guessing-the-Greatest"><a href="#C-Guessing-the-Greatest" class="headerlink" title="C. Guessing the Greatest"></a>C. Guessing the Greatest</h2><h3 id="题目描述：-2"><a href="#题目描述：-2" class="headerlink" title="题目描述："></a>题目描述：</h3><p>现有一个长度为 n 的无重复数字的数列，只给了你 n ，并未给出每个元素大小<br>你可以进行询问，询问格式为 ? L R ，询问后会返回 [L,R] 中第二大的元素所在位置<br>现在你需要在 20 次询问内找出数组中最大元素的位置。</p>
<h3 id="题解：-2"><a href="#题解：-2" class="headerlink" title="题解："></a>题解：</h3><p>一道简单的交互题<br>首先我们询问 [1,n] 找出第二大元素的位置，假设该位置为 mid<br>接着我们询问 [1,mid] 和 [mid,n] （$mid \neq 1,mid \neq n$），如果其中一个区间询问的答案是 mid 说明最大的元素就在该区间<br/><br>假设最大元素在[1,mid]，我们如果询问 [Mid,mid] 的答案是 mid 说明最大元素在 Mid 右边 ，否则就是在 Mid 左边，这样就可以二分了<br>对于 [mid,n] 同理</p>
<p>不过有些细节要处理下，比如 mid 为 1 或者 n </p>
<p>参考代码如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;? %d %d\n&quot;</span>,L,R);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">int</span> mid=ask(<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">int</span> L,R;</span><br><span class="line">    <span class="keyword">bool</span> f;</span><br><span class="line">    <span class="keyword">if</span>(mid==<span class="number">1</span>||mid==n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(mid==<span class="number">1</span>)&#123;</span><br><span class="line">            L=<span class="number">2</span>,R=n;</span><br><span class="line">            f=<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            L=<span class="number">1</span>,R=n<span class="number">-1</span>;</span><br><span class="line">            f=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p=ask(<span class="number">1</span>,mid);</span><br><span class="line">        <span class="keyword">if</span>(p==mid)&#123;</span><br><span class="line">            L=<span class="number">1</span>,R=mid<span class="number">-1</span>;</span><br><span class="line">            f=<span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            L=mid+<span class="number">1</span>,R=n;</span><br><span class="line">            f=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(!f)&#123;</span><br><span class="line">        <span class="keyword">int</span> Mid;</span><br><span class="line">        <span class="keyword">while</span>(L&lt;=R)&#123;</span><br><span class="line">            Mid=L+R&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(ask(Mid,mid)!=mid)R=Mid<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> L=Mid+<span class="number">1</span>,ans=Mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> Mid;</span><br><span class="line">        <span class="keyword">while</span>(L&lt;=R)&#123;</span><br><span class="line">            Mid=L+R&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(ask(mid,Mid)!=mid)L=Mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> R=Mid<span class="number">-1</span>,ans=Mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;! %d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>yysy代码好丑啊qwq</p>
<h2 id="D-Max-Median"><a href="#D-Max-Median" class="headerlink" title="D. Max Median"></a>D. Max Median</h2><h3 id="题目描述：-3"><a href="#题目描述：-3" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给定以长度为 n 的数列，求出所有长度至少为 k 的子序列中位数的最大值。<br>例如：median([1,2,3,4])=2 , median([3,2,1])=2, median([2,1,2,1])=1</p>
<h3 id="题解：-3"><a href="#题解：-3" class="headerlink" title="题解："></a>题解：</h3><p>这题很简单，就是有点难<br>求中位数其实有套路的，假如我们想求一个数列的中位数，我们可以直接排序，然后求出<br>但其实还可以直接二分中位数的值，我们假设二分的值为 x ，我们让小于 x 的为 1 ，让大于等于 x 的为 -1<br>要注意一下，这里如果元素总数为偶数，中位数并不是中间两个数的平均数，而是中间两个数中较小的一个<br>我们通过分类讨论可以得出，如果总和小于等于 -1 说明中位数大于等于 x </p>
<p>那么这题就好解决了<br>我们二分中位数的大小，然后判断是否存在一个长度至少为 k 的区间的和小于等于 -1<br>很显然可以用前缀和将判断的复杂度优化到 O ( n )<br>一个区间[L,R]的和为 $s_R-s_{L-1}$，我们要找到长度至少为 k 的区间且区间和小于等于-1，即找到$s_R\leq s_{L-1}-1$，且$R-L+1\geq k$，枚举 R ，我们设 $Max=max{s_{0},s_1…s_{R-k}}$，判断$s_R\leq Max-1$即可<br/></p>
<p>参考代码如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[N],b[N];</span><br><span class="line"><span class="keyword">int</span> c[N],s[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;x)c[i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> c[i]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)s[i]=s[i<span class="number">-1</span>]+c[i];</span><br><span class="line">    <span class="keyword">int</span> Max=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=k;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]&lt;=Max<span class="number">-1</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        Max=max(Max,s[i-k+<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]),b[i]=a[i];</span><br><span class="line">    sort(b+<span class="number">1</span>,b+<span class="number">1</span>+n);</span><br><span class="line">    <span class="keyword">int</span> L=<span class="number">1</span>,R=n,mid,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(L&lt;=R)&#123;</span><br><span class="line">        mid=L+R&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(check(b[mid]))L=mid+<span class="number">1</span>,ans=mid;</span><br><span class="line">        <span class="keyword">else</span> R=mid<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,b[ans]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="E-Paired-Payment"><a href="#E-Paired-Payment" class="headerlink" title="E. Paired Payment"></a>E. Paired Payment</h2><h3 id="题目描述：-4"><a href="#题目描述：-4" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给定 n 个点 m 条边的无向图（无自环和重边）<br>规定你每次必须走两条边，即每次从 a 到 b ，再从 b 到 c ，花费为 $(w_{ab}+w_{bc})^2$ ，求从 1 到 所有点的最短路，如果不存在则输出 -1 。<br/></p>
<h3 id="题解：-4"><a href="#题解：-4" class="headerlink" title="题解："></a>题解：</h3><p>首先，非常重要的一个条件：<strong>边权很小！</strong><br>我们不妨将其按照奇/偶分层</p>
<ul>
<li>第 0 层代表通过偶数条边到达</li>
<li>第 i 层代表通过奇数条边到达，且上一条边的权值是 i </li>
</ul>
<p>假设有边 u - &gt; v ，边权为 w<br>将第 0 层的 u 连边权为 0 的边到第 w 层的 v<br>将第 $i(i\in [1,50])$层的 u 连边权为 $(i+w)^2$ 的边到第 0 层的 v<br>对于 v - &gt; u 同理。</p>
<p>那么事实上没必要建这个分层图，只需要在转移的时候改改原图的边权即可<br>很显然分层图可以跑dijkstra，那么不分层也是可以跑dijkstra的<br>让 dis[x][i] 表示第 i 层的 x 点的最短路，然后转移即可。</p>
<p>参考代码如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>,inf=<span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,d[N],nxt[N&lt;&lt;<span class="number">1</span>],to[N&lt;&lt;<span class="number">1</span>],cost[N&lt;&lt;<span class="number">1</span>],tot;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    to[++tot]=b;</span><br><span class="line">    nxt[tot]=d[a];</span><br><span class="line">    d[a]=tot;</span><br><span class="line">    cost[tot]=c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,w,dis;</span><br><span class="line">    node(<span class="keyword">int</span> a = <span class="number">0</span>, <span class="keyword">int</span> b = <span class="number">0</span>, <span class="keyword">int</span> c = <span class="number">0</span>) &#123;</span><br><span class="line">        x=a,w=b,dis=c;</span><br><span class="line">    &#125;<span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> node&amp; other)<span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dis&gt;other.dis;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">priority_queue</span>&lt;node&gt;q;</span><br><span class="line"><span class="keyword">int</span> dis[N][<span class="number">51</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">sqr</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> x*x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dis));</span><br><span class="line">    dis[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    q.push(node(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        node x=q.top();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">if</span>(x.dis&gt;dis[x.x][x.w])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = d[x.x]; i; i = nxt[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> u=to[i];</span><br><span class="line">            <span class="keyword">if</span> (!x.w) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dis[u][cost[i]] &gt; dis[x.x][x.w]) &#123;</span><br><span class="line">                    dis[u][cost[i]]=dis[x.x][x.w];</span><br><span class="line">                    q.push(node(u,cost[i],dis[u][cost[i]]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (dis[u][<span class="number">0</span>] &gt; dis[x.x][x.w] + sqr(x.w + cost[i])) &#123;</span><br><span class="line">                    dis[u][<span class="number">0</span>]=dis[x.x][x.w]+sqr(x.w+cost[i]);</span><br><span class="line">                    q.push(node(u,<span class="number">0</span>,dis[u][<span class="number">0</span>]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(dis[i][<span class="number">0</span>]&lt;=inf)<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,dis[i][<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;-1 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">int</span> u,v,w;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">        ins(u,v,w);</span><br><span class="line">        ins(v,u,w);</span><br><span class="line">    &#125;</span><br><span class="line">    dijkstra();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>cf比赛</tag>
      </tags>
  </entry>
  <entry>
    <title>Educational Codeforces Round 102 (Rated for Div. 2)</title>
    <url>/Educational-Codeforces-Round-102-Rated-for-Div-2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLm1sL2NvbnRlc3QvMTQ3My8=">比赛链接<i class="fa fa-external-link-alt"></i></span></p>
<span id="more"></span>
<h2 id="A-Replacing-Elements"><a href="#A-Replacing-Elements" class="headerlink" title="A.Replacing Elements"></a>A.Replacing Elements</h2><p><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLm1sL2NvbnRlc3QvMTQ3My9wcm9ibGVtL0E=">题目链接<i class="fa fa-external-link-alt"></i></span><br>题目描述：<br>n个元素的数组，可以任取$(i,j,k)$，令 $a_i=a_j+a_k$，问是否可以使得所有数小于等于给定的数d。</p>
<p>题解：<br>很显然，将n个数从小到大排序后，所有$i\geq 3$的数均可被替换成$a_1+a_2$，则判断$a_1+a_2$是否小于等于d或者$a_n$是否小于等于d即可。</p>
<details>
    <summary>参考代码</summary>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> T,d;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">105</span>;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;d);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">        sort(a+<span class="number">1</span>,a+<span class="number">1</span>+n);</span><br><span class="line">        <span class="keyword">if</span>(a[<span class="number">1</span>]+a[<span class="number">2</span>]&lt;=d)<span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[n]&lt;=d)<span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<h2 id="B-String-LCM"><a href="#B-String-LCM" class="headerlink" title="B.String LCM"></a>B.String LCM</h2><p><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLm1sL2NvbnRlc3QvMTQ3My9wcm9ibGVtL0I=">题目链接<i class="fa fa-external-link-alt"></i></span></p>
<p>题目描述：<br>见原题。</p>
<p>题解：<br>1.暴力。直接从大到小枚举gcd长度，并且暴力判断是否符合题意，假设gcd长度为l，第一个串长度为n,第二个为m，则将gcd字符串输出$\frac{n*m}{l*l}$次即可。<br/><br>2.某个引理。待填坑。</p>
<h2 id="C-No-More-Inversions"><a href="#C-No-More-Inversions" class="headerlink" title="C.No More Inversions"></a>C.No More Inversions</h2><p><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLm1sL2NvbnRlc3QvMTQ3My9wcm9ibGVtL0M=">题目链接<i class="fa fa-external-link-alt"></i></span></p>
<p>题目描述：<br>逆序对定义为$i<j,a_i>a_j$。<br/><br>求出一个数组p，令b[i]=p[a[i]]，且要求b的逆序对数小于等于a的逆序对数，并且要最大化b的字典序。</p>
<p>题解：<br>$\because a[k-i]=a[k+i]$<br/><br>$\therefore b[k-i]=b[k+i]$<br/><br>且a数组的逆序对数可以求出来，然后b数组关于k对称，b数组$2*k-n \sim n$的逆序对数也很容易求，即等于a的逆序对数，与p无关。<br>因此b数组前$2*k-n-1$个数不能与任何数形成逆序对，且$2*k-n \sim n$可以任意排列，则前$2*k-n-1$个数从1开始从小到大排，$2*k-n\sim n$从n开始从大到小即可。</p>
<details>
    <summary>参考代码</summary>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*k-n<span class="number">-1</span>;++i)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> Max=k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>*k-n;i&lt;=k;++i)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,Max--);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<h2 id="D-Program"><a href="#D-Program" class="headerlink" title="D.Program"></a>D.Program</h2><p><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLm1sL2NvbnRlc3QvMTQ3My9wcm9ibGVtL0Q=">题目链接<i class="fa fa-external-link-alt"></i></span></p>
<p>题目描述：<br>初始x是0，给定长度为n的字符串，’+’表示x++，’-‘表示x—，给出m次询问[L,R]，忽略[L,R]，问x有多少种取值。<br>例如： ++—+ 若忽略[2,3]则为+-+，x依次为0，1，0，1，共两个取值。</p>
<p>题解：<br>x的值始终是连续的，则求出x的最大值和最小值即可，即前缀和的最大值和最小值。<br>用重载运算符简化代码。</p>
<details>
    <sumamry>参考代码</summary>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>,M=N&lt;&lt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> ch[M][<span class="number">2</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> s,Min,Max;</span><br><span class="line">    node()&#123;</span><br><span class="line">        s=Min=Max=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">node q[M];</span><br><span class="line"><span class="keyword">inline</span> node <span class="keyword">operator</span>+(node a,node b)&#123;</span><br><span class="line">    node c;</span><br><span class="line">    c.Min=min(a.Min,a.s+b.Min);</span><br><span class="line">    c.Max=max(a.Max,a.s+b.Max);</span><br><span class="line">    c.s=a.s+b.s;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="keyword">int</span> n,m,T;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lc ch[x][0]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rc ch[x][1]</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">    x=++cnt;</span><br><span class="line">    <span class="keyword">if</span>(L==R)&#123;</span><br><span class="line">        <span class="keyword">int</span> val=s[L]==<span class="string">&#x27;+&#x27;</span>?<span class="number">1</span>:<span class="number">-1</span>;</span><br><span class="line">        q[x].Min=min(val,<span class="number">0</span>);</span><br><span class="line">        q[x].Max=max(val,<span class="number">0</span>);</span><br><span class="line">        q[x].s=val;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="keyword">int</span> mid=L+R&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    build(lc,L,mid);</span><br><span class="line">    build(rc,mid+<span class="number">1</span>,R);</span><br><span class="line">    q[x]=q[lc]+q[rc];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> node <span class="title">query</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> ll,<span class="keyword">int</span> rr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ll&lt;=L&amp;&amp;R&lt;=rr)<span class="keyword">return</span> q[x];</span><br><span class="line">    <span class="keyword">int</span> mid=L+R&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(rr&lt;=mid)<span class="keyword">return</span> query(lc,L,mid,ll,rr);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(ll&gt;mid)<span class="keyword">return</span> query(rc,mid+<span class="number">1</span>,R,ll,rr);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> query(lc,L,mid,ll,rr)+query(rc,mid+<span class="number">1</span>,R,ll,rr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">        cnt=<span class="number">0</span>;</span><br><span class="line">        build(ch[<span class="number">0</span>][<span class="number">0</span>],<span class="number">1</span>,n);</span><br><span class="line">        <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">            <span class="keyword">int</span> L,R;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;L,&amp;R);</span><br><span class="line">            node x;</span><br><span class="line">            <span class="keyword">if</span>(L!=<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(R!=n)x=query(<span class="number">1</span>,<span class="number">1</span>,n,<span class="number">1</span>,L<span class="number">-1</span>)+query(<span class="number">1</span>,<span class="number">1</span>,n,R+<span class="number">1</span>,n);</span><br><span class="line">                <span class="keyword">else</span> x=query(<span class="number">1</span>,<span class="number">1</span>,n,<span class="number">1</span>,L<span class="number">-1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                <span class="keyword">if</span>(R!=n)x=query(<span class="number">1</span>,<span class="number">1</span>,n,R+<span class="number">1</span>,n);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,-x.Min+x.Max+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<h2 id="E、F、G待填坑"><a href="#E、F、G待填坑" class="headerlink" title="E、F、G待填坑"></a>E、F、G待填坑</h2>]]></content>
      <tags>
        <tag>cf比赛</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round#695 Div.2</title>
    <url>/CodeforcesR695/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="A-Wizard-of-Orz"><a href="#A-Wizard-of-Orz" class="headerlink" title="A. Wizard of Orz"></a>A. Wizard of Orz</h2><p><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLm1sL2NvbnRlc3QvMTQ2Ny9wcm9ibGVtL0E=">题目链接<i class="fa fa-external-link-alt"></i></span><br><span id="more"></span><br>题意：长度为n的数组，选择某一位为任意0~9，从其开始至左右两端逐渐递增（依然在0~9之间），问最大的数。<br>题解：<br>此题有坑，可能会想到第一位为9然后一直递减下去，但这样并不是最大的。<br>如果n&gt;2，则第三位是7，但是如果选第二位是8，则第一位都为9且第三位是9，因此当n&gt;2时选第二位为8即可。</p>
<h2 id="B-Hills-And-Valleys"><a href="#B-Hills-And-Valleys" class="headerlink" title="B. Hills And Valleys"></a>B. Hills And Valleys</h2><p><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLm1sL2NvbnRlc3QvMTQ2Ny9wcm9ibGVtL0I=">题目链接<i class="fa fa-external-link-alt"></i></span><br>题意：给定长度为n的数组，定义山峰为比左右两边都大的数，山谷为比左右两边都小的，可以修改一个数，问最小的山峰山谷数。<br>题解：<br>挺简单的，先求出初始的山峰+山谷数量，然后依次枚举每个数，将其修改为其左边、右边的数然后取最小即可。<br>因为只修改了一个数最多影响三个位置的状态。</p>
<h2 id="C-Three-Bags"><a href="#C-Three-Bags" class="headerlink" title="C. Three Bags"></a>C. Three Bags</h2><p><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLm1sL2NvbnRlc3QvMTQ2Ny9wcm9ibGVtL0M=">题目链接<i class="fa fa-external-link-alt"></i></span><br>题意：给了三组数，每次给以从两个非空数组中各选出一个数，假设先从一个取出A,后一个取出B，则将A-B放入取出A的数组，问最后能得到的最大值。<br>题解：<br>挺不错的思维题。<br>首先如果某一个数被合并了偶数次，那么他是它本身，否则是相反数。<br>能想到这一步基本就做出来了。<br>1.一个数组的情况，如果没有不同的数组的限制，那么想要最大，我们可以让大部分数都合并两次，最小的数合并一次。<br>我们随便取一个除了最小的数之外的数，然后将其他所有的非最小数合并到最小数上，再将最小的数合并到之前那个随便取的数，这样就是最大的，只减去了一个最小的数。<br>2.如果是两个数组，还是假设最后合并的数在第一个数组，则第二个数组无论如何合并都是奇数次，第一个数组无论如何都是偶数次，所以即减去第二个数组的和。<br>3.如果是三个数组，还是假设最后合并的数在第一个数组。<br>我们不妨将第二个数组除了最小的数都合并到第三个数组的最小的数，第三个数组除了最小的数都合并到第二个数组最小的数上。<br>这样再合并到第一个数组大部分数都是合并了偶数次，会比较优。<br>接下来会有两种情况，一种是将这两个数组最小的数都合并到第一个数组，即答案为sum-2*(min[2]+min[3])(sum为所有数总和，min[i]表示第i个数组的最小的数)<br>一种是将其中一个数组的最小的数再合并到另一个最小数上，再合并到第一个数组，这样其实最后答案就是减去了其中一个数组。</p>
<p>然后枚举最后的数所在的数组，再在两种情况中取最大即可。</p>
<p>D E 没做了，打了一半去休息了，以后填坑。（<del>以后你还记得个鬼</del>）</p>
]]></content>
      <tags>
        <tag>cf比赛</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>FFT学习</title>
    <url>/FFT/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="FFT定义"><a href="#FFT定义" class="headerlink" title="FFT定义"></a>FFT定义</h2><blockquote>
<p>FFT（Fast Fourier Transformation）是离散傅氏变换（DFT）的快速算法。即为快速傅氏变换。它是根据离散傅氏变换的奇、偶、虚、实等特性，对离散傅立叶变换的算法进行改进获得的。<br>(yysy这个定义看着乐呵就好)<br><span id="more"></span></p>
</blockquote>
<h2 id="FFT的用处"><a href="#FFT的用处" class="headerlink" title="FFT的用处"></a>FFT的用处</h2><p>在算法竞赛中会碰到卷积形式的计数，或者说多项式乘法，但是常规的计算复杂度是$O(n^2)$的，当 n 比较大的时候，很显然不能满足我们的要求。<br>而FFT将这个过程的复杂度降低到了$O(nlog n)$。</p>
<h2 id="前置芝士"><a href="#前置芝士" class="headerlink" title="前置芝士"></a>前置芝士</h2><h3 id="多项式"><a href="#多项式" class="headerlink" title="多项式"></a>多项式</h3><p>简单来说，形如$a_0+a_1 x+a_2 x^{2}…+a_n a^{n}$的代数表达式叫做多项式，可以记做$f(x)=a_0+a_1 x+a_2 x^{2}…+a_n a^{n}$</p>
<h3 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h3><p>复数形如$a+bi$，其中$i=\sqrt{-1},i*i=-1$<br/><br>a 叫做复数的实部， b 叫做复数的虚部。<br>复数相乘：</p>
<script type="math/tex; mode=display">
(a1+b1i)*(a2+b2i)=(a1*a2-b1*b2)+(a1*b2+a2*b1)i</script><p>复数$c+di$可以用这种方式表示出来：<br><img data-src="https://tu.sunpma.com/imgs/2021/01/f7bce41a38b84035.png" alt=""><br>复数乘法的在复平面中表现为<strong>辐角相加，模长相乘</strong></p>
<h3 id="单位根"><a href="#单位根" class="headerlink" title="单位根"></a>单位根</h3><p>复数 w 满足$w^n=1$，则称 w 是 n 次单位根，下图包含了所有的 8 次方根 （下图中圆的半径是1）<br><img data-src="https://tu.sunpma.com/imgs/2021/01/427fa960f8864b4c.png" alt=""></p>
<p>n 次单位根用 $w_n$ 表示<br/><br>关于单位根有如下性质：<br>1.$w_{2n}^{2}=w_{n}$，因此有$w_{2n}^{2m}=w_{n}^{m}$<br/><br>2.$w_{n}^{\frac{n}{2}}=-1$，因此有$w_{2n}^{m}=-w_{2n}^{m+\frac{n}{2}}$<br/><br>这两个很有用，一定要记住。</p>
<h3 id="多项式的系数表示法"><a href="#多项式的系数表示法" class="headerlink" title="多项式的系数表示法"></a>多项式的系数表示法</h3><p>这是我们常用的表示方法，即$f(x)=a_0+a_1 x+a_2 x^{2}…+a_n a^{n}$的形式，称$A(X)$是多项式$f(x)$的系数表示法。<br/><br>这样多项式乘法是$O(n^2)$</p>
<h3 id="多项式的点值表示法"><a href="#多项式的点值表示法" class="headerlink" title="多项式的点值表示法"></a>多项式的点值表示法</h3><p>即用 n+1 个点表示多项式，可以证明 n+1 个不同的点可以唯一确定一个 n 次多项式。<br>其实就是相当于有 n+1 个方程求 n+1 个未知数（ n 次多项式最高此项是n，最多是 n+1 项）<br>也可以将其理解为解系数矩阵。<br>这样多项式乘法是$O(n)$，因为我们只需要两个多项式分别求出$O(n)$个点，然后相乘即可确定两个多项式相乘后的多项式。<br/></p>
<h2 id="FFT的具体过程"><a href="#FFT的具体过程" class="headerlink" title="FFT的具体过程"></a>FFT的具体过程</h2><p>我们可以看到点值表示法多项式相乘是$O(n)$的，不过要转化为点值相乘却要$O(n^2)$，因此我们要想办法降低这些点值的复杂度。<br/><br>所以FFT即将系数表示法转化为点值表示法再转化回来，其中第一个过程叫 <strong>求值(DFT)</strong>，第二个过程叫 <strong>插值(IDFT)</strong>。</p>
<h3 id="求值"><a href="#求值" class="headerlink" title="求值"></a>求值</h3><p>还记得我们之前提到的单位根吗？回顾一下：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&w_{2n}^{2m}=w_{n}^{m}\\
&w_{n}^{m}=-w_{n}^{m+\frac{n}{2}}\\
\end{aligned}</script><p>设$A_0(X)$为$A(X)$（这里设其为n次多项式，共n+1项，n+1为偶数）偶数项的和，设$A_1(X)$为$A(X)$奇数项的和，即</p>
<script type="math/tex; mode=display">
\begin{aligned}
&A_0(X)=a_0+a_2X+...+a_{n-1}X^{\frac{n}{2}}\\
&A_1(X)=a_1+a_3X+...+a_{n}X^{\frac{n}{2}}\\
\end{aligned}</script><p>因为$A(w_{n}^{m})=a_0w_{n}^{0}+a_1w_n^{m}+a_2w_n^{2m}+…+a_{n}w_{n}^{nm}$<br/><br>将此多项式偶数项和奇数项分别提出来可以得到</p>
<script type="math/tex; mode=display">
\begin{aligned}
&a_0w_n^0+a_2w_n^{2m}+a_4w_n^{4m}+...+a_{n-1}w_n^{(n-1)m}\\
&a_1w_n^m+a_3w_n^{3m}+a_5w_n^{5m}+...+a_{n}w_n^{nm}\\
\end{aligned}</script><p>根据之前的性质可以得出</p>
<script type="math/tex; mode=display">
\begin{aligned}
&A_0(w_{\frac{n}{2}}^{m})=A_0({w_n^{2m}})=a_0w_n^0+a_2w_n^{2m}+a_4w_n^{4m}+...+a_{n-1}w_n^{(n-1)m} \\
&A_1(w_{\frac{n}{2}}^{m})=A_1({w_n^{2m}})=a_1w_n^0+a_3w_n^{2m}+a_5w_n^{4m}+...+a_{n}w_n^{(n-1)m}\\
\end{aligned}</script><p>因此有$A(w_n^m)=A_0(w_{\frac{n}{2}}^m)+w_n^m*A_1(w_{\frac{n}{2}}^m)$<br/></p>
<p>且有$A(w_n^{m+\frac{n}{2}})=A_0(w_{\frac{n}{2}}^{m+\frac{n}{2}})+w_{n}^{m+\frac{n}{2}}*A_1(w_{\frac{n}{2}}^{m+\frac{n}{2}})$<br/></p>
<p>$\because w_{\frac{n}{2}}^{m+\frac{n}{2}}=w_{\frac{n}{2}}^{m}，w_{n}^{m+\frac{n}{2}}=-w_{n}^{m}$<br/></p>
<p>$\therefore A(w_n^{m+\frac{n}{2}})=A_0(w_{\frac{n}{2}}^{m})-w_{n}^{m}*A_1(w_{\frac{n}{2}}^{m})$<br/></p>
<p>这样的话，只要知道了$A_0(X)$和$A_1(X)$的点值表示，就可以$O(n)$求出$A(X)$的点值表示。<br/><br>我们将 $2^k$ 次单位根看做是第 k 层，这样我们知道了第 k-1 层的点值表示，就可以推出第 k 层。<br/><br>假设$f(2^k)$是求$2^k$多项式的复杂度，则有$f(2^k)=2*f(2^{k-1})+2^k$，因此复杂度是$O(k*2^k)$，令$n=2^k$，即$O(n log n)$。</p>
<p>因为这个过程一定要求每层都可以分成两大小相等的部分，所以求的点值必须是$2^k(k\in N)$个，则最高次至多为$2^k-1$，项数至多为$2^k$，如果次数不够，可以将高次项设置为0。</p>
<p>于是我们就有了递归写法：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFT</span><span class="params">(Complex* a,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(len==<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    Complex* a0=<span class="keyword">new</span> Complex[len/<span class="number">2</span>];</span><br><span class="line">    Complex* a1=<span class="keyword">new</span> Complex[len/<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i+=<span class="number">2</span>)&#123;</span><br><span class="line">        a0[i/<span class="number">2</span>]=a[i];</span><br><span class="line">        a1[i/<span class="number">2</span>]=a[i+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    FFT(a0,len/<span class="number">2</span>);FFT(a1,len/<span class="number">2</span>);</span><br><span class="line">    <span class="function">Complex <span class="title">wn</span><span class="params">(<span class="built_in">cos</span>(<span class="number">2</span>*Pi/len),<span class="built_in">sin</span>(<span class="number">2</span>*Pi/len))</span></span>;</span><br><span class="line">    <span class="function">Complex <span class="title">w</span><span class="params">(<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(len/<span class="number">2</span>);i++)&#123;</span><br><span class="line">        a[i]=a0[i]+w*a1[i];</span><br><span class="line">        a[i+len/<span class="number">2</span>]=a0[i]-w*a1[i];</span><br><span class="line">        w=w*wn;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>但递归版的FFT常数巨大，实现起来比较复杂，于是又有了迭代的写法</p>
<p>重新考虑下递归FFT的过程，在第 i 次求解中，我们将所有元素二进制 i 位为 0 的放在了左面，i 位为 1 的放在了右面，事实上，每个元素最终到的是他二进制颠倒过来的位置<br>例如：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>000</th>
<th>001</th>
<th>010</th>
<th>011</th>
<th>100</th>
<th>101</th>
<th>110</th>
<th>111</th>
</tr>
</thead>
<tbody>
<tr>
<td>000</td>
<td>010</td>
<td>100</td>
<td>110</td>
<td>001</td>
<td>011</td>
<td>101</td>
<td>111</td>
</tr>
<tr>
<td>000</td>
<td>100</td>
<td>001</td>
<td>101</td>
<td>010</td>
<td>110</td>
<td>011</td>
<td>111</td>
</tr>
<tr>
<td>000</td>
<td>001</td>
<td>010</td>
<td>011</td>
<td>100</td>
<td>101</td>
<td>110</td>
<td>111</td>
</tr>
</tbody>
</table>
</div>
<p>这样子我们将原数组顺序替换成最下面之后就不用再像递归一样每次把原数组的偶数项放左边，奇数项放右边了。<br>关于如何将二进制反转，其实也不难。<br>假设有个数 x ，我们知道了 x&gt;&gt;1 反转后的数，那么 x 反转后的数和 x&gt;&gt;1 反转后的数就差最高位，而这个最高位是 x 的最低位反转后的，然后就很简单了。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">get_rev</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=<span class="number">1</span>&lt;&lt;s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;(s<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后我们再看看非递归版该怎么向上合并。<br>我们对应要求的$x$的值列出来</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>$w_8^0$</th>
<th>$w_8^1$</th>
<th>$w_8^2$</th>
<th>$w_8^3$</th>
<th>$w_8^4$</th>
<th>$w_8^5$</th>
<th>$w_8^6$</th>
<th>$w_8^7$</th>
</tr>
</thead>
<tbody>
<tr>
<td>$w_4^0$</td>
<td>$w_4^1$</td>
<td>$w_4^2$</td>
<td>$w_4^3$</td>
<td>$w_4^0$</td>
<td>$w_4^1$</td>
<td>$w_4^2$</td>
<td>$w_4^3$</td>
</tr>
<tr>
<td>$w_2^0$</td>
<td>$w_2^1$</td>
<td>$w_2^0$</td>
<td>$w_2^1$</td>
<td>$w_2^0$</td>
<td>$w_2^1$</td>
<td>$w_2^0$</td>
<td>$w_2^1$</td>
</tr>
<tr>
<td>$w_1^0$</td>
<td>$w_1^0$</td>
<td>$w_1^0$</td>
<td>$w_1^0$</td>
<td>$w_1^0$</td>
<td>$w_1^0$</td>
<td>$w_1^0$</td>
<td>$w_1^0$</td>
</tr>
</tbody>
</table>
</div>
<p>首先最下面一层，只用求一个点，这个点只用求$x=w_{1}^{0}=1$的值即可，所以交换后的数组即为最下面一层的初始值。<br>然后从最下面一层慢慢往上推就行了，可以通过手动模拟画图来找到递推的规律。<br>迭代写法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">DFT</span><span class="params">(Complex*a,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        <span class="keyword">if</span>(i&lt;rev[i])<span class="comment">//没这个条件的话，交换两次就会恢复原状</span></span><br><span class="line">            swap(a[i],a[rev[i]]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>,mid=<span class="number">1</span>;i&lt;=n;i&lt;&lt;=<span class="number">1</span>,mid&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="function">Complex <span class="title">wn</span><span class="params">(<span class="built_in">cos</span>(<span class="number">2</span>*PI/i),<span class="built_in">sin</span>(<span class="number">2</span>*PI/i))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j+=i)&#123;</span><br><span class="line">            <span class="function">Complex <span class="title">w</span><span class="params">(<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=j;k&lt;j+mid;++k)&#123;</span><br><span class="line">                Complex x=a[k],y=w*a[k+mid];</span><br><span class="line">                a[k]=x+y,a[k+mid]=x-y;</span><br><span class="line">                w=w*wn;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h3><p>刚刚计算的是 $\vec y = DFT_n(\vec a)$，可以将多项式转化成点值表示，现在为了将点值表示转化成系数表示，需要计算 IDFT（Inverse Discrete Fourier Transform），它是 DFT 的逆</p>

<p>这个问题实际上相当于是一个解线性方程组的问题，也就是给出了 $n$ 个线性方程 \(\begin{equation*} \left\{ \begin{array}{ccccccccc} a_0(\omega_n^0)^{0}&amp;+&amp;\cdots&amp;+&amp;a_{n-2}(\omega_n^0)^{n-2}&amp;+&amp;+a_{n-1}(\omega_n^0)^{n-1}&amp;=&amp;A(\omega_n^0) \\ a_0(\omega_n^1)^{0}&amp;+&amp;\cdots&amp;+&amp;a_{n-2}(\omega_n^1)^{n-2}&amp;+&amp;+a_{n-1}(\omega_n^1)^{n-1}&amp;=&amp;A(\omega_n^1) \\ \vdots &amp; &amp; \vdots &amp; &amp;\vdots&amp; &amp; \vdots &amp; &amp; \vdots\\ a_0(\omega_n^{n-1})^{0}&amp;+&amp;\cdots&amp;+&amp;a_{n-2}(\omega_n^{n-1})^{n-2}&amp;+&amp;+a_{n-1}(\omega_n^{n-1})^{n-1}&amp;=&amp;A(\omega_n^{n-1}) \end{array} \right. \end{equation*}\)</p>

<p>写成矩阵方程的形式就是</p>

<p>\begin{equation} \label{IDFT-equation} \begin{bmatrix} (\omega_n^0)^0 &amp; (\omega_n^0)^1 &amp; \cdots &amp; (\omega_n^0)^{n-1} \\ (\omega_n^1)^0 &amp; (\omega_n^1)^1 &amp; \cdots &amp; (\omega_n^1)^{n-1} \\ \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ (\omega_n^{n-1})^0 &amp; (\omega_n^{n-1})^1 &amp; \cdots &amp; (\omega_n^{n-1})^{n-1} \end{bmatrix} \begin{bmatrix} a_0 \\ a_1 \\ \vdots \\ a_{n-1} \end{bmatrix} = \begin{bmatrix} A(\omega_n^0) \\ A(\omega_n^1) \\ \vdots \\ A(\omega_n^{n-1}) \end{bmatrix} \end{equation}</p>
<p>记上面的系数矩阵为 $\mathbf V$ 现在考虑下面这个矩阵 $d_{ij}=\omega_n^{-ij}$ </p>
<p>\begin{equation} \mathbf D = \begin{bmatrix} (\omega_n^{-0})^0 &amp; (\omega_n^{-0})^1 &amp; \cdots &amp; (\omega_n^{-0})^{n-1} \\ (\omega_n^{-1})^0 &amp; (\omega_n^{-1})^1 &amp; \cdots &amp; (\omega_n^{-1})^{n-1} \\ \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ (\omega_n^{-(n-1)})^0 &amp; (\omega_n^{-(n-1)})^1 &amp; \cdots &amp; (\omega_n^{-(n-1)})^{n-1} \end{bmatrix} \end{equation}</p>
<p>设它们相乘后的结果是 $\mathbf E=\mathbf D \cdot \mathbf V$</p>

<p>\begin{eqnarray} e_{ij} &amp;=&amp; \sum_{k=0}^{n-1} d_{ik} v_{kj} \\ &amp;=&amp; \sum_{k=0}^{n-1} \omega_n^{-ik}\omega_n^{kj} \\ &amp;=&amp; \sum_{k=0}^{n-1} \omega_n^{k(j-i)} \end{eqnarray}</p>
<p>当 $i=j$ 时，$e_{ij}=n$</p>

<p>当 $i\neq j$ 时，</p>

<p>\begin{eqnarray} e_{ij} &amp;=&amp; \sum_{k=0}^{n-1} (\omega_n^{j-i})^k \\ &amp;=&amp; \frac{1-(\omega_n^{j-i})^n}{1-\omega_n^{j-i}}\\ &amp;=&amp; 0 \end{eqnarray}</p>
<p>因此可以知道 $\mathbf I_n=\frac{1}{n}\mathbf E$，所以 $\frac{1}{n}\mathbf D = \mathbf V^{-1}$</p>

<p>将 $\frac{1}{n}\mathbf D$ 在 $\ref{IDFT-equation}$ 左乘就会得到</p>

<p>\begin{equation} \begin{bmatrix} a_0 \\ a_1 \\ \vdots \\ a_{n-1} \end{bmatrix} = \frac{1}{n} \begin{bmatrix} (\omega_n^{-0})^0 &amp; (\omega_n^{-0})^1 &amp; \cdots &amp; (\omega_n^{-0})^{n-1} \\ (\omega_n^{-1})^0 &amp; (\omega_n^{-1})^1 &amp; \cdots &amp; (\omega_n^{-1})^{n-1} \\ \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ (\omega_n^{-(n-1)})^0 &amp; (\omega_n^{-(n-1)})^1 &amp; \cdots &amp; (\omega_n^{-(n-1)})^{n-1} \end{bmatrix} \begin{bmatrix} A(\omega_n^0) \\ A(\omega_n^1) \\ \vdots \\ A(\omega_n^{n-1}) \end{bmatrix} \end{equation}</p>
<p>这样，IDFT 就相当于把 DFT 过程中的 $\omega_n^i$ 换成 $\omega_n^{-i}$，然后做一次 DFT，之后结果除以 $n$ 就可以了。</p>

<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="洛谷P3803-多项式乘法模板题"><a href="#洛谷P3803-多项式乘法模板题" class="headerlink" title="洛谷P3803 多项式乘法模板题"></a>洛谷P3803 多项式乘法模板题</h3><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDM4MDM=">多项式乘法模板<i class="fa fa-external-link-alt"></i></span><br>多项式乘法还是有些细节需要注意：<br>1.自带的complex速度不如手写一个Complex，推荐手写一个Complex，并重载运算符。<br>2.注意数组开的大小。<br>3.此题相乘后是最高次是 n+m 次，因此需要至少 n+m+1 个点值。<br>4.因为精度可能出问题，因此最后需要四舍五入。</p>
<p>下面上代码</p>
<details>
    <summary>参考代码</summary>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Complex</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x,y;<span class="comment">//实部和虚部</span></span><br><span class="line">    Complex(<span class="keyword">double</span> a=<span class="number">0</span>,<span class="keyword">double</span> b=<span class="number">0</span>)&#123;</span><br><span class="line">        x=a;</span><br><span class="line">        y=b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">inline</span> Complex <span class="keyword">operator</span>+(Complex a,Complex b)&#123;<span class="keyword">return</span> Complex(a.x+b.x,a.y+b.y);&#125;</span><br><span class="line"><span class="keyword">inline</span> Complex <span class="keyword">operator</span>-(Complex a,Complex b)&#123;<span class="keyword">return</span> Complex(a.x-b.x,a.y-b.y);&#125;</span><br><span class="line"><span class="keyword">inline</span> Complex <span class="keyword">operator</span>*(Complex a,Complex b)&#123;<span class="keyword">return</span> Complex(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1</span>&lt;&lt;<span class="number">21</span>|<span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">int</span> rev[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">get_rev</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=<span class="number">1</span>&lt;&lt;s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;(s<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">FFT</span><span class="params">(Complex*a,<span class="keyword">int</span> n,<span class="keyword">int</span> p)</span></span>&#123;<span class="comment">//p为1即DFT，p为-1即为IDFT</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        <span class="keyword">if</span>(i&lt;rev[i])</span><br><span class="line">            swap(a[i],a[rev[i]]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>,mid=<span class="number">1</span>;i&lt;=n;i&lt;&lt;=<span class="number">1</span>,mid&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="function">Complex <span class="title">wn</span><span class="params">(<span class="built_in">cos</span>(<span class="number">2</span>*PI/i),p*<span class="built_in">sin</span>(<span class="number">2</span>*PI/i))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j+=i)&#123;</span><br><span class="line">            <span class="function">Complex <span class="title">w</span><span class="params">(<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=j;k&lt;j+mid;++k)&#123;</span><br><span class="line">                Complex x=a[k],y=w*a[k+mid];</span><br><span class="line">                a[k]=x+y,a[k+mid]=x-y;</span><br><span class="line">                w=w*wn;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)a[i].x/=n;</span><br><span class="line">&#125;<span class="keyword">int</span> n,m;</span><br><span class="line">Complex a[N],b[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;++i)<span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;a[i].x);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=m;++i)<span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;b[i].x);</span><br><span class="line">    <span class="keyword">int</span> len=n+m+<span class="number">1</span>,s=<span class="number">1</span>,bit=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(s&lt;len)++bit,s&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">    get_rev(bit);</span><br><span class="line">    FFT(a,s,<span class="number">1</span>),FFT(b,s,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s;++i)a[i]=a[i]*b[i];</span><br><span class="line">    FFT(a,s,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,<span class="keyword">int</span>(a[i].x+<span class="number">0.5</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<h3 id="牛客挑战赛47-E-路径"><a href="#牛客挑战赛47-E-路径" class="headerlink" title="牛客挑战赛47 E.路径"></a>牛客挑战赛47 E.路径</h3><p><span class="exturl" data-url="aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL2NvbnRlc3QvMTA3NDMvRQ==">点分治+FFT<i class="fa fa-external-link-alt"></i></span><br><a href="/牛客挑战赛47E-路径/">题解</a></p>
<blockquote>
<p>参考文章<br><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1dBRHVhbjIvYXJ0aWNsZS9kZXRhaWxzLzc5NTI5OTAw">FFT算法讲解<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cDovL2Jsb2cubWlza2Nvby5jb20vMjAxNS8wNC9wb2x5bm9taWFsLW11bHRpcGxpY2F0aW9uLWFuZC1mYXN0LWZvdXJpZXItdHJhbnNmb3JtI21qeC1lcW4tSURGVC1lcXVhdGlvbg==">从多项式乘法到快速傅里叶变换<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>第一篇讲的是针不戳，就是有些细节有点问题，本文已经处理过了（<del>不保证修bug一定不出新bug qwq</del>）</p>
]]></content>
      <tags>
        <tag>FFT</tag>
      </tags>
  </entry>
  <entry>
    <title>FWT模板</title>
    <url>/FWT%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="FWT（快速沃尔什变换）"><a href="#FWT（快速沃尔什变换）" class="headerlink" title="FWT（快速沃尔什变换）"></a>FWT（快速沃尔什变换）</h2><p>可用于求解形如</p>
<script type="math/tex; mode=display">
C[i\oplus j]=\sum_{i}\sum_{j}a[i]*b[j]</script><p>的式子</p>
<p>其中运算符可以取 异或（^)，或（|），与（&amp;）</p>
<p>证明在此省略，在此只给出封装过后的代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> wjr &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>, inv2 = <span class="number">499122177</span>, inf = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a * <span class="number">1ll</span> * b % mod; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a += b, a &gt;= mod ? a - mod : a; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a -= b, a &lt; <span class="number">0</span> ? a + mod : a; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">int</span> s = <span class="number">1</span>; <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>, a = mul(a, a))<span class="keyword">if</span> (b &amp; <span class="number">1</span>)s = mul(s, a); <span class="keyword">return</span> s; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> T <span class="title">sqr</span><span class="params">(<span class="keyword">register</span> T x)</span> </span>&#123; <span class="keyword">return</span> x * x; &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> wjr;</span><br><span class="line"><span class="keyword">namespace</span> FWT &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1</span>&lt;&lt;<span class="number">20</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">maintain</span><span class="params">(<span class="keyword">int</span>&amp; n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> q=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(q&lt;n)</span><br><span class="line">            q&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">        n=q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FWT_and</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> n, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> step, s, i, j;</span><br><span class="line">        <span class="keyword">for</span> (step = <span class="number">1</span>, s = <span class="number">2</span>; step &lt; n; step &lt;&lt;= <span class="number">1</span>, s &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i += s)</span><br><span class="line">                <span class="keyword">for</span> (j = i; j &lt; i + step; ++j)</span><br><span class="line">                    a[j] = ~p ? add(a[j], a[j + step]) : del(a[j], a[j + step]);</span><br><span class="line">    &#125;<span class="function"><span class="keyword">void</span> <span class="title">FWT_or</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> n, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> step, s, i, j;</span><br><span class="line">        <span class="keyword">for</span> (step = <span class="number">1</span>, s = <span class="number">2</span>; step &lt; n; step &lt;&lt;= <span class="number">1</span>, s &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i += s)</span><br><span class="line">                <span class="keyword">for</span> (j = i; j &lt; i + step; ++j)</span><br><span class="line">                    a[j + step] = ~p ? add(a[j + step], a[j]) : del(a[j + step], a[j]);</span><br><span class="line">    &#125;<span class="function"><span class="keyword">void</span> <span class="title">FWT_xor</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> n, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> step, s, i, j, x;</span><br><span class="line">        <span class="keyword">for</span> (step = <span class="number">1</span>, s = <span class="number">2</span>; step &lt; n; step &lt;&lt;= <span class="number">1</span>, s &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i += s)</span><br><span class="line">                <span class="keyword">for</span> (j = i; j &lt; i + step; ++j) &#123;</span><br><span class="line">                    x = a[j];</span><br><span class="line">                    a[j] = add(a[j], a[j + step]);</span><br><span class="line">                    a[j + step] = del(x, a[j + step]);</span><br><span class="line">                    <span class="keyword">if</span> (~p)<span class="keyword">continue</span>;</span><br><span class="line">                    a[j] = mul(a[j], inv2);</span><br><span class="line">                    a[j + step] = mul(a[j + step], inv2);</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FWTAND</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> n,<span class="keyword">int</span>* b,<span class="keyword">int</span> m,<span class="keyword">int</span>*c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> A[N],B[N];</span><br><span class="line">        <span class="keyword">int</span> len=max(n,m);</span><br><span class="line">        maintain(len);</span><br><span class="line">        <span class="built_in">memcpy</span>(A,a,<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*len);</span><br><span class="line">        <span class="built_in">memcpy</span>(B,b,<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*len);</span><br><span class="line">        FWT_and(A,len,<span class="number">1</span>);</span><br><span class="line">        FWT_and(B,len,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i)</span><br><span class="line">            A[i]=mul(A[i],B[i]);</span><br><span class="line">        FWT_and(A,len,<span class="number">-1</span>);</span><br><span class="line">        len=max(n,m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i)</span><br><span class="line">            c[i]=A[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FWTOR</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> n, <span class="keyword">int</span>* b, <span class="keyword">int</span> m, <span class="keyword">int</span>* c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> A[N], B[N];</span><br><span class="line">        <span class="keyword">int</span> len = max(n, m);</span><br><span class="line">        maintain(len);</span><br><span class="line">        <span class="built_in">memcpy</span>(A, a, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * len);</span><br><span class="line">        <span class="built_in">memcpy</span>(B, b, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * len);</span><br><span class="line">        FWT_or(A, len, <span class="number">1</span>);</span><br><span class="line">        FWT_or(B, len, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">            A[i] = mul(A[i], B[i]);</span><br><span class="line">        FWT_or(A, len, <span class="number">-1</span>);</span><br><span class="line">        len = max(n, m);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">            c[i] = A[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FWTXOR</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> n, <span class="keyword">int</span>* b, <span class="keyword">int</span> m, <span class="keyword">int</span>* c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> A[N], B[N];</span><br><span class="line">        <span class="keyword">int</span> len = max(n, m);</span><br><span class="line">        maintain(len);</span><br><span class="line">        <span class="built_in">memcpy</span>(A, a, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * len);</span><br><span class="line">        <span class="built_in">memcpy</span>(B, b, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * len);</span><br><span class="line">        FWT_xor(A, len, <span class="number">1</span>);</span><br><span class="line">        FWT_xor(B, len, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">            A[i] = mul(A[i], B[i]);</span><br><span class="line">        FWT_xor(A, len, <span class="number">-1</span>);</span><br><span class="line">        len = max(n, m);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">            c[i] = A[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是需要进行取模的代码，模数如有变动请修改参数 mod 以及 inv2 (inv2=(mod+1)&gt;&gt;1)</p>
<p>如果不需要取模的话请自行进行修改，inv2即除以2。</p>
<p>使用方法：</p>
<p>传入 a 数组及大小，b数组及大小，接受答案的数组 c</p>
<p>注意，需要初始化 a，b 数组</p>
<p>对于$len=2^k,len\geq n且2^{k-1}&lt;n$，将a数组从第 n 位到 len-1 位置为0</p>
<p>对于b同理</p>
<p>这是因为快速变换等都只能跑2的整次幂，因此需要初始化（其实是我懒，没有封装初始化）。</p>
]]></content>
      <tags>
        <tag>FWT</tag>
        <tag>快速沃尔什变换</tag>
      </tags>
  </entry>
  <entry>
    <title>Gym - 102433J Interstellar Travel</title>
    <url>/Gym-102433J-Interstellar-Travel/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>给定$n$​个实数三元组$(t_i,s_i,a_i)$​，选定一个$a$，使得$\sum_{i=1}^{n}max(0,t_i-s_i*dist(a,a_i))$最大，其中$dist(a_i,a)=min(|a-a_i|,2\pi-|a-a_i| )$。  </p>
<p>数据范围：$n\leq 10^5,0&lt;t\leq 1000,0\leq s_i\leq1000,0\leq a_i&lt;2*\pi$</p>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>可以不用分段的方法，使用模拟退火可做。  </p>
<p>类似于<span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3Uub3JnL3Byb2JsZW1uZXcvc2hvdy9QMTMzNw==">平衡点<i class="fa fa-external-link-alt"></i></span>的做法  </p>
<p>我们定义初始delta为$\pi$，每次加$delta*rd,rd\in[-1,1]$  </p>
<p>每次使delta减少，例如每次乘0.99，当delta&lt;1e-8时退出循环  </p>
<p>此题不难想到一个贪心我们可以将所有的点表示为$(si<em>cos(a_i),s_i</em>sin(a_i))$，并且将所有的向量加起来，其合向量的方向作为为我们的初始向量  </p>
<p>代码如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> T[N],s[N],a[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">dist</span><span class="params">(<span class="keyword">double</span> angle1, <span class="keyword">double</span> angle2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> delta=<span class="built_in">fabs</span>(angle1-angle2);</span><br><span class="line">    <span class="keyword">return</span> min(delta,<span class="number">2</span>*PI-delta);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">calc</span><span class="params">(<span class="keyword">double</span> angle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        sum+=max(<span class="number">0.0</span>,T[i]-s[i]*dist(a[i],angle));</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"><span class="function">mt19937 <span class="title">mt_rand</span><span class="params">(time(<span class="literal">NULL</span>))</span></span>;</span><br><span class="line"><span class="function">uniform_real_distribution&lt;<span class="keyword">double</span>&gt; <span class="title">rd</span><span class="params">(<span class="number">-1.0</span>,<span class="number">1.0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">maintain</span><span class="params">(<span class="keyword">double</span> Angle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Angle&lt;<span class="number">0</span>)Angle+=<span class="number">2</span>*PI;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(Angle&gt;=<span class="number">2</span>*PI)Angle-=<span class="number">2</span>*PI;</span><br><span class="line">    <span class="keyword">return</span> Angle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">initAngle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> X=<span class="number">0</span>,Y=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        X+=<span class="built_in">cos</span>(a[i])*s[i]/n,Y+=<span class="built_in">sin</span>(a[i])*s[i]/n;</span><br><span class="line">    <span class="keyword">return</span> maintain(<span class="built_in">atan</span>(Y/X));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps=<span class="number">1e-8</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> delta=PI;</span><br><span class="line">    <span class="keyword">double</span> angle=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> ans=calc(angle);</span><br><span class="line">    <span class="keyword">int</span> step=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (delta&gt;eps) &#123;</span><br><span class="line">        <span class="keyword">double</span> RandAngle=maintain(angle+delta*rd(mt_rand));</span><br><span class="line">        <span class="keyword">double</span> RandAns=calc(RandAngle);</span><br><span class="line">        <span class="keyword">if</span> (RandAns &gt; ans) &#123;</span><br><span class="line">            angle=RandAngle;</span><br><span class="line">            ans=RandAns;</span><br><span class="line">        &#125;</span><br><span class="line">        delta*=<span class="number">0.99</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lf%lf%lf&quot;</span>,&amp;T[i],&amp;s[i],&amp;a[i]);</span><br><span class="line">    solve();</span><br><span class="line">    <span class="keyword">double</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;++i)</span><br><span class="line">        ans=max(ans,solve());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.10f\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>模拟退火</tag>
      </tags>
  </entry>
  <entry>
    <title>Gym - 101086C Everything</title>
    <url>/Gym-101086C-Everything/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定$n$​个字符串，询问每次查询每一个字符串最少需要操作数  </p>
<span id="more"></span>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>对于一个字符串，不妨考虑枚举对于其每一个前缀统计答案  </p>
<p>我们求出所有前缀为S的大于当前字符串的数目为suf，前缀为S的字符串的个数为size,则最小操作数为|S|+min(size-suf-1,suf+1)+1  </p>
<p>即输入|S|的操作数，第一次向下的操作  </p>
<p>然后有两种选择，一种是不断按down，一种是先按end，再不断按up，取min即可  </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> T, n;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>, M = N * <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ch[M][<span class="number">26</span>], tot;</span><br><span class="line"><span class="keyword">int</span> siz[M];</span><br><span class="line"><span class="keyword">int</span> pos[N];</span><br><span class="line"><span class="keyword">int</span> dep[M];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i)</span><br><span class="line">        siz[i] = fa[i] = <span class="number">0</span>, <span class="built_in">memset</span>(ch[i], <span class="number">0</span>, <span class="keyword">sizeof</span>(ch[i]));</span><br><span class="line">    tot = <span class="number">1</span>;</span><br><span class="line">    pos[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> p = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!ch[x][p]) &#123;</span><br><span class="line">            ch[x][p] = ++tot;</span><br><span class="line">            fa[tot] = x;</span><br><span class="line">            dep[tot] = dep[x] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        x = ch[x][p];</span><br><span class="line">    &#125;</span><br><span class="line">    pos[++pos[<span class="number">0</span>]] = x;</span><br><span class="line">    siz[x] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//预处理出size</span></span><br><span class="line">    <span class="keyword">if</span> (!x)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) &#123;</span><br><span class="line">        dfs1(ch[x][i]);</span><br><span class="line">        siz[x] += siz[ch[x][i]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//向上跳</span></span><br><span class="line">    <span class="keyword">int</span> suf = siz[x] - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//pre表示该子树下小于该字符串的数目</span></span><br><span class="line">    <span class="comment">//suf表示大于该字符串的数目</span></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> pre = siz[x] - suf - <span class="number">1</span>;</span><br><span class="line">        ans = min(ans, dep[x] + min(pre, suf + <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">1</span>)<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> Fa = fa[x];</span><br><span class="line">        <span class="keyword">for</span> (p = <span class="number">0</span>; p &lt; <span class="number">26</span>; ++p)</span><br><span class="line">            <span class="keyword">if</span> (ch[Fa][p] == x)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = p + <span class="number">1</span>; i &lt; <span class="number">26</span>; ++i) &#123;</span><br><span class="line">            suf += siz[ch[Fa][i]];</span><br><span class="line">        &#125;</span><br><span class="line">        x = Fa;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        tot = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">            insert(s);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs1(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, query(pos[i]));</span><br><span class="line">        clear();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>trie树</tag>
      </tags>
  </entry>
  <entry>
    <title>FST模板</title>
    <url>/FST%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>可用于求</p>
<script type="math/tex; mode=display">
C[T]=\sum a[S]*b[T \oplus S]</script><p>逻辑运算符为异或</p>
<p>也可以写成</p>
<script type="math/tex; mode=display">
C[k]=\sum_{i\&j=0\\i|j=k}a[i]*[j]</script><span id="more"></span>
<p>如果只有 $i | j=k$</p>
<p>那么就是求</p>
<script type="math/tex; mode=display">
C[i|j]=\sum a[i]*b[j]</script><p>因为还有个$i\&amp;j=0$的限制</p>
<p>所以还需要$ctz[i]+ctz[j]=ctz[k]$，其中$ctz[i]$表示i中1的个数</p>
<p>这样的话将原数组$a[1&lt;&lt;N]$拆成 $A[N][1&lt; &lt; N]$即可</p>
<p>$A[ctz[i]][i]=a[i]$初始化</p>
<p>然后再跑FWT即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> wjr &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lb(x) x&amp;-x</span></span><br><span class="line">    <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">9</span>,inv2,inf=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">initial</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        inv2=(mod+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a * <span class="number">1ll</span> * b % mod; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a += b, a &gt;= mod ? a - mod : a; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a -= b, a &lt; <span class="number">0</span> ? a + mod : a; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">int</span> s = <span class="number">1</span>; <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>, a = mul(a, a))<span class="keyword">if</span> (b &amp; <span class="number">1</span>)s = mul(s, a); <span class="keyword">return</span> s; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> T <span class="title">sqr</span><span class="params">(<span class="keyword">register</span> T x)</span> </span>&#123; <span class="keyword">return</span> x * x; &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> wjr;</span><br><span class="line"><span class="keyword">namespace</span> FST &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1</span>&lt;&lt;<span class="number">20</span>;</span><br><span class="line">    <span class="keyword">int</span> ctz[N];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">initial</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ctz[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        ctz[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; ++i) &#123;</span><br><span class="line">            ctz[i]=ctz[i^(i&amp;-i)]+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">maintain</span><span class="params">(<span class="keyword">int</span>&amp; n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> q = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (q &lt; n)</span><br><span class="line">            q &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        n = q;</span><br><span class="line">    &#125;<span class="function"><span class="keyword">void</span> <span class="title">FWT_or</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> n, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> step, s, i, j;</span><br><span class="line">        <span class="keyword">for</span> (step = <span class="number">1</span>, s = <span class="number">2</span>; step &lt; n; step &lt;&lt;= <span class="number">1</span>, s &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i += s)</span><br><span class="line">                <span class="keyword">for</span> (j = i; j &lt; i + step; ++j)</span><br><span class="line">                    a[j + step] = ~p ? add(a[j + step], a[j]) : del(a[j + step], a[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FST</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> n,<span class="keyword">int</span>*b,<span class="keyword">int</span> m,<span class="keyword">int</span>*c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> A[<span class="number">21</span>][<span class="number">1</span>&lt;&lt;<span class="number">20</span>],B[<span class="number">21</span>][<span class="number">1</span>&lt;&lt;<span class="number">20</span>],C[<span class="number">21</span>][<span class="number">1</span>&lt;&lt;<span class="number">20</span>];</span><br><span class="line">        <span class="comment">//没考虑初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">            A[ctz[i]][i]=a[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i)</span><br><span class="line">            B[ctz[i]][i]=b[i];</span><br><span class="line">        <span class="keyword">int</span> len=max(n,m);</span><br><span class="line">        maintain(len);</span><br><span class="line">        <span class="keyword">int</span> lim=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((<span class="number">1</span>&lt;&lt;lim)&lt;len)</span><br><span class="line">            ++lim;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=lim;++i)</span><br><span class="line">            FWT_or(A[i],len,<span class="number">1</span>), FWT_or(B[i], len, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= lim; ++i) </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=i;++j)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; len; ++k) </span><br><span class="line">                    C[i][k]=add(C[i][k],mul(A[j][k],B[i-j][k]));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=lim;++i)</span><br><span class="line">            FWT_or(C[i],len,<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;lim);++i)</span><br><span class="line">            c[i]=C[ctz[i]][i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>答案即是$C[ctz[i]][i]$</p>
<p>我已经封装好了</p>
<p>传入数组a及大小，数组b及大小，以及接受答案的数组c即可</p>
<p>这是需要进行取模的代码，模数如有变动请修改参数 mod 以及 inv2 (inv2=(mod+1)&gt;&gt;1)</p>
<p>如果不需要取模的话请自行进行修改，inv2即除以2。</p>
<p>请自行初始化数组a和b！</p>
]]></content>
      <tags>
        <tag>FST</tag>
        <tag>快速子集变换</tag>
      </tags>
  </entry>
  <entry>
    <title>HNOI2011 Problem b</title>
    <url>/HNOI2011-Problem-b/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul>
<li>莫比乌斯反演入门题，让刚学莫比乌斯反演的我有了继续学下去的欲望。</li>
</ul>
<span id="more"></span>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>n 次询问 $\sum_{i=a}^{b}\sum_{j=c}^{d} [gcd(i,j)==k]$ 。<br><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDI1MjI=">题目链接<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>数学题没啥好说的，这题显然的莫比乌斯反演题，把其变为可以莫比乌斯反演的形式即可。<br>并且可以用一个简单地容斥将下限都换成 1 。<br>设 $f(k)=\sum_{i=1}^{n}\sum_{j=1}^{m}[gcd(i,j)==k]$ ， $F(k)=\sum_{i=1}^{n}\sum_{j=1}^{m}[k|gcd(i,j)]$<br/><br>则有<br>$F(k)=\sum_{k|d}f(d)=\lfloor\frac{n}{k}\rfloor\lfloor\frac{m}{k}\rfloor$<br>前者很显然，后者因为只要求是 k 倍数的gcd，则 i , j 均为 k 的倍数即可。<br>然后我们开始愉快的推式子：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\because F(k)=\sum_{k|d}f(d) \\
&\therefore f(k) =\sum_{k|d}\mu(\frac{d}{k})F(d) \\
\end{aligned}</script><p>即</p>
<script type="math/tex; mode=display">
f(k) = \sum_{k|d}\mu(\frac{d}{k})\lfloor\frac{n}{d}\rfloor \lfloor\frac{m}{d}\rfloor</script><p>再令 $T=\frac{d}{k}$</p>
<script type="math/tex; mode=display">
f(k)=\sum_{T}^{\frac{min(n,m)}{k}}\mu(R)\lfloor\frac{n}{kT}\rfloor \lfloor\frac{m}{kT}\rfloor</script><p>然后整除分块即可。<br>关于整除分块，其实就是将$\frac{n}{kT}\frac{m}{KT}$相同的一起处理<br/><br>比如当$T\in(L,R)$时$\frac{n}{kT}\frac{m}{KT}$相同，则这一部分答案为$\frac{n}{kT}\frac{m}{KT}\sum_{i=L}^{R}\mu(i)$，预处理一下莫比乌斯函数的前缀和就好。</p>
<p>代码如下<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">5e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> prime[N],mu[N];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum[N];</span><br><span class="line"><span class="keyword">bool</span> f[N];</span><br><span class="line"><span class="keyword">int</span> a,b,c,d,k;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>]=<span class="number">1</span>,f[<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> maxn=<span class="number">5e4</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=maxn;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!f[i])&#123;</span><br><span class="line">            prime[++prime[<span class="number">0</span>]]=i;</span><br><span class="line">            mu[i]=<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=prime[<span class="number">0</span>]&amp;&amp;i*prime[j]&lt;=maxn;++j)&#123;</span><br><span class="line">            f[i*prime[j]]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">            mu[i*prime[j]]=-mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=maxn;++i)</span><br><span class="line">        sum[i]=sum[i<span class="number">-1</span>]+mu[i];</span><br><span class="line">&#125;<span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">F</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    n/=k,m/=k;</span><br><span class="line">    <span class="keyword">int</span> maxn=min(n,m);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>,r=<span class="number">1</span>;l&lt;=maxn;l=r+<span class="number">1</span>)&#123;</span><br><span class="line">        r=min(n/(n/l),m/(m/l));</span><br><span class="line">        ans+=(sum[r]-sum[l<span class="number">-1</span>])*(n/l)*(m/l);</span><br><span class="line">    &#125;<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c,&amp;d,&amp;k);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,F(b,d,k)-F(b,c<span class="number">-1</span>,k)-F(a<span class="number">-1</span>,d,k)+F(a<span class="number">-1</span>,c<span class="number">-1</span>,k));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title>LOJ6515 「雅礼集训 2018 Day10」贪玩蓝月</title>
    <url>/LOJ6515%E8%B4%AA%E7%8E%A9%E8%93%9D%E6%9C%88/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><span class="exturl" data-url="aHR0cHM6Ly9vaS13aWtpLm9yZy9kcy9xdWV1ZS8jXzM=">前置知识&amp;wiki题解<i class="fa fa-external-link-alt"></i></span></p>
<span id="more"></span>
<p>此题如果是栈的形式，则非常好维护DP<br>因为删除栈顶DP不变，栈顶增加元素只用$O(p)$修改DP<br/><br>因此就用到到了<strong>双栈模拟队列</strong></p>
<h2 id="双栈模拟队列"><a href="#双栈模拟队列" class="headerlink" title="双栈模拟队列"></a>双栈模拟队列</h2><p>设 F , S 分别是队尾和队首的栈，支持 push（在队尾插入），pop（在队首弹出）操作：</p>
<ul>
<li>push：插入到栈 F 中。</li>
<li>pop：如果 S 非空，让 S 弹栈；否则把 F 的元素倒过来压到 S 中（其实就是一个一个弹出插入，做完后是首位颠倒的），然后再让 S 弹栈。</li>
</ul>
<p>容易证明，每个元素只会进入/转移/弹出一次，均摊复杂度$O(1)$ 。</p>
<h2 id="双栈模拟双端队列"><a href="#双栈模拟双端队列" class="headerlink" title="双栈模拟双端队列"></a>双栈模拟双端队列</h2><p>与双栈模拟队列相似，仅pop改变</p>
<ul>
<li>pop时，若栈为空，将另一个栈（设元素大小为siz)的前$\frac{siz+1}{2}$倒着压入该栈并弹出一个<br>这样到下一次pop时为空最少需要$\frac{siz}{2}$次pop<br/><br>这样的话均摊复杂度是$O(1)$的</li>
</ul>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>设 $f[i,j]$ 表示前 i 个二元组，余数为 j 的最大价值</p>
<script type="math/tex; mode=display">
f[i][j]=max(f[i-1][j],f[i-1][(j-w_i+p)\%p]+v_j)</script><p>用双栈模拟队列即可很容易的分别维护队首和队尾的 f<br>询问可用单调队列优化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> w,v;</span><br><span class="line">    node(<span class="keyword">int</span> a = <span class="number">0</span>, <span class="keyword">int</span> b = <span class="number">0</span>) &#123;</span><br><span class="line">        w=a,v=b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">5e4</span>+<span class="number">10</span>,M=<span class="number">505</span>;</span><br><span class="line"><span class="keyword">int</span> m,p;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">int</span> _(<span class="keyword">int</span> x) &#123; <span class="keyword">return</span> (x + p) % p; &#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stk</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> dp[N][M], top;</span><br><span class="line">    node st[N];</span><br><span class="line">    stk() &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">500</span>;++i)</span><br><span class="line">            dp[<span class="number">0</span>][i]=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p; ++i) &#123;</span><br><span class="line">            dp[top][i]=dp[top<span class="number">-1</span>][i];</span><br><span class="line">            <span class="keyword">int</span> k=_(i-st[top].w);</span><br><span class="line">            <span class="keyword">if</span>(~dp[top<span class="number">-1</span>][k])</span><br><span class="line">                dp[top][i]=max(dp[top][i],dp[top<span class="number">-1</span>][k]+st[top].v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;a[<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> o,node x)</span> </span>&#123;</span><br><span class="line">    a[o].st[++a[o].top]=x;</span><br><span class="line">    a[o].update();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">(<span class="keyword">int</span> o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a[o].top) &#123;</span><br><span class="line">        --a[o].top;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="keyword">int</span> k=!o;</span><br><span class="line">    <span class="keyword">int</span> mid=(a[k].top+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>,top=a[k].top;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=mid;i&gt;=<span class="number">1</span>;--i)push(o,a[k].st[i]);</span><br><span class="line">    a[k].top=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=mid+<span class="number">1</span>;i&lt;=top;++i)push(k,a[k].st[i]);</span><br><span class="line">    --a[o].top;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> q[N],ql,qr;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    ql=<span class="number">1</span>,qr=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> k1=a[<span class="number">0</span>].top,k2=a[<span class="number">1</span>].top;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l - p + <span class="number">1</span>; i &lt;= r - p + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x=a[<span class="number">1</span>].dp[k2][_(i)];</span><br><span class="line">        <span class="keyword">while</span>(ql&lt;=qr&amp;&amp;a[<span class="number">1</span>].dp[k2][q[qr]]&lt;=x)--qr;</span><br><span class="line">        q[++qr]=_(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = p - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(ql&lt;=qr&amp;&amp;~a[<span class="number">0</span>].dp[k1][i]&amp;&amp;~a[<span class="number">1</span>].dp[k2][q[ql]])</span><br><span class="line">            ans=max(ans,a[<span class="number">0</span>].dp[k1][i]+a[<span class="number">1</span>].dp[k2][q[ql]]);</span><br><span class="line">        <span class="keyword">if</span>(ql&lt;=qr&amp;&amp;_(l-i)==q[ql])++ql;</span><br><span class="line">        <span class="keyword">int</span> x=a[<span class="number">1</span>].dp[k2][_(r-i+<span class="number">1</span>)];</span><br><span class="line">        <span class="keyword">while</span>(ql&lt;=qr&amp;&amp;a[<span class="number">1</span>].dp[k2][q[qr]]&lt;=x)--qr;</span><br><span class="line">        q[++qr]=_(r-i+<span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> kase;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;kase);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;m,&amp;p);</span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> v,w;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d&quot;</span>,s,&amp;w,&amp;v);</span><br><span class="line">        <span class="keyword">int</span> o=s[<span class="number">1</span>]==<span class="string">&#x27;F&#x27;</span>?<span class="number">0</span>:<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">&#x27;I&#x27;</span>)push(o,node(_(w),v));</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">&#x27;D&#x27;</span>)pop(o);</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,query(w,v));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>双端队列</tag>
        <tag>单调队列</tag>
        <tag>双栈模拟队列</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>线性筛学习</title>
    <url>/Linear%20sieve/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>最简单的，最容易想到的筛素数的应该就是直接从小到大，将每个素数的2以上的倍数筛掉了，这个方法复杂度约为 O(N ln ln N)。</p>
<span id="more"></span>
<p>举个栗子：<br>初始：&emsp;&emsp; &emsp; &nbsp;&nbsp;&nbsp; 1 2 3 4 5 6 7 8 9 10 11 12<br>第一次（2）：&nbsp;&nbsp; 1 2 3 5 7 9 11<br>第二次（3）：&nbsp;&nbsp; 1 2 3 5 7 11<br>第三次（5）： &nbsp;&nbsp;1 2 3 5 7 11<br>第四次（7）： &nbsp;&nbsp;1 2 3 5 7 11<br>第五次（11）：1 2 3 5 7 11</p>
<p>如果每次并非是用素数进行筛，复杂度是O(N lnN)（调和级数），因为只用素数筛去，因此复杂度进一步降低了。</p>
<p>不过这个方法并不是线性的，下面来重点介绍下线性筛。</p>
<h2 id="线性筛"><a href="#线性筛" class="headerlink" title="线性筛"></a>线性筛</h2><p>线性筛本质就是让一个数只被筛去一次，而上述的筛法（Eratosthenes筛法）有很多数其实不止被筛去了一次。<br>我们考虑让每个非素数 x=p*q ，其中 p 是 x 分解质因数的最小质数，我们仅让其能被 q 筛去，这样因为每个数仅有一个最小质因数，所以只会被筛去一次，且每个非素数一定会被筛去，因为我们总是能找到这样的 p 和 q </p>
<h3 id="那么如何实现呢？"><a href="#那么如何实现呢？" class="headerlink" title="那么如何实现呢？"></a>那么如何实现呢？</h3><p>将 q 分解质因数，则 q 也存在一个最小的质因数，假设为 c ，则当 p 不大于 c 时，即代表可以筛去。<br>不过实际上不用求出 q 的最小质因数。<br>我们假设当前是 i ，且我们用了另一个数组 pri 存下来当前找到的所有素数（从小到大），然后考虑用 i 用上述方法筛去非素数，枚举素数，当 i%pri[j]==0 时停止即可，此时代表 i 存在一个 pri[j]这个素数，当 j 继续增加，i 分解质因数后的最小素数比 pri[j]更小，这样会导致部分数筛去多次，因此需要停止。</p>
<p>举个栗子：<br>初始：&emsp;&emsp;&emsp;&nbsp;&nbsp;       1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16<br>第一次（2）：1 2 3 5 6 7 8 9 10 11 12 13 14 15 16  （pri:2，筛去2*2=4并停止）<br>第二次（3）：1 2 3 5 7 8 10 11 12 13 14 15 16  （pri:2,3，筛去3*2=6，3*3=9并停止）<br>第三次（4）：1 2 3 5 7 10 11 12 13 14 15 16  （pri:2,3，筛去4*2=6并停止）<br>第四次（5）：1 2 3 5 7 11 12 13 14 16 （pri:2,3,5，筛去5*2=10，5*3=15并停止）<br>第五次（6）：1 2 3 5 7 11 13 14 16  （pri:2,3,5，筛去6*2并停止）<br>第六次（7）：1 2 3 5 7 11 13 16  （pri:2,3,5,7，筛去7*2=14并停止）<br>第七次（8）：1 2 3 5 7 11 13 （pri:2,3,5,7，筛去8*2=16并停止）<br>…</p>
<p>代码如下<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> pri[maxn];</span><br><span class="line"><span class="keyword">bool</span> f[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">    f[<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!f[i])pri[++pri[<span class="number">0</span>]]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=pri[<span class="number">0</span>]&amp;&amp;i*pri[j]&lt;=n;++j)&#123;</span><br><span class="line">            f[i*pri[j]]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%pri[j]==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>线性筛也可以用于求欧拉函数、莫比乌斯函数，因此弄懂线性筛的原理很重要！</p>
]]></content>
      <tags>
        <tag>线性筛</tag>
      </tags>
  </entry>
  <entry>
    <title>线形基学习</title>
    <url>/Linear%20basis/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>基（basis）是线性代数中的一个概念，它是描述、刻画向量空间的基本工具。而在现行的 OI 题目中，通常在利用基在异或空间中的一些特殊性质来解决题目，而这一类题目所涉及的知识点被称作「线性基」。（大部分求线性基类似于线代里面的矩阵求最大线性无关组）</p>
</blockquote>
<span id="more"></span>
<p>可以将每个数 x 转为二进制，将其看成一个向量。线性基即求 m 个向量，<strong>这 m 个向量线性无关</strong>（即任意一个向量不能被其他任意个向量表示出），且 m 个向量可以表示出原数组的所有向量。</p>
<p>则如果 x 为 0 ，或者 x 可以被线性基表示出，不加入线性基，否则加入线性基。</p>
<h2 id="那么如何快速得出-x-是否可以被线性基表示出？"><a href="#那么如何快速得出-x-是否可以被线性基表示出？" class="headerlink" title="那么如何快速得出 x 是否可以被线性基表示出？"></a>那么如何快速得出 x 是否可以被线性基表示出？</h2><p>可以使用高斯消元，假设线性基加入 x 后高斯消元有全为 0 的行，则说明 x 可以被表示出。<br>如果不能表示出则可以直接加入线性基。</p>
<p>在最后跑高斯消元，因为 x 转为二进制的长度有限，假设为 k ，则消元后的主元（即每一行中第一个非零元素）数最多也为 k，若大于k，则说明还能继续消元下去。<br><strong>因此我们得到了一个最多 k 个向量的线性基</strong>，该线性基在高斯消元前即为原数组中的最多 k 个元素，且这 k 个元素可以表示原数组所有数，因为未加入到线性基的数均为 0 或者可以被线性基表示的数。</p>
<p>不过因为异或的特殊性质，可以不用高斯消元求解。<br>如果是用向量写的话，正规来说，应该是将k个向量竖着组成一个矩阵，然后高斯消元，我们为了减小复杂度，可以将其横着放，将第 i 个数二进制对应的第 j 位放在矩阵的第 i 行第 j 列。<br>这样的话，行化简即为异或。<br>举个栗子，原数组为{7,1,4,3,5}<br>加入 7 ，矩阵变为<br>\begin{bmatrix}<br>1 &amp; 1 &amp; 1<br>\end{bmatrix}</p>
<p>加入 1 ，矩阵变为<br>\begin{bmatrix}<br>1 &amp; 1 &amp; 1\\<br>0 &amp; 0 &amp; 1<br>\end{bmatrix}</p>
<p>高斯消元后变为<br>\begin{bmatrix}<br>1 &amp; 1 &amp; 0\\<br>0 &amp; 0 &amp; 1<br>\end{bmatrix}</p>
<p>加入 4 ，矩阵变为<br>\begin{bmatrix}<br>1 &amp; 1 &amp; 0\\<br>0 &amp; 0 &amp; 1\\<br>1 &amp; 0 &amp; 0<br>\end{bmatrix}</p>
<p>高斯消元后变为<br>\begin{bmatrix}<br>1 &amp; 0 &amp; 0\\<br>0 &amp; 1 &amp; 0\\<br>0 &amp; 0 &amp; 1<br>\end{bmatrix}</p>
<p>加入 3 ,矩阵变为<br>\begin{bmatrix}<br>1 &amp; 0 &amp; 0\\<br>0 &amp; 1 &amp; 0\\<br>0 &amp; 0 &amp; 1\\<br>0 &amp; 1 &amp; 1<br>\end{bmatrix}</p>
<p>高斯消元后变为<br>\begin{bmatrix}<br>1 &amp; 0 &amp; 0\\<br>0 &amp; 1 &amp; 0\\<br>0 &amp; 0 &amp; 1\\<br>0 &amp; 0 &amp; 0<br>\end{bmatrix}</p>
<p>因此 3 不能加入线性基，同理，5也是。</p>
<p>因此最后线性基中的元素为4,2,1，其异或和可以表示所有原数组中的任意异或和。</p>
<p>这样求需要对换两行，但其实这一步也可以省略。</p>
<p>即我们设$d[i]$表示主元是第 i 列的线性基中的数，我们插入一个数 x 时，从高位到低位，假设当前是第 i 位，且 x 的第 i 位为 1 ，如果 d[i]=0 ，则令$d[i]=x$即可，否则令 $x=x\oplus d[i]$，并继续下去。<br/><br>证明很显然。</p>
<ul>
<li>当 x 到了第 i 位，则高位一定全是0，此时第 i 为 1 且d[i]不存在，则肯定不会被消去，则 x 一定会加入线性基。</li>
<li>如果 d[i] 已经存在，则仿照高斯消元，将 x 的第 i 位消成 0 ，再继续即可。</li>
</ul>
<p>注意：这种方法也分两种写法，一种是每次加入后从下往上消去，一种是全部加入完后再从下往上消去，本质是一样的。<br>（在线代中从上往下消即向前步骤，从下往上消为向后步骤，为了理解更简单，之后会一直以向上/向下消去代替，不过我觉得学线性基的估计都是学了高斯消元的吧）</p>
<p>代码如下（后消去）：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">60</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">        <span class="keyword">if</span>(x&amp;(<span class="number">1ll</span>&lt;&lt;i))&#123;</span><br><span class="line">            <span class="keyword">if</span>(d[i])x^=d[i];</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                d[i]=x;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">60</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i<span class="number">-1</span>;j&gt;=<span class="number">0</span>;--j)</span><br><span class="line">            <span class="keyword">if</span>(d[i]&amp;(<span class="number">1ll</span>&lt;&lt;j))d[i]^=d[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="线性基的性质及证明"><a href="#线性基的性质及证明" class="headerlink" title="线性基的性质及证明"></a>线性基的性质及证明</h2><ul>
<li>原序列里面的任意一个数都可以由线性基里面的一些数异或得到</li>
<li>线性基的元素能相互异或得到原集合的元素的所有相互异或得到的值。</li>
<li>线性基没有异或和为 0 的子集。</li>
<li>线性基是满足性质 1 的最小的集合。</li>
<li>线性基中每个元素的异或方案唯一，也就是说，线性基中不同的异或组合异或出的数都是不一样的。</li>
<li>线性基中每个元素的二进制最高位互不相同。</li>
<li>线性基的元素的所有相互异或得到的值均可由原集合的元素相互异或得到。</li>
</ul>
<p>证明如下：</p>
<h3 id="性质1"><a href="#性质1" class="headerlink" title="性质1"></a>性质1</h3><p>线性基构造时我们即能被线性基得到的不加入，否则加入。<br>假设加入的数为 x ，高斯消元后变为 $x\oplus y$，则$x\oplus y \oplus y$即为 x ，y可以被线性基表示，因此性质1得证。</p>
<h3 id="性质2"><a href="#性质2" class="headerlink" title="性质2"></a>性质2</h3><p>因为原数组每个数都能被线性基异或得到，因此原数组相互异或得到的所有数均可以被线性基中若干个数异或得到。</p>
<h3 id="性质3"><a href="#性质3" class="headerlink" title="性质3"></a>性质3</h3><p>如果存在异或为 0 的子集，则与构造方法不符，因为此时必定会出现至少一行无主元，则说明至少有一个不该插入的数插入，因此当方法正确时线性基中的任意数异或不能为 0 。</p>
<h3 id="性质4"><a href="#性质4" class="headerlink" title="性质4"></a>性质4</h3><p>因为所有能被表示的数都被剔除了，能插入到线性基中的数均为不能被线性基表示的数，因此得证。</p>
<h3 id="性质5"><a href="#性质5" class="headerlink" title="性质5"></a>性质5</h3><p>即性质 2 的变形。</p>
<h3 id="性质6"><a href="#性质6" class="headerlink" title="性质6"></a>性质6</h3><p>高斯消元后不同行的主元不会出现在相同列，否则可以继续消元，因此性质6得证。</p>
<h3 id="性质7"><a href="#性质7" class="headerlink" title="性质7"></a>性质7</h3><p>很显然在高斯消元前线性基中的元素即为原集合的部分元素，因此高斯消元后，任何线性基的元素可以被表示为若干个原集合的元素的异或和。<br>之后即性质2。<br>因此线性基任意异或得到的数的集合与原集合中任意异或得到的数的集合完全相同（0除外，因为线性基规定不能异或出0）。</p>
<h2 id="如何求最大值"><a href="#如何求最大值" class="headerlink" title="如何求最大值"></a>如何求最大值</h2><p>其实和0/1 trie树求最大异或值差不多。<br>从高位到低位，若当前是第 i 位，若$(ans\oplus d[i]) &gt; ans$，则$ans=ans\oplus d[i]$即可。<br/><br>证明：<br>如果 ans 第 i 位是 1 ，若 d[i] 不为 0 ，则 d[i] 第 i 位是 1 ，则异或后肯定更小。<br>如果 ans 第 i 位是 0 ，若 d[i] 不为 0 ，则 d[i] 比 i 位更高的位均为 0 ，且第 i 位是 1 ，因此异或后肯定更大。</p>
<p>因此也可以看出其实可以有两种写法，具体效率相差多少我不清楚qwq。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDM4MTI=">异或最大值模板题<i class="fa fa-external-link-alt"></i></span></p>
<details>
    <summary>参考代码</summary>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">52</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> d[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">50</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">        <span class="keyword">if</span>(x&amp;(<span class="number">1ll</span>&lt;&lt;i))&#123;</span><br><span class="line">            <span class="keyword">if</span>(d[i])x^=d[i];</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                d[i]=x;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">get_Max</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">50</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">        <span class="keyword">if</span>((ans^d[i])&gt;ans)</span><br><span class="line">            ans^=d[i];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;<span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> x;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;x);</span><br><span class="line">        add(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,get_Max());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<p>此代码并未向上消元，仅仅只是最大值/最小值的话没必要。</p>
<h2 id="如何求最小值"><a href="#如何求最小值" class="headerlink" title="如何求最小值"></a>如何求最小值</h2><p>1.如果线性基元素个数小于原集合元素个数，说明至少有一个未能成功插入线性基，则这个数要么是 0 要么可以被线性基中的数表示，两种情况最小值均为0。<br>2.如果线性基元素等于原集合元素个数。<br>我们假设最小值为$d_{a_1}\oplus d_{a_2}\oplus d_{a_3}…\oplus d_{a_m}$ ，且$a_1&lt; a_2 &lt;…&lt; a_m$，则最高位一定是$a_m$，必定大于$d_{a_1}$，因为后者最高位是$a_1$。<br/><br>所以可以知道最小值是最小的$d$，因为最小值不为 0 ，因此为最小的$d_i(d_i!=0)$。</p>
<h2 id="如何求第k小"><a href="#如何求第k小" class="headerlink" title="如何求第k小"></a>如何求第k小</h2><p>之前求最大和最小均可以不用向上消元，但是求第 k 小就需要向上消元了。<br>在高斯消元后每个主元所在列除了该主元所在行之外均为0。<br>若有$d_{a_1}\oplus d_{a_2}…\oplus d_{a_m}$，且$a_1&lt; a_2…&lt; a_m$，则第 $a_1,a_2…,a_m$位均为 1 ，因为有且仅有$d_{a_1}$第$a_1$位是1，其他同理。<br/><br>现在考虑比较由线性基异或得到的不同的两个数的大小，假设$x=d_{a_1}\oplus d_{a_2}…\oplus d_{a_p},y=d_{b_1}\oplus d_{b_2}…\oplus d_{b_q}$ ，且$a_1 &lt; a_2…&lt; a_p,b_1 &lt; b_2…&lt; b_q$，且$d_{a_1},d_{a_2}…，d_{a_p} ,d_{b_1},d_{b_2}…d_{b_q}$均不为0<br/><br>1.若$a_p &lt; a_q$ ，则$x &lt; y$<br/><br>2.若$a_p &gt; a_q$ ，则$x &gt; y$<br/><br>3.若$a_p = a_q$ ，则比较$a_{p-1}$和$b_{q-1}$ ，假设$a_{p-1}&gt;b_{q-1}$，则比$a_{p-1}$高的位不变，且第$a_{p-1}$位 x 是 1，y 是 0，因此$x&gt;y$ ，$a_{p-1} &lt; b_{q-1}$则$x &lt; y$，当$a_{p-1}=b_{q-1}$时，不妨将$d_{a_{p}}\oplus d_{a_{p-1}}$当成新数，并继续这样下去。<br/></p>
<p>因此可以发现仅比较$a_{1}，a_{2}…a_{p}，b_{1},b_{2}…b_{q}$即可。<br/><br>我们用另一个数组 p ，令p[i] 表示从低到高位第 i+1 个非零的 d<br>将 k 表示为二进制，则如果$k\&amp;(1ll &lt;&lt; i)$，令$ans = ans \oplus p[i]$即可。<br/></p>
<p>最大值即为所有异或起来，最小值需要讨论。</p>
<p>如果原集合能异或出 0 ，即线性基中元素个数 cnt &lt; 原集合元素个数 n ，那么最小值为 0 。<br>如果不能异或出 0 ，即为 p[0]。<br>因此其实能异或出的元素个数也能求出来。</p>
<ul>
<li>如果 cnt &lt; n ，则能异或出的数为 $2^{cnt}$。<br/></li>
<li>如果 cnt = n ，则能异或出的数为 $2^{cnt}-1$。<br/></li>
</ul>
<p>因此当求第 k 小时有几点需要注意：</p>
<ul>
<li>cnt &lt; n 时 ，能异或出的数的个数为 $2^{cnt}$（可以有 0 ）。<br/></li>
<li>cnt = n 时 ， 能异或出的数的个书屋 $2^{cnt}-1$（不能有 0 ）。<br/></li>
<li>当 k=1 时 ，如果 cnt &lt; n ，则最小是 0 。</li>
<li>当 k 不为 1 ，且 cnt &lt; n 时，因为最小值是 0 ，而 0 被算成了第 0 小，因此需要令$k=k-1$。</li>
</ul>
<p><span class="exturl" data-url="aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL2NvbnRlc3QvMTA4NDUvRQ==">异或第k小例题+二分<i class="fa fa-external-link-alt"></i></span></p>
<blockquote>
<p>hack数据：<br>2 12<br>13 2</p>
</blockquote>
<p><a href="/2021/01/17/牛客挑战赛76E-牛牛数数/">题解</a></p>
<h2 id="判断一个数是否能被当前元素异或得到"><a href="#判断一个数是否能被当前元素异或得到" class="headerlink" title="判断一个数是否能被当前元素异或得到"></a>判断一个数是否能被当前元素异或得到</h2><p>即看是否能插入到线性基中，如果不能则说明可以，否则说明不行。</p>
<blockquote>
<p>参考文章<br><span class="exturl" data-url="aHR0cHM6Ly9vaS13aWtpLm9yZy9tYXRoL2Jhc2lzLyNfX2NvbW1lbnRz">线性基 OI wiki<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLnNlbmd4aWFuLmNvbS9hbGdvcml0aG1zL2xpbmVhci1iYXNpcw==">线性基学习笔记<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FfZm9yZXZlcl9kcmVhbS9hcnRpY2xlL2RldGFpbHMvODM2NTQzOTc=">线性基详解<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
]]></content>
      <tags>
        <tag>线性基</tag>
      </tags>
  </entry>
  <entry>
    <title>2019-2020 ICPC Asia Hong Kong Regional Contest J.Junior Mathematician</title>
    <url>/Junior-Mathematician/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="数位DP题"><a href="#数位DP题" class="headerlink" title="数位DP题"></a>数位DP题</h3><span id="more"></span>
<p>此题可以选择从高位到低位转移或者低位到高位转移，我两种都试了一下，其实差不多。</p>
<p>最简单的方法是记$dp[i][j][k][l]$表示转移到第$i$位（从高到低或者从低到高）$x\%m==j$并且$f(x)\%m==k$并且各位数字和$\%m==l$的方案数<br/></p>
<p>不过这样空间和时间复杂度都太高了</p>
<p>不难发现可以将第二维和第三维合并，即$dp[i][j][k]$表示转移到第$i$位且$(x-f(x))\%m==0$且各位数字和$\%m==l$的方案数<br/></p>
<p>转移方程并不是难点。</p>
<p>对于数位DP，想降低错误率，尽量减少调试时间或者不调试，建议用<strong>记忆化搜索</strong>，递推虽然会快一些但是记忆化更容易写。</p>
<h4 id="记忆化搜索版本："><a href="#记忆化搜索版本：" class="headerlink" title="记忆化搜索版本："></a>记忆化搜索版本：</h4><p>基本写完调了一下就过了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">5050</span>,M=<span class="number">61</span>,mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> dp[N][M][M],q[N],a[N],len1,len2,m;</span><br><span class="line"><span class="keyword">char</span> s[N],g[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    q[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=len2;++i)</span><br><span class="line">        q[i]=(q[i<span class="number">-1</span>]*<span class="number">10</span>)%m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> s, <span class="keyword">int</span> p, <span class="keyword">int</span> lim)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!now)<span class="keyword">return</span> s==<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(!lim&amp;&amp;~dp[now][s][p])<span class="keyword">return</span> dp[now][s][p];</span><br><span class="line">    <span class="keyword">int</span> Max=lim?a[now]:<span class="number">9</span>;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= Max; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u=((s+q[now]*i-i*p)%m+m)%m,v=(p+i)%m;</span><br><span class="line">        ans=((ans+dfs(now<span class="number">-1</span>,u,v,lim&amp;i==Max))%mod+mod)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!lim)dp[now][s][p]=ans;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getans</span><span class="params">(<span class="keyword">char</span>* s,<span class="keyword">int</span> len,<span class="keyword">bool</span> gg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len;++i)</span><br><span class="line">        a[i]=s[len-i+<span class="number">1</span>]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (gg) &#123;</span><br><span class="line">        --a[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                a[i] += <span class="number">10</span>;</span><br><span class="line">                --a[i + <span class="number">1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!a[len])--len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dfs(len,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">&#125;<span class="keyword">int</span> T;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%s%d&quot;</span>,s+<span class="number">1</span>,g+<span class="number">1</span>,&amp;m);</span><br><span class="line">        len1=<span class="built_in">strlen</span>(s+<span class="number">1</span>),len2=<span class="built_in">strlen</span>(g+<span class="number">1</span>);</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len2;++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;++j)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;m;++k)</span><br><span class="line">                    dp[i][j][k]=<span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,(getans(g,len2,<span class="number">0</span>)-getans(s,len1,<span class="number">1</span>)+mod)%mod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="递推版本："><a href="#递推版本：" class="headerlink" title="递推版本："></a>递推版本：</h4><p>写完还调试了半天才过qwq</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">5010</span>,M=<span class="number">62</span>,mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> f[N][M][M],g[N][M][M];</span><br><span class="line"><span class="keyword">int</span> a[N],q[N],len;</span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="keyword">char</span> s[N],h[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    q[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">5000</span>;++i)</span><br><span class="line">        q[i]=(q[i<span class="number">-1</span>]*<span class="number">10</span>)%m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getans</span><span class="params">(<span class="keyword">char</span>*s,<span class="keyword">bool</span> gg)</span> </span>&#123;</span><br><span class="line">    len=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len;++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;++j)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;m;++k)</span><br><span class="line">                f[i][j][k]=g[i][j][k]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len;++i)</span><br><span class="line">        a[i]=s[len-i+<span class="number">1</span>]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (gg) &#123;</span><br><span class="line">        --a[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                a[i]+=<span class="number">10</span>;</span><br><span class="line">                --a[i+<span class="number">1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!a[len])--len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        ++f[<span class="number">1</span>][i%m][i%m];</span><br><span class="line">        <span class="keyword">if</span>(i&lt;=a[<span class="number">1</span>])++g[<span class="number">1</span>][i%m][i%m];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= len; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;++j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; m; ++k) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; <span class="number">10</span>; ++p) &#123;</span><br><span class="line">                    <span class="keyword">int</span> u=((j + q[i] * p - k * p)%m+m)%m,v=(k+p)%m;</span><br><span class="line">                    f[i][u][v]=(f[i][u][v]+f[i<span class="number">-1</span>][j][k])%mod;</span><br><span class="line">                    <span class="keyword">if</span>(p&lt;a[i])</span><br><span class="line">                        g[i][u][v]=(g[i][u][v]+f[i<span class="number">-1</span>][j][k])%mod;</span><br><span class="line">                    <span class="keyword">if</span>(p==a[i])</span><br><span class="line">                        g[i][u][v]=(g[i][u][v]+g[i<span class="number">-1</span>][j][k])%mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i)</span><br><span class="line">        ans=(ans+g[len][<span class="number">0</span>][i])%mod;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%s%d&quot;</span>,s+<span class="number">1</span>,h+<span class="number">1</span>,&amp;m);</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">int</span> u=getans(s,<span class="number">1</span>),v=getans(h,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,((v-u)%mod+mod)%mod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>ICPC</tag>
        <tag>数位DP</tag>
      </tags>
  </entry>
  <entry>
    <title>KMP学习</title>
    <url>/KMP/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>KMP算法的核心，是一个被称为 <strong>部分匹配表(Partial Match Table)</strong> 的数组。我觉得理解KMP的最大障碍就是很多人在看了很多关于KMP的文章之后，仍然搞不懂PMT中的值代表了什么意思。这里我们抛开所有的枝枝蔓蔓，先来解释一下这个数据到底是什么。<br><span id="more"></span><br>对于字符串“abababca”，它的PMT如下表所示:<br><img data-src="https://pic2.zhimg.com/v2-e905ece7e7d8be90afc62fe9595a9b0f_r.jpg?source=1940ef5c" alt=""><br>就像例子中所示的，如果待匹配的模式字符串有8个字符，那么PMT就会有8个值。</p>
<p>我先解释一下字符串的前缀和后缀。<em>如果字符串A和B，存在A=BS，其中S是任意的非空字符串，那就称B为A的前缀</em>。例如，”Harry”的前缀包括{”H”, ”Ha”, ”Har”, ”Harr”}，我们把所有前缀组成的集合，称为字符串的前缀集合。<em>同样可以定义后缀A=SB， 其中S是任意的非空字符串，那就称B为A的后缀</em>，例如，”Potter”的后缀包括{”otter”, ”tter”, ”ter”, ”er”, ”r”}，然后把所有后缀组成的集合，称为字符串的后缀集合。<strong>要注意的是，字符串本身并不是自己的后缀</strong>。</p>
<p>有了这个定义，就可以说明PMT中的值的意义了。<strong>PMT中的值是字符串的前缀集合与后缀集合的交集中最长元素的长度</strong>。例如，对于”aba”，它的前缀集合为{”a”, ”ab”}，后缀 集合为{”ba”, ”a”}。两个集合的交集为{”a”}，那么长度最长的元素就是字符串”a”了，长 度为1，所以对于”aba”而言，它在PMT表中对应的值就是1。再比如，对于字符串”ababa”，它的前缀集合为{”a”, ”ab”, ”aba”, ”abab”}，它的后缀集合为{”baba”, ”aba”, ”ba”, ”a”}， 两个集合的交集为{”a”, ”aba”}，其中最长的元素为”aba”，长度为3。</p>
<p>好了，解释清楚这个表是什么之后，我们再来看如何使用这个表来加速字符串的查找，以及这样用的道理是什么。如图 1.12 所示，要在主字符串”ababababca”中查找模式字符串”abababca”。如果在 j 处字符不匹配，那么由于前边所说的模式字符串 PMT 的性质，主字符串中 i 指针之前的 PMT[j−1] 位就一定与模式字符串的第 0 位至第 PMT[j−1] 位是相同的。这是因为主字符串在 i 位失配，也就意味着主字符串从 i−j 到 i 这一段是与模式字符串的 0 到 j 这一段是完全相同的。而我们上面也解释了，模式字符串从 0 到 j−1 ，在这个例子中就是”ababab”，其前缀集合与后缀集合的交集的最长元素为”abab”， 长度为4。所以就可以断言，主字符串中i指针之前的 4 位一定与模式字符串的第0位至第 4 位是相同的，即长度为 4 的后缀与前缀相同。这样一来，我们就可以将这些字符段的比较省略掉。具体的做法是，保持i指针不动，然后将j指针指向模式字符串的PMT[j−1]位即可。</p>
<p>简言之，以图中的例子来说，在 i 处失配，那么主字符串和模式字符串的前边6位就是相同的。又因为模式字符串的前6位，它的前4位前缀和后4位后缀是相同的，所以我们推知主字符串i之前的4位和模式字符串开头的4位是相同的。就是图中的灰色部分。那这部分就不用再比较了。</p>
<p><img data-src="https://pic4.zhimg.com/80/v2-03a0d005badd0b8e7116d8d07947681c_720w.jpg?source=1940ef5c" alt=""></p>
<p>有了上面的思路，我们就可以使用PMT加速字符串的查找了。我们看到如果是在 j 位 失配，那么影响 j 指针回溯的位置的其实是第 j −1 位的 PMT 值，所以为了编程的方便， 我们不直接使用PMT数组，而是将PMT数组向后偏移一位。我们把新得到的这个数组称为next数组。下面给出根据next数组进行字符串匹配加速的字符串匹配程序。其中要注意的一个技巧是，在把PMT进行向右偏移时，第0位的值，我们将其设成了-1，这只是为了编程的方便，并没有其他的意义。在本节的例子中，next数组如下表所示。</p>
<p><img data-src="https://pic1.zhimg.com/80/v2-40b4885aace7b31499da9b90b7c46ed3_720w.jpg?source=1940ef5c" alt=""></p>
<p>具体的程序如下所示:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KMP</span><span class="params">(<span class="keyword">char</span>*s,<span class="keyword">char</span>*p)</span></span>&#123;</span><br><span class="line">    <span class="comment">//s是主串,p是模式串</span></span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n=<span class="built_in">strlen</span>(s),m=<span class="built_in">strlen</span>(p);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(i&lt;n&amp;&amp;j&lt;m)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">-1</span>||s[i]==p[j])</span><br><span class="line">            ++i,++j;</span><br><span class="line">        <span class="keyword">else</span> j=nxt[j];<span class="comment">//因为next会出现命名冲突,所以用nxt</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(j==m)</span><br><span class="line">        <span class="keyword">return</span> i-j;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>好了，讲到这里，其实KMP算法的主体就已经讲解完了。你会发现，其实KMP算法的动机是很简单的，解决的方案也很简单。远没有很多教材和算法书里所讲的那么乱七八糟，只要搞明白了PMT的意义，其实整个算法都迎刃而解。</p>
<p>现在，我们再看一下如何编程快速求得next数组。其实，求next数组的过程完全可以看成字符串匹配的过程，即以模式字符串为主字符串，以模式字符串的前缀为目标字符串，一旦字符串匹配成功，那么当前的next值就是匹配成功的字符串的长度。</p>
<p>具体来说，就是从模式字符串的第一位(注意，不包括第0位)开始对自身进行匹配运算。 在任一位置，能匹配的最长长度就是当前位置的next值。如下图所示。</p>
<p><img data-src="https://pic1.zhimg.com/80/v2-645f3ec49836d3c680869403e74f7934_720w.jpg?source=1940ef5c" alt=""><br><img data-src="https://pic1.zhimg.com/80/v2-06477b79eadce2d7d22b4410b0d49aba_720w.jpg?source=1940ef5c" alt=""><br><img data-src="https://pic1.zhimg.com/80/v2-8a1a205df5cad7ab2f07498484a54a89_720w.jpg?source=1940ef5c" alt=""><br><img data-src="https://pic2.zhimg.com/80/v2-f2b50c15e7744a7b358154610204cc62_720w.jpg?source=1940ef5c" alt=""><br><img data-src="https://pic2.zhimg.com/80/v2-bd42e34a9266717b63706087a81092ac_720w.jpg?source=1940ef5c" alt=""></p>
<p>求next数组值的程序如下所示:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNxt</span><span class="params">(<span class="keyword">char</span>*s,<span class="keyword">int</span>*nxt)</span></span>&#123;</span><br><span class="line">    nxt[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">-1</span>,n=<span class="built_in">strlen</span>(s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(i&lt;n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">-1</span>||s[i]==s[j])</span><br><span class="line">            nxt[++i]=++j;</span><br><span class="line">        <span class="keyword">else</span> j=nxt[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，KMP算法就全部介绍完了。</p>
<blockquote>
<p>转载自 知乎 作者：海纳<br>原文链接：<span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzIxOTIzMDIxL2Fuc3dlci8yODEzNDY3NDY=">https://www.zhihu.com/question/21923021/answer/281346746<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
]]></content>
      <tags>
        <tag>字符串</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux安装php-fpm</title>
    <url>/Linux%E5%AE%89%E8%A3%85php-fpm/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>主要参考文章：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc1MjI5NC9hcnRpY2xlL2RldGFpbHMvOTAxODE4MDU=">Linux安装PHP-FPM<i class="fa fa-external-link-alt"></i></span></p>
<p>跟着做的时候踩坑了，在此记录下踩的坑，并排坑。</p>
<p>注：参考文章于2019年5月发布！</p>
<span id="more"></span>
<h2 id="安装编译环境"><a href="#安装编译环境" class="headerlink" title="安装编译环境"></a>安装编译环境</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum -y install epel-release</span><br><span class="line">yum -y install gcc automake autoconf libtool make gcc-c++ glibc libmcrypt-devel mhash-devel libxslt-devel libjpeg libjpeg-devel libpng libpng-devel freetype freetype-devel libxml2 libxml2-devel zlib zlib-devel glibc glibc-devel glib2 glib2-devel bzip2 bzip2-devel ncurses ncurses-devel curl curl-devel e2fsprogs e2fsprogs-devel krb5 krb5-devel libidn libidn-devel openssl openssl-devel libmcrypt mcrypt mhash  php-mcrypt</span><br></pre></td></tr></table></figure>
<h2 id="下载php版本包"><a href="#下载php版本包" class="headerlink" title="下载php版本包"></a>下载php版本包</h2><p>php官方地址：<span class="exturl" data-url="aHR0cHM6Ly93d3cucGhwLm5ldC9yZWxlYXNlcy8=">https://www.php.net/releases/<i class="fa fa-external-link-alt"></i></span><br>本次安装环境的版本包为php5.6，可以选择更高版本下载<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget http:&#x2F;&#x2F;cn2.php.net&#x2F;distributions&#x2F;php-5.6.24.tar.gz</span><br><span class="line">tar zvxf php-5.6.24.tar.gz</span><br><span class="line">cd php-5.6.24</span><br></pre></td></tr></table></figure></p>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>php编译过程中，如果要php支持相应的功能，需要先安装对应的组件，然后再编译。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;php  --enable-fpm --with-mcrypt --enable-mbstring --disable-pdo --with-curl --disable-debug  --disable-rpath --enable-inline-optimization --with-bz2  --with-zlib --enable-sockets --enable-sysvsem --enable-sysvshm --enable-pcntl --enable-mbregex --with-mhash --enable-zip --with-pcre-regex --with-mysql --with-mysqli </span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><br>此处可能会出现一些错误<br>例如：</p>
<h3 id="错误一"><a href="#错误一" class="headerlink" title="错误一"></a>错误一</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PHP configure: error: mcrypt.h not found. Please reinstall libmcrypt.</span><br></pre></td></tr></table></figure>
<h3 id="错误二"><a href="#错误二" class="headerlink" title="错误二"></a>错误二</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Don&#39;t know how to define struct flock on this system, set --enable-opcache&#x3D;no</span><br></pre></td></tr></table></figure>
<p>对于第一个，解决方法：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget ftp:&#x2F;&#x2F;mcrypt.hellug.gr&#x2F;pub&#x2F;crypto&#x2F;mcrypt&#x2F;attic&#x2F;libmcrypt&#x2F;libmcrypt-2.5.7.tar.gz</span><br><span class="line">tar -zxvf libmcrypt-2.5.7.tar.gz</span><br><span class="line">cd libmcrypt-2.5.7</span><br><span class="line">.&#x2F;configure  --prefix&#x3D;&#x2F;usr&#x2F;local</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><br>(可以选择更高版本的进行下载，但是我为了方便(lan)就没有改)</p>
<p>对于第二个，解决方法：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;ld.so.conf.d&#x2F;local.conf     # 编辑库文件</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;lib                       # 添加该行</span><br><span class="line">:wq                                  # 保存退出</span><br><span class="line">ldconfig -v                          # 使之生效</span><br></pre></td></tr></table></figure></p>
<p>有的人可能会出现 make 时出错，这个应该是因为你编译时出错导致的，因此上述问题解决后重新 make &amp;&amp; make install 即可</p>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>复制配置文件，对其中一些代码进行修改，可根据需要开启php中的功能<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp php.ini-development &#x2F;usr&#x2F;local&#x2F;php&#x2F;php.ini</span><br><span class="line">cp &#x2F;usr&#x2F;local&#x2F;php&#x2F;etc&#x2F;php-fpm.conf.default &#x2F;usr&#x2F;local&#x2F;php&#x2F;etc&#x2F;php-fpm.conf</span><br><span class="line">cp sapi&#x2F;fpm&#x2F;php-fpm &#x2F;usr&#x2F;local&#x2F;bin</span><br></pre></td></tr></table></figure><br>修改php-fpm.conf配置文件，使用www用户和www用户组运行（我为了方便用了我之前创建的其他用户组，注意此处不能用root）<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;usr&#x2F;local&#x2F;php&#x2F;etc&#x2F;php-fpm.conf</span><br><span class="line">#修改为以下</span><br><span class="line">; Unix user&#x2F;group of processes</span><br><span class="line">; Note: The user is mandatory. If the group is not set, the default user&#39;s group</span><br><span class="line">;       will be used.</span><br><span class="line">user &#x3D; www</span><br><span class="line">group &#x3D; www</span><br></pre></td></tr></table></figure></p>
<p>修改php.ini，根据需求开启需要的php功能<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;usr&#x2F;local&#x2F;php&#x2F;php.ini</span><br><span class="line">#############################</span><br><span class="line">display_errors &#x3D; On</span><br><span class="line">display_startup_errors &#x3D; On</span><br><span class="line">error_prepend_string &#x3D; &quot;&lt;br&gt;&lt;font color&#x3D;#ff0000&gt;&quot;</span><br><span class="line">error_append_string &#x3D; &quot;&lt;&#x2F;font&gt;&lt;br&gt;&lt;br&gt;&quot;</span><br><span class="line">fastcgi.impersonate &#x3D; 1</span><br><span class="line">date.timezone &#x3D; asia&#x2F;Shanghai</span><br><span class="line">extension&#x3D;php_mysql.dll</span><br><span class="line">extension&#x3D;php_gd2.dll</span><br><span class="line">extension&#x3D;php_mbstring.dll</span><br></pre></td></tr></table></figure></p>
<h2 id="官方提醒"><a href="#官方提醒" class="headerlink" title="官方提醒"></a>官方提醒</h2><p>需要着重提醒的是，如果文件不存在，则阻止 Nginx 将请求发送到后端的 PHP-FPM 模块， 以避免遭受恶意脚本注入的攻击。<br>将 php.ini 文件中的配置项 cgi.fix_pathinfo 设置为 0 。<br>打开 php.ini，定位到 cgi.fix_pathinfo= 并将其修改为如下所示：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;usr&#x2F;local&#x2F;php&#x2F;php.ini</span><br><span class="line">##########################</span><br><span class="line">cgi.fix_pathinfo&#x3D;0</span><br></pre></td></tr></table></figure></p>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;usr&#x2F;local&#x2F;bin&#x2F;php-fpm</span><br><span class="line">#查看是否运行</span><br><span class="line">netstat -anop | grep php</span><br></pre></td></tr></table></figure>
<p>出现以下界面表示正常运行：<br><img data-src="https://img-blog.csdnimg.cn/20190513161843862.png" alt=""></p>
<h2 id="Nginx添加PHP支持"><a href="#Nginx添加PHP支持" class="headerlink" title="Nginx添加PHP支持"></a>Nginx添加PHP支持</h2><p>Nginx的配置文件中已经给出了模板，将root修改为网站目录即可，参考如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location ~ .php$ &#123;</span><br><span class="line">root html；  #网站程序目录，根据需求修改</span><br><span class="line">fastcgi_pass 127.0.0.1:9000；</span><br><span class="line">fastcgi_index index.php；</span><br><span class="line">fastcgi_param SCRIPT_FILENAME &#x2F;html$fastcgi_script_name；  #&#x2F;html 为网站程序目录</span><br><span class="line">include fastcgi_params；</span><br><span class="line">fastcgi_param   SCRIPT_NAME        $fastcgi_script_name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Apache添加PHP支持"><a href="#Apache添加PHP支持" class="headerlink" title="Apache添加PHP支持"></a>Apache添加PHP支持</h2><p>若是要使用apache，编译时候需加上<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--with-apxs2&#x3D;&#x2F;usr&#x2F;local&#x2F;apache&#x2F;bin&#x2F;apxs</span><br><span class="line">#apxs路径自行确认，如果是yum安装，没有找到apxs需要安装下httpd-devel组件</span><br></pre></td></tr></table></figure></p>
<p>在httpd.conf添加以下配置：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LoadModule php5_module modules&#x2F;libphp5.so</span><br><span class="line">##########################################</span><br><span class="line">&lt;FilesMatch \.php$&gt;</span><br><span class="line">    SetHandler application&#x2F;x-httpd-php</span><br><span class="line">&lt;&#x2F;FilesMatch&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>访问80端口出现以下表示php配置完成。<br><img data-src="https://img-blog.csdnimg.cn/20190513182736115.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc1MjI5NA==,size_16,color_FFFFFF,t_70" alt=""></p>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title>最小斯坦纳树学习</title>
    <url>/Minimum%20Steiner%20tree/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>转载自:<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vc3FydHl6L3AvMTM0Mjc4NjguaHRtbA==">https://www.cnblogs.com/sqrtyz/p/13427868.html<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>摘自百度百科的定义：<br>斯坦纳树问题是组合优化问题，与 最小生成树相似 ，是最短网络的一种。最小生成树是在给定的点集和边中寻求最短网络使所有点连通。而最小斯坦纳树允许在给定点外增加额外的点，使生成的最短网络开销最小。</p>
</blockquote>
<span id="more"></span>
<p>可以这么理解：一个图的生成树是构造一棵树把所有点给联通，而斯坦纳树则是构造一棵树把给定的几个点联通。如同生成树有最小的一棵，斯坦纳树也有最小的。如何求最小斯坦纳树，是我们今天要探讨的话题。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ul>
<li>例题：<span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDYxOTI=">Luogu P6192【模板】最小斯坦纳树<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<blockquote>
<p><div>给定一个包含 $n$ 个结点和 $m$ 条带权边的无向连通图 $G=(V,E)$。<br/><br>再给定包含 $k$ 个结点的点集 $S$，选出 $G$ 的子图 $G&#039;=(V&#039;,E&#039;)$，使得：<br/></p>
<ol>
<li>$S\subseteq V&#039;$；<br/></li>
<li>$G&#039;$ 为连通图；<br/></li>
<li>$E&#039;$ 中所有边的权值和最小。<br/><br>你只需要求出 $E&#039;$ 中所有边的权值和。&lt;/div&gt; <br/></li>
</ol>
</blockquote>
<p>求最小斯坦纳树，我们使用的是 <strong>状压DP</strong>。</p>
<p>首先非常显然的是，这个选出来的子图 <span class="math inline">\(G'\)</span> 一定是个树。</p>
<p>令 <span class="math inline">\(f_{i,S}\)</span> 表示当前这个树的根为 <span class="math inline">\(i\)</span>，选出的点的集合为 <span class="math inline">\(S\)</span>（注意这里选出的点专指那 <span class="math inline">\(k\)</span> 个点中的点），这里的 <span class="math inline">\(S\)</span> 在 dp 中是被状压的。</p>

<ul>
<li>第一种转移方式：</li>
</ul>

<p></p><div class="math display">\[f_{i,S} = f_{i,T} + f_{i,S-T} \ \ \ (T \subseteq S)
\]</div><p></p><p>这种转移方式意义在于把一个根可能会连出多棵 <span class="math inline">\(S\)</span> 互不相交的树，该方程可以合并它们。此时这个根的度数 <span class="math inline">\(\geq 1\)</span>。以下是一个示意图，其中 <span class="math inline">\(5,6,7\)</span> 三个点属于目标的那 <span class="math inline">\(k\)</span> 个点，<span class="math inline">\(3\)</span> 是目前的 <span class="math inline">\(i\)</span>。</p>
<p><img data-src="https://cdn.luogu.com.cn/upload/image_hosting/mqaufgz2.png" alt="" loading="lazy"></p>

<ul>
<li>第二种转移方式：</li>
</ul>

<p><p></p><div class="math display">\[f_{i,S} = f_{j,S} + w(i,j)
\]</div><p></p><p>这种转移方式意义在于把一个根的状态转移到与他相邻的一个根上。此时根 <span class="math inline">\(i\)</span> 的度数 <span class="math inline">\(=1\)</span>。示意图如下，其中 <span class="math inline">\(i = 1，j=3\)</span>，<span class="math inline">\(S=\{5,6\}\)</span>，橙色虚线代表待扩展的边 <span class="math inline">\((i,j)\)</span>。</p></p>
<p><p><img data-src="https://cdn.luogu.com.cn/upload/image_hosting/kpoebt6x.png" alt="" loading="lazy"></p></p>
<p><p>考虑 dp 顺序，显然 <span class="math inline">\(S\)</span> 从小到大枚举即可。</p></p>
<p><p>对于第一种转移方式，只需枚举 <span class="math inline">\(S\)</span> 的子集 <span class="math inline">\(T\)</span>。对于第二种转移方式，注意到这玩意儿是个 <strong>三角不等式</strong>，联想到最短路也是如此——没错，用最短路跑一遍就行了。</p></p>
<h3 id="参考代码">参考代码</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n, m, k, f[Maxn][<span class="number">1</span> &lt;&lt; Maxk];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> next, to, dis;</span><br><span class="line">&#125;</span><br><span class="line">edge[Maxm * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> head[Maxn], edge_num;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> dis)</span> </span>&#123;</span><br><span class="line">    edge[++edge_num].next = head[from];</span><br><span class="line">    edge[edge_num].to = to;</span><br><span class="line">    edge[edge_num].dis = dis;</span><br><span class="line">    head[from] = edge_num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; Q; <span class="keyword">int</span> dist[Maxn]; <span class="keyword">bool</span> inq[Maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(inq, <span class="number">0</span>, <span class="keyword">sizeof</span>(inq));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        dist[i] = f[i][S];</span><br><span class="line">        <span class="keyword">if</span>(dist[i] != <span class="number">1061109567</span>) Q.push(i), inq[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(Q.size()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = Q.front();</span><br><span class="line">        Q.pop();</span><br><span class="line">        inq[u] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; i; i = edge[i].next) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(dist[v] &gt; dist[u] + edge[i].dis) &#123;</span><br><span class="line">                dist[v] = dist[u] + edge[i].dis;</span><br><span class="line">                <span class="keyword">if</span>(!inq[v]) &#123;</span><br><span class="line">                    inq[v] = <span class="number">1</span>;</span><br><span class="line">                    Q.push(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) f[i][S] = dist[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = read(); m = read(); k = read();</span><br><span class="line">    <span class="keyword">int</span> u, v, w;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        u = read(); v = read(); w = read();</span><br><span class="line">        add_edge(u, v, w);</span><br><span class="line">        add_edge(v, u, w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">63</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">        u = read();</span><br><span class="line">        f[u][<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>)] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) f[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> S = <span class="number">0</span>; S &lt; (<span class="number">1</span> &lt;&lt; k); ++S) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> T = S &amp; (S - <span class="number">1</span>); T; T = S &amp; (T - <span class="number">1</span>))</span><br><span class="line">                f[i][S] = min(f[i][S], f[i][T] + f[i][T ^ S]);</span><br><span class="line">        SPFA(S);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">2e9</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) ans = min(ans, f[i][(<span class="number">1</span> &lt;&lt; k) - <span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="例题">例题</h3>

<ul>
<li>[WC2008] 游览计划</li>
</ul>

<p><p>考虑把每个方格当成一个点，最小斯坦纳树搞它就完了。</p></p>
<p><p>需要注意的是，由于这道题从边权变成了点权，因此需要把第一种转移方式改成</p></p>
<p><p></p><div class="math display">\[f_{i,S} = f_{i,T} + f_{i,S-T} - w_i\ \ \ (T \subseteq S)
\]</div><p></p><p>原因显然，因为合并状态时 <span class="math inline">\(i\)</span> 的点权被算了两次，需要减去一次。</p></p>
<p><p>另外，这道题需要输出方案。一个解决方法是记录前驱、回溯解决。怎么 dp 过来，就怎么找回去，如果某个状态和上个状态满足 dp 方程，说明这个状态是从上个状态转移过来的，从而可以计算出哪些点是选了的。具体请参见代码的 dfs 部分。</p></p>
<p><p>代码：</p><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> w, h, n, cnt, root, val[Maxn], dp[Maxn][<span class="number">1</span> &lt;&lt; Maxk], pre[Maxn][<span class="number">1</span> &lt;&lt; Maxk];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> next, to;</span><br><span class="line">&#125;</span><br><span class="line">edge[Maxm];</span><br><span class="line"><span class="keyword">int</span> head[Maxn], edge_num;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">    edge[++edge_num].next = head[from];</span><br><span class="line">    edge[edge_num].to = to;</span><br><span class="line">    head[from] = edge_num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h * (i - <span class="number">1</span>) + j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; Q; <span class="keyword">bool</span> inq[Maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">if</span>(dp[i][S] != <span class="number">1061109567</span>) Q.push(i), inq[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(Q.size()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = Q.front();</span><br><span class="line">        Q.pop();</span><br><span class="line">        inq[u] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(rg <span class="keyword">int</span> i = head[u]; i; i = edge[i].next) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(dp[v][S] &gt; dp[u][S] + val[v]) &#123;</span><br><span class="line">                dp[v][S] = dp[u][S] + val[v];</span><br><span class="line">                pre[v][S] = u;</span><br><span class="line">                <span class="keyword">if</span>(!inq[v]) inq[v] = <span class="number">1</span>, Q.push(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> ans[Maxn], vis[Maxn][<span class="number">1</span> &lt;&lt; Maxk];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!S || vis[u][S]) <span class="keyword">return</span>;</span><br><span class="line">    vis[u][S] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(pre[u][S] &amp;&amp; dp[pre[u][S]][S] + val[u] == dp[u][S]) dfs(pre[u][S], S), ans[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(rg <span class="keyword">int</span> T = S &amp; (S - <span class="number">1</span>); T; T = S &amp; (T - <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">if</span>(dp[u][T] + dp[u][S ^ T] - val[u] == dp[u][S]) dfs(u, T), dfs(u, S ^ T);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    w = read(); h = read(); n = w * h;</span><br><span class="line">    <span class="keyword">for</span>(rg <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= w; ++i)</span><br><span class="line">        <span class="keyword">for</span>(rg <span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= h; ++j) &#123;</span><br><span class="line">            val[f(i, j)] = read();</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">1</span>) add_edge(f(i, j), f(i - <span class="number">1</span>, j));</span><br><span class="line">            <span class="keyword">if</span>(j &gt; <span class="number">1</span>) add_edge(f(i, j), f(i, j - <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">if</span>(i &lt; w) add_edge(f(i, j), f(i + <span class="number">1</span>, j));</span><br><span class="line">            <span class="keyword">if</span>(j &lt; h) add_edge(f(i, j), f(i, j + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">63</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span>(rg <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!val[i]) dp[i][<span class="number">1</span> &lt;&lt; (cnt++)] = <span class="number">0</span>, root = i;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(rg <span class="keyword">int</span> S = <span class="number">0</span>; S &lt; (<span class="number">1</span> &lt;&lt; cnt); ++S) &#123;</span><br><span class="line">        <span class="keyword">for</span>(rg <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">for</span>(rg <span class="keyword">int</span> T = S &amp; (S - <span class="number">1</span>); T; T = S &amp; (T - <span class="number">1</span>))</span><br><span class="line">                dp[i][S] = min(dp[i][S], dp[i][T] + dp[i][S ^ T] - val[i]);</span><br><span class="line">        SPFA(S);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root, (<span class="number">1</span> &lt;&lt; cnt) - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[root][(<span class="number">1</span> &lt;&lt; cnt) - <span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(rg <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= w; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(rg <span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= h; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> pos = f(i, j);</span><br><span class="line">            <span class="keyword">if</span>(!val[pos]) <span class="built_in">printf</span>(<span class="string">&quot;x&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ans[pos]) <span class="built_in">printf</span>(<span class="string">&quot;o&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;_&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>最小斯坦纳树</tag>
      </tags>
  </entry>
  <entry>
    <title>Problem Buyer</title>
    <url>/Problem-Buyer/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>给定 $n$个题目，每个题目有一个难度范围$[a_i,b_i]$。你需要举办一场$m$个题目的比赛，其中第$i$题难度应该是$c_i$，若你选择的题目难度范围是$[A,B]且A\leq c_i \leq B$，则可以作为第$i$题。现在你需要买给定的$n$题中的$k$题，但是买到的题目是随机的，求出能保证可以举办比赛的最小的$k$。</p>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>看着很像是点覆盖之类的，不过又是要求任意$k$题可以构成比赛，因此考虑贪心。  </p>
<p>如果每道题的难度区间只会覆盖至多一个考题，设第$i$题被$d_i$个区间覆盖。最坏情况是第$i$题外的每一道题对应区间都被选了，然后我们第$i$题随意来一题即可，枚举所有的$i$并取max，所以答案$ans=max\{n-d_i+1\}$。</p>
<p>考虑一个区间可能覆盖多个点，那么我们将$c$从小到大排序，从左往右选择考题时，每次选出一题将符合这题的区间右端点最左的一道题去掉即可。可以证明，这样对于后面选择影响是最小的，会使得后面的$d_i$尽可能小，使得答案尽可能大。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt;&gt;q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> node&amp; other)<span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> l&lt;other.l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;a[N];</span><br><span class="line"><span class="keyword">int</span> c[N];</span><br><span class="line"><span class="keyword">int</span> T,n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> ii = <span class="number">1</span>; ii &lt;= T; ++ii) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a[i].l,&amp;a[i].r);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;c[i]);</span><br><span class="line">        sort(c+<span class="number">1</span>,c+<span class="number">1</span>+m);</span><br><span class="line">        sort(a+<span class="number">1</span>,a+<span class="number">1</span>+n);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())q.pop();</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>,j=<span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span>(j&lt;=n&amp;&amp;a[j].l&lt;=c[i])</span><br><span class="line">                q.push(a[j++].r);</span><br><span class="line">            <span class="keyword">while</span>(!q.empty()&amp;&amp;q.top()&lt;c[i])q.pop();</span><br><span class="line">            ans=max(ans,n-(<span class="keyword">int</span>)q.size()+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(!q.empty())</span><br><span class="line">                q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: &quot;</span>,ii);</span><br><span class="line">        <span class="keyword">if</span>(ans&lt;=n)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;IMPOSSIBLE!\n&quot;</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt 内存文件映射</title>
    <url>/Qt-%E5%86%85%E5%AD%98%E6%96%87%E4%BB%B6%E6%98%A0%E5%B0%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>其实很简单</p>
<p>Qt都封装好了</p>
<p>映射一个文件：</p>
<span id="more"></span>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QFile file;</span><br><span class="line">file.setFileName(path);<span class="comment">//设置文件路径</span></span><br><span class="line">file.open(QIODevice::ReadOnly);<span class="comment">//只读，读写为ReadWrite</span></span><br><span class="line"><span class="keyword">int</span> len=file.size();</span><br><span class="line">uchar*ptr=file.<span class="built_in">map</span>(<span class="number">0</span>,len);<span class="comment">//ptr即为文件字符串</span></span><br><span class="line"><span class="keyword">if</span>(!ptr)&#123;</span><br><span class="line">    len=<span class="number">0</span>;</span><br><span class="line">    file.close();</span><br><span class="line">    ptr=<span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">uchar*tail=ptr+len;<span class="comment">//尾指针</span></span><br></pre></td></tr></table></figure>
<p>读取文件（和从字符串中读取没任何区别）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">QString <span class="title">QuickFile::QStringLine</span><span class="params">()</span></span>&#123;<span class="comment">//读取一行</span></span><br><span class="line">    QString s=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span>(ptr&lt;tail&amp;&amp;*ptr!=<span class="string">&#x27;\r&#x27;</span>&amp;&amp;*ptr!=<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        s.push_back(*ptr++);</span><br><span class="line">    <span class="keyword">if</span>(*ptr==<span class="string">&#x27;\r&#x27;</span>)++ptr;</span><br><span class="line">    <span class="keyword">if</span>(*ptr==<span class="string">&#x27;\n&#x27;</span>)++ptr;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其余读取操作请自行完善</p>
<p>下面附上我封装好的读取文件类</p>
<h4 id="quickfile-h"><a href="#quickfile-h" class="headerlink" title="quickfile.h"></a>quickfile.h</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MYFILE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYFILE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QFile&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QuickFile</span>&#123;</span><span class="comment">//读入的文件</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    QFile file;</span><br><span class="line">    uchar*ptr,*tail;</span><br><span class="line">    QuickFile();</span><br><span class="line">    ~QuickFile();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">QuickFileRead</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;path,<span class="keyword">const</span> <span class="keyword">int</span> &amp;MinSize=<span class="number">0</span>,<span class="keyword">const</span> <span class="keyword">int</span>&amp;MaxSize=<span class="number">-1</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">QString <span class="title">QStringAll</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">QString <span class="title">QStringLine</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">IntAll</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">IntLine</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// MYFILE_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="quickfile-cpp"><a href="#quickfile-cpp" class="headerlink" title="quickfile.cpp"></a>quickfile.cpp</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;quickfile.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;function.h&quot;</span></span></span><br><span class="line">QuickFile::QuickFile()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">QuickFile::~QuickFile()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickFile::QuickFileRead</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;path,<span class="keyword">const</span> <span class="keyword">int</span> &amp;MinSize,<span class="keyword">const</span> <span class="keyword">int</span>&amp;MaxSize)</span></span>&#123;</span><br><span class="line">    file.setFileName(QString::fromLocal8Bit(path.data()));</span><br><span class="line">    file.open(QIODevice::ReadOnly);</span><br><span class="line">    len=file.size();</span><br><span class="line">    <span class="keyword">if</span>(~MaxSize&amp;&amp;(len&lt;MinSize||len&gt;MaxSize))&#123;</span><br><span class="line">        len=<span class="number">0</span>;</span><br><span class="line">        file.close();</span><br><span class="line">        ptr=<span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ptr=file.<span class="built_in">map</span>(<span class="number">0</span>,len);</span><br><span class="line">    <span class="keyword">if</span>(!ptr)&#123;</span><br><span class="line">        len=<span class="number">0</span>;</span><br><span class="line">        file.close();</span><br><span class="line">        ptr=<span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    tail=ptr+len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickFile::close</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(len)file.unmap(ptr);</span><br><span class="line">    file.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">QString <span class="title">QuickFile::QStringAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">    QString s=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span>(ptr&lt;tail)</span><br><span class="line">        s.push_back(*ptr++);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">QString <span class="title">QuickFile::QStringLine</span><span class="params">()</span></span>&#123;</span><br><span class="line">    QString s=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span>(ptr&lt;tail&amp;&amp;*ptr!=<span class="string">&#x27;\r&#x27;</span>&amp;&amp;*ptr!=<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        s.push_back(*ptr++);</span><br><span class="line">    <span class="keyword">if</span>(*ptr==<span class="string">&#x27;\r&#x27;</span>)++ptr;</span><br><span class="line">    <span class="keyword">if</span>(*ptr==<span class="string">&#x27;\n&#x27;</span>)++ptr;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QuickFile::IntAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(ptr&lt;tail)</span><br><span class="line">        s=(s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+(*(ptr++)-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QuickFile::IntLine</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(ptr&lt;tail&amp;&amp;*ptr!=<span class="string">&#x27;\r&#x27;</span>&amp;&amp;*ptr!=<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        s=(s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+(*(ptr++)-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(*ptr==<span class="string">&#x27;\r&#x27;</span>)++ptr;</span><br><span class="line">    <span class="keyword">if</span>(*ptr==<span class="string">&#x27;\n&#x27;</span>)++ptr;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="使用方法："><a href="#使用方法：" class="headerlink" title="使用方法："></a>使用方法：</h3><p>QuickFileRead:</p>
<p>读取路径为path，文件大小在[MinSize,MaxSize]（不在的话len=0,ptr=nullptr，即文件置为空）之间的文件，MaxSize=-1即无限制。</p>
<p>ptr指针即为文件内容指针,uchar类型。</p>
<p>读取完后需要用close()进行关闭</p>
<p>close:</p>
<p>关闭读取的文件以及映射</p>
<p>QStringAll:</p>
<p>返回文件剩余内容，类型为QString</p>
<p>ptr移至尾指针tail</p>
<p>QStringLine:</p>
<p>返回一行，类型为QString</p>
<p>ptr移至下一行</p>
<p>IntAll:</p>
<p>返回文件剩余内容，类型为int</p>
<p>ptr移至尾指针tail</p>
<p>IntLine:</p>
<p>返回一行，类型为int</p>
<p>ptr移至下一行</p>
<p>为啥要用文件内容映射？</p>
<p>使用这个可以减少I/O操作，并且对于性能提升有好处</p>
<p>同时降低了程序内存使用（节省了接收文件内容所需要的字符数组）</p>
<p>对于快速写入，我暂时用不上，因此没写</p>
]]></content>
      <tags>
        <tag>Qt</tag>
        <tag>内存文件映射</tag>
      </tags>
  </entry>
  <entry>
    <title>QtCreator开启-O编译优化的方式</title>
    <url>/QtCreator%E5%BC%80%E5%90%AF-O%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E7%9A%84%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>首先，编译优化必须是在Release模式下进行，保证程序没有任何bug的条件下进行执行。</p>
<p>如果程序开了编译优化，部分错误不会报错且debug会出问题，因此需要在没有bug后再进行优化</p>
<p>编译优化能极大提升程序的运行效率，级别越高速度越快，但是对代码健壮性要求也越高！</p>
<span id="more"></span>
<p>选择编译release模式，在pro文件根据优化的需要添加下面的语句：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QMAKE_CXXFLAGS_RELEASE += -O        # Release -O</span><br><span class="line">QMAKE_CXXFLAGS_RELEASE += -O1       # Release -O1</span><br><span class="line">QMAKE_CXXFLAGS_RELEASE += -O2       # Release -O2</span><br><span class="line">QMAKE_CXXFLAGS_RELEASE += -O3       # Release -O3</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title>YY的GCD</title>
    <url>/YY%E7%9A%84GCD/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>入门级别的题（不过貌似我一开始想复杂了<br><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDIyNTc=">题目链接<i class="fa fa-external-link-alt"></i></span><br><span id="more"></span></p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定 $N, M$，求 $1 \leq x \leq N$，$1 \leq y \leq M$ 且 $\gcd(x, y)$ 为质数的 $(x, y)$ 有多少对。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>直接上柿子</p>
<script type="math/tex; mode=display">
Ans=\sum_{k\in prime}\sum_{i=1}^{N}\sum_{j=1}^{M}[gcd(i,j)==k]</script><p>如果莫比乌斯反演做了个几道题，就会知道要化简后面那个式子<br>我们令$f(k)=\sum_{i=1}^{N}\sum_{j=1}^{M}[gcd(i,j)==k],F(k)=\sum_{i=1}^{N}\sum_{j=1}^{M}[k|gcd(i,j)]$<br/><br>然后可以得到</p>
<script type="math/tex; mode=display">
\begin{aligned}
&F(k)=\sum_{k|d}f(d)=\lfloor\frac{N}{k}\rfloor\lfloor\frac{M}{k}\rfloor \\
\therefore &f(k)=\sum_{k|d}\mu(\frac{d}{k})F(d)=\sum_{k|d}\mu(\frac{d}{k})\lfloor\frac{N}{d}\rfloor\lfloor\frac{M}{d}\rfloor
\end{aligned}</script><p>代入到 Ans 中，可以得到</p>
<script type="math/tex; mode=display">
Ans=\sum_{k\in prime}\sum_{k|d}\mu(\frac{d}{k})\lfloor\frac{N}{d}\rfloor\lfloor\frac{M}{d}\rfloor</script><p>这题因为是多组询问，如果我们将$\lfloor\frac{N}{d}\rfloor\lfloor\frac{M}{d}\rfloor$放在内层的话不好进行整数分块，因此要想办法将其放到外层<br/><br>因此我们外层枚举 d ：</p>
<script type="math/tex; mode=display">
Ans=\sum_{d=1}^{min(n,m)}\lfloor\frac{N}{d}\rfloor\lfloor\frac{M}{d}\rfloor(\sum_{k|d,k\in prime}\mu(\frac{d}{k}))</script><p>内层的这个与 N 和 M 无关，因此是可以预处理出其前缀和的，之后就可以进行整除分块了。</p>
<p>代码如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e7</span>+<span class="number">10</span>,M=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> mu[N],prime[M];</span><br><span class="line"><span class="keyword">bool</span> f[N];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    f[<span class="number">1</span>]=<span class="literal">true</span>,mu[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> maxn=<span class="number">1e7</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=maxn;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!f[i])&#123;</span><br><span class="line">            prime[++prime[<span class="number">0</span>]]=i;</span><br><span class="line">            mu[i]=<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=prime[<span class="number">0</span>]&amp;&amp;i*prime[j]&lt;=maxn;++j)&#123;</span><br><span class="line">            f[i*prime[j]]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">            mu[i*prime[j]]=-mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=prime[<span class="number">0</span>];++j)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i*prime[j]&lt;=maxn;++i)</span><br><span class="line">            sum[i*prime[j]]+=mu[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=maxn;++i)</span><br><span class="line">        sum[i]+=sum[i<span class="number">-1</span>];</span><br><span class="line">&#125;<span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">F</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxn=min(n,m);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>,r=<span class="number">1</span>;l&lt;=maxn;l=r+<span class="number">1</span>)&#123;</span><br><span class="line">        r=min(n/(n/l),m/(m/l));</span><br><span class="line">        ans+=(sum[r]-sum[l<span class="number">-1</span>])*(n/l)*(m/l);</span><br><span class="line">    &#125;<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T,n,m;</span><br><span class="line">    init();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,F(n,m));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title>SCOI2005最大子矩阵</title>
    <url>/SCOI2005%E6%9C%80%E5%A4%A7%E5%AD%90%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote>
<p>这里有一个n*m的矩阵，请你选出其中k个子矩阵，使得这个k个子矩阵分值之和最大。<br>注意：选出的k个子矩阵 不能相互重叠。</p>
</blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL3Byb2JsZW0vMjAyNDI=">题目链接<i class="fa fa-external-link-alt"></i></span><br><span id="more"></span></p>
<p>题解：<br>题目范围很重要，$m\leq 2$，当m为1时即简单的数组中取k段连续和的最大值，令dp[i][j]表示前i个取j个子矩阵的最大值即可。<br>当m=2时，即将上述的二维dp改为三维dp即可，令dp[i][j][k]表示第一列前i个，第二列前j个中取k个子矩阵的最大值。<br>dp[i][j][k]初始为max(dp[i-1][j][k],dp[i][j-1][k])，表示不取的转移。<br>1.如果是当前取一个一列的矩阵，则分别在两列进行转移：</p>
<script type="math/tex; mode=display">
\begin{aligned}
dp[i][j][k]=max\{dp[p][j][k-1]+s1[i]-s1[p]\}\\
dp[i][j][k]=max\{dp[i][p][k-1]+s2[i]-s2[p]\}
\end{aligned}</script><p>2.如果是取一个两列的矩阵，则只能在i=j时进行转移：</p>
<script type="math/tex; mode=display">
\begin{aligned}
dp[i][i][k]=max\{dp[p][p][k-1]+s1[i]+s2[i]-s1[p]-s2[p]\}
\end{aligned}</script><p>其中s1表示第一列前缀和，s2表示第二列前缀和。</p>
<p>不过后来我发现这样做还是有些问题的，如果m=1并且第一列全为负数，这样第二列当做0算，这样取的k个子矩阵可能有第二列的，但这是非法的，因此需要考虑将m=1和m=2分开来做或者是第二列前缀和进行修改。<br>因为数据范围并不大，因此对第二列前缀和修改即可，而且此题貌似数据也很弱，不考虑也能过。</p>
<details>
    <summary>参考代码</summary>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">105</span>][<span class="number">105</span>][<span class="number">12</span>],s[<span class="number">105</span>][<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,k;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">105</span>][<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0xf3</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;++j)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i][j]);</span><br><span class="line">            s[i][j]=s[i<span class="number">-1</span>][j]+a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=n;++j)</span><br><span class="line">            dp[i][j][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(m==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">            s[i][<span class="number">2</span>]=-i*<span class="number">1e7</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">1</span>;p&lt;=k;++p)<span class="comment">//取p个子矩阵</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)<span class="comment">//第一列</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;++j)&#123;<span class="comment">//第二列</span></span><br><span class="line">                dp[i][j][p]=max(dp[i<span class="number">-1</span>][j][p],dp[i][j<span class="number">-1</span>][p]);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">0</span>;l&lt;i;++l)</span><br><span class="line">                    dp[i][j][p]=max(dp[i][j][p],dp[l][j][p<span class="number">-1</span>]+s[i][<span class="number">1</span>]-s[l][<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">0</span>;l&lt;j;++l)</span><br><span class="line">                    dp[i][j][p]=max(dp[i][j][p],dp[i][l][p<span class="number">-1</span>]+s[j][<span class="number">2</span>]-s[l][<span class="number">2</span>]);</span><br><span class="line">                <span class="keyword">if</span>(i==j)</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">0</span>;l&lt;i;++l)</span><br><span class="line">                        dp[i][j][p]=max(dp[i][j][p],dp[l][l][p<span class="number">-1</span>]+s[i][<span class="number">1</span>]+s[i][<span class="number">2</span>]-s[l][<span class="number">1</span>]-s[l][<span class="number">2</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,dp[n][n][k]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
]]></content>
      <tags>
        <tag>DP</tag>
        <tag>牛客每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>WC2008游览计划</title>
    <url>/WC2008%E6%B8%B8%E8%A7%88%E8%AE%A1%E5%88%92/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这题我居然觉得难点是回溯…</p>
<span id="more"></span>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这题其实和最小斯坦纳树模板很像，只是将边权改为了点权，而斯坦纳树通过 dp 方式转移的时候根节点 i 的点权会被算两次，因此减去一次即可。<br>然后就是套最小斯坦纳树板子了，不过这个回溯着实坑死我了…<br>其实就是记下每个 dp 状态是由什么转移过来的即可，最后从终止状态慢慢往回推，只要是回溯到的点都打上标记，代表这个位置安排了志愿者。</p>
<p>代码如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">11</span>, M = <span class="number">1</span> &lt;&lt; <span class="number">10</span>, inf = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, c;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, s;</span><br><span class="line">    node(<span class="keyword">int</span> a = <span class="number">0</span>, <span class="keyword">int</span> b = <span class="number">0</span>) &#123;</span><br><span class="line">        x = a;</span><br><span class="line">        s = b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;pre[N * N][M];</span><br><span class="line"><span class="keyword">int</span> d[N * N], nxt[N * N * <span class="number">4</span>], to[N * N * <span class="number">4</span>], w[N * N], id[N * N], tot;</span><br><span class="line"><span class="keyword">int</span> maxn, cnt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    to[++tot] = b;</span><br><span class="line">    nxt[tot] = d[a];</span><br><span class="line">    d[a] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dp[N * N][M], dis[N * N];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line"><span class="keyword">bool</span> in[N * N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= c; ++i) &#123;</span><br><span class="line">        dis[i] = dp[i][s];</span><br><span class="line">        <span class="keyword">if</span> (dis[i] &lt; inf)in[i] = <span class="number">1</span>, q.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        in[x] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = d[x]; i; i = nxt[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = to[i];</span><br><span class="line">            <span class="keyword">if</span> (dis[u] &gt; dis[x] + w[u]) &#123;</span><br><span class="line">                dis[u] = dis[x] + w[u];</span><br><span class="line">                pre[u][s] = node(x, s);</span><br><span class="line">                <span class="keyword">if</span> (!in[u])in[u] = <span class="number">1</span>, q.push(u);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= c; ++i)dp[i][s] = dis[i];</span><br><span class="line">&#125;<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    maxn = <span class="number">1</span> &lt;&lt; cnt;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= c; ++i)</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> S = <span class="number">1</span>; S &lt; maxn; ++S) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= c; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> T = (S - <span class="number">1</span>) &amp; S; T; T = (T - <span class="number">1</span>) &amp; S) &#123;</span><br><span class="line">                <span class="keyword">int</span> v = dp[i][T] + dp[i][S ^ T] - w[i];</span><br><span class="line">                <span class="keyword">if</span> (v &lt; dp[i][S]) &#123;</span><br><span class="line">                    dp[i][S] = v;</span><br><span class="line">                    pre[i][S] = node(i, T);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        spfa(S);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">int</span> py[<span class="number">4</span>][<span class="number">2</span>] = &#123; &#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125; &#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123; <span class="keyword">return</span> (i - <span class="number">1</span>) * m + j; &#125;</span><br><span class="line"><span class="keyword">bool</span> ans[N * N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x)<span class="keyword">return</span>;</span><br><span class="line">    ans[x] = <span class="literal">true</span>;</span><br><span class="line">    node p = pre[x][s];</span><br><span class="line">    dfs(p.x, p.s);</span><br><span class="line">    <span class="keyword">if</span> (p.x == x)dfs(p.x, p.s ^ s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">int</span> p;</span><br><span class="line">    <span class="keyword">int</span> root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = ++c;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;p);</span><br><span class="line">            w[x] = p;</span><br><span class="line">            <span class="keyword">if</span> (!p) &#123;</span><br><span class="line">                id[x] = cnt++;</span><br><span class="line">                dp[x][<span class="number">1</span> &lt;&lt; id[x]] = <span class="number">0</span>;</span><br><span class="line">                root = x;</span><br><span class="line">                pre[x][<span class="number">1</span> &lt;&lt; id[x]] = node(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                id[x] = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = i + py[k][<span class="number">0</span>], y = j + py[k][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (x&lt;<span class="number">1</span> || y&lt;<span class="number">1</span> || x&gt;n || y&gt;m)<span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> a = get(i, j), b = get(x, y);</span><br><span class="line">                ins(a, b);</span><br><span class="line">            &#125;</span><br><span class="line">    work();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dp[root][maxn - <span class="number">1</span>]);</span><br><span class="line">    dfs(root, maxn - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = get(i, j);</span><br><span class="line">            <span class="keyword">if</span> (id[x] == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ans[x])<span class="built_in">printf</span>(<span class="string">&quot;o&quot;</span>);</span><br><span class="line">                <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;_&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;x&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>最小斯坦纳树</tag>
      </tags>
  </entry>
  <entry>
    <title>Steps to One</title>
    <url>/Steps-to-One/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这一题质量是真的不错，做了很久才做出来（初学莫比乌斯反演，别骂了<br><span id="more"></span></p>
<p>题目描述：<br>每次随机选出 $1\sim m$中的一个数，当已有的数的 gcd 为 1 时停止，问停止时的期望次数。<br/><br><span class="exturl" data-url="aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL3Byb2JsZW0vMTEzNTUy">题目链接<i class="fa fa-external-link-alt"></i></span></p>
<p>题解：</p>
<ul>
<li>看到的一个<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLm5vd2NvZGVyLm5ldC9uLzQ2YTU2YjYwMTlkMzRlYjM5OWE4MmM1NmJjZWQyZjJj">神仙题解<i class="fa fa-external-link-alt"></i></span>，复杂度是O(m)。</li>
<li>我的题解<br>假设$F_i$是 gcd 为 i 时变成 1 的期望次数，则不难得出$F_i=1+\frac{1}{m}\sum_{j=1}^{m}F_{gcd(i,j)}$<br/><br>这个$gcd(i,j)$下标不好处理，我们将其变为枚举 $gcd(i,j)$，则可以得到：<br/><script type="math/tex; mode=display">
F_{i}=1+\frac{1}{m}\sum_{d|i}F_{d}\sum_{j=1}^{m}[gcd(i,j)==d]</script>内层循环是可以进一步化简的，我们设$g(d)=\sum_{i=1}^{m}[gcd(i,n)==d],G(d)=\sum_{i=1}^{m}[d|gcd(i,n)]$<br/><br>可以得出<script type="math/tex; mode=display">
\begin{aligned}
&G(d)=\sum_{d|k}g(k)=\lfloor\frac{m}{d}\rfloor[n\%d==0] \\
&g(d)=\sum_{d|k}\mu(\frac{k}{d})G(k)=\sum_{d|k}\mu(\frac{k}{d})\lfloor\frac{m}{k}\rfloor[n\%k==0]
\end{aligned}</script>然后可以将原式稍微变形，并将上式代入：<script type="math/tex; mode=display">
\sum_{j=1}^{m}[gcd(i,j)==d]=\sum_{j=1}^{\lfloor\frac{m}{d}\rfloor}[gcd(\frac{i}{d},j)==1]</script>代入 g(1) ，得<script type="math/tex; mode=display">
\begin{aligned}
\sum_{k}\mu(k)\lfloor\frac{m}{dk}\rfloor[\frac{i}{d}\%k==0]=\sum_{k|\frac{i}{d}}\mu(k)\lfloor\frac{m}{dk}\rfloor
\end{aligned}</script>令 $T=dk$ <script type="math/tex; mode=display">
\sum_{T|i}\mu(\frac{T}{d})\lfloor\frac{m}{T}\rfloor</script>代入原式<script type="math/tex; mode=display">
\begin{aligned}
F_i&=1+\frac{1}{m}\sum_{d|i}F_d\sum_{T|i}\mu(\frac{T}{d})\lfloor\frac{m}{T}\rfloor \\
&=1+\frac{1}{m}\sum_{T|i}\lfloor\frac{m}{T}\rfloor\sum_{d|T}\mu(\frac{T}{d})F_d
\end{aligned}</script>内层循环与 i 无关，因此可以进行处理，在求 F 的同时进行更新。<br>注意到左右两边均存在 $F_i$ ，将右边的 $F_i$提出并合并到左边即可<script type="math/tex; mode=display">
\begin{aligned}
F_i&=1+\frac{1}{m}\sum_{T|i}\lfloor\frac{m}{T}\rfloor\sum_{d|T}\mu(\frac{T}{d})F_d \\
&=1+\frac{1}{m}\sum_{T|i}\lfloor\frac{m}{T}\rfloor\sum_{d|T}\mu(\frac{T}{d})F_d[d\neq i]+\frac{1}{m}\lfloor\frac{m}{i}\rfloor\mu(1)F_i \\
&=1+\frac{1}{m}\sum_{T|i}\lfloor\frac{m}{T}\rfloor\sum_{d|T}\mu(\frac{T}{d})F_d[d\neq i]+\frac{1}{m}\lfloor\frac{m}{i}\rfloor F_i \\
F_{i}&=\frac{m+\sum_{T|i}\lfloor\frac{m}{T}\rfloor\sum_{d|T}\mu(\frac{T}{d})F_d[d\neq i]}{m-\lfloor\frac{m}{i}\rfloor}
\end{aligned}</script>记$g_T=\sum_{d|T}\mu(\frac{T}{d})F_d[d\neq i]$即可，每次求出$F_i$后更新 g ，因为 $g_T$在求出 $F_T$后被更新，因此求$F_T$时不需要特判$T\neq i$。<br/></li>
</ul>
<p>代码如下<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,M=<span class="number">1e5</span>,mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> a+b&gt;=mod?a+b-mod:a+b;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> a&lt;b?a-b+mod:a-b;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> a*<span class="number">1ll</span>*b%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)s=mul(s,a);</span><br><span class="line">        a=mul(a,a);</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> prime[N],mu[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;q[N];</span><br><span class="line"><span class="keyword">bool</span> f[N];</span><br><span class="line"><span class="keyword">int</span> F[N],g[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    f[<span class="number">1</span>]=<span class="literal">true</span>,mu[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=M;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!f[i])&#123;</span><br><span class="line">            prime[++prime[<span class="number">0</span>]]=i;</span><br><span class="line">            mu[i]=<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=prime[<span class="number">0</span>]&amp;&amp;i*prime[j]&lt;=M;++j)&#123;</span><br><span class="line">            f[i*prime[j]]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">            mu[i*prime[j]]=-mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=M;++i)</span><br><span class="line">        mu[i]=mu[i]&lt;<span class="number">0</span>?mu[i]+mod:mu[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=M;++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=M;j+=i)</span><br><span class="line">            q[j].push_back(i);</span><br><span class="line">    F[<span class="number">1</span>]=<span class="number">0</span>,g[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">&#125;<span class="keyword">int</span> m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=m;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=q[i].size()<span class="number">-1</span>;~j;--j)</span><br><span class="line">            F[i]=add(F[i],mul(m/q[i][j],g[q[i][j]]));</span><br><span class="line">        F[i]=add(F[i],m);</span><br><span class="line">        F[i]=mul(F[i],qpow(m-m/i,mod<span class="number">-2</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=m;j+=i)</span><br><span class="line">            g[j]=add(g[j],mul(F[i],mu[j/i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">        ans=add(ans,F[i]);</span><br><span class="line">    ans=add(<span class="number">1</span>,mul(ans,qpow(m,mod<span class="number">-2</span>)));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>莫比乌斯反演</tag>
        <tag>DP</tag>
        <tag>牛客每日一题</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>Educational Codeforces Round 99</title>
    <url>/codeforcesECR99/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="A-Strange-Functions"><a href="#A-Strange-Functions" class="headerlink" title="A. Strange Functions"></a>A. Strange Functions</h2><p><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLm1sL2NvbnRlc3QvMTQ1NS9wcm9ibGVtL0E=">题目链接<i class="fa fa-external-link-alt"></i></span><br>题意:g(x)定义为$\frac{x}{f(f(x))}$(f(x)表示将x翻转后的数),例如f(10)=1,对于给定的n求出1~n中有多少不同的g(x)<br>题解:<br>即n的长度数<br><span id="more"></span></p>
<h2 id="B-Jumps"><a href="#B-Jumps" class="headerlink" title="B. Jumps"></a>B. Jumps</h2><p><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLm1sL2NvbnRlc3QvMTQ1NS9wcm9ibGVtL0I=">题目链接<i class="fa fa-external-link-alt"></i></span><br>题意:初始在0,第k次可以选择+k或者-1,问到达n的最小次数<br>题解:<br>对于<script type="math/tex">\frac{n*(n+1)}{2}</script>,即为n次<br><br>对于这n次中任意一次变成-1,可以得到<script type="math/tex">\frac{(n-1)*n}{2}-1\sim\frac{n*(n+1)}{2}-1</script><br><br>令<script type="math/tex">F_{k}=\frac{k*(k+1)}{2}</script><br><br>则对于<script type="math/tex">n=F_{k}</script>,最小次数为k<br><br>对于<script type="math/tex">F_{k-1}\leq n\leq F_{k}-1</script>,最小次数为k<br><br>对于<script type="math/tex">n=F_{k}-1</script>,最小次数为k+1<br></p>
<h2 id="C-Ping-pong"><a href="#C-Ping-pong" class="headerlink" title="C. Ping-pong"></a>C. Ping-pong</h2><p><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLm1sL2NvbnRlc3QvMTQ1NS9wcm9ibGVtL0M=">题目链接<i class="fa fa-external-link-alt"></i></span><br>题意:详见题目<br>题解:<br>因为只是最大化自己的获胜次数<br>因此如果是Alice先手,Alice赢,则Bob必定不回球<br>如果是Alice先手,Bob赢,若Alice还能回球,则必定能降低Bob的获胜次数,因此这种情况不会发生<br>因此若输入为(n,m),输出(n-1,m)即可</p>
<h2 id="D-Sequence-and-Swaps"><a href="#D-Sequence-and-Swaps" class="headerlink" title="D.Sequence and Swaps"></a>D.Sequence and Swaps</h2><p><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLm1sL2NvbnRlc3QvMTQ1NS9wcm9ibGVtL0Q=">题目链接<i class="fa fa-external-link-alt"></i></span><br>题意:详见题目<br>题解:<br>否则对于<script type="math/tex">a_{i},a_{j}>x</script>,如果先把<script type="math/tex">a_{j}</script>替换成x,则<script type="math/tex">a_{i}</script>永远不可能小于等于x,因此每次都交换第一个符合的即可。<br>如果本身就是有序,则输出0<br>如果在交换若干次变成有序,则break并输出<br>如果交换后并非非递减,则break并输出-1即可</p>
<h2 id="E-F待填坑"><a href="#E-F待填坑" class="headerlink" title="E,F待填坑"></a>E,F待填坑</h2>]]></content>
      <tags>
        <tag>cf比赛</tag>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title>二维hash</title>
    <url>/%E4%BA%8C%E7%BB%B4hash/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>设sum[i][j]表示左上角为(1,1)，右下角为(i,j)的hash值，mod为模数。<br><span id="more"></span><br>则</p>
<script type="math/tex; mode=display">sum[i][j]=(a[i][j]+sum[i-1][j-1]*base1*base2+sum[i-1][j]*base1+sum[i][j-1]*base2)\%mod</script><p>即可。<br>求左上角为(A,B)，右下角为(C,D)的hash值：</p>
<script type="math/tex; mode=display">
return (sum[C][D]+sum[A][B]*base1^{C-A}*base2^{D-B}-sum[A][D]*base1^{C-A}-sum[C][B]*base2^{D-B}+mod)\%mod;</script><p>和二维前缀和及其相似。<br>细节未处理，比如可能会溢出。<br>mod可以取1e9+7,base1和base2可以取孪生素数。</p>
]]></content>
      <tags>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round#694 (Div. 2)</title>
    <url>/codeforcesR694/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLm1sL2NvbnRlc3QvMTQ3MQ==">比赛链接<i class="fa fa-external-link-alt"></i></span></p>
<span id="more"></span>
<h2 id="A-Strange-Partition"><a href="#A-Strange-Partition" class="headerlink" title="A.Strange Partition"></a>A.Strange Partition</h2><p><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLm1sL2NvbnRlc3QvMTQ3MS9wcm9ibGVtL0E=">题目链接<i class="fa fa-external-link-alt"></i></span></p>
<p>题目描述：给定长度为n的数组，可以任意次合并相邻元素，假设合并后长度为k，求$\sum_{i=1}^{k}{\lceil\frac{a_i}{k}\rceil}$的最小值和最大值。</p>
<p>题解：<br>简单的贪心。<br>很显然，当不合并时最大，当所有的合并时最小，这是因为可以证明任意合并两个变成一个后一定不会比不合并的更大，因此得证。</p>
<details>
    <summary>参考代码</summary>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> T,n,x;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> s1,s2;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        s1=s2=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;x);</span><br><span class="line">        <span class="keyword">int</span> p;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;p);</span><br><span class="line">            <span class="keyword">if</span>(p%x==<span class="number">0</span>)</span><br><span class="line">                s1+=p/x;</span><br><span class="line">            <span class="keyword">else</span> s1+=p/x+<span class="number">1</span>;</span><br><span class="line">            s2+=p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s2%x==<span class="number">0</span>)s2/=x;</span><br><span class="line">        <span class="keyword">else</span> s2=s2/x+<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld %lld\n&quot;</span>,s2,s1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<h2 id="B-Strange-List"><a href="#B-Strange-List" class="headerlink" title="B.Strange List"></a>B.Strange List</h2><p><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLm1sL2NvbnRlc3QvMTQ3MS9wcm9ibGVtL0E=">题目链接<i class="fa fa-external-link-alt"></i></span></p>
<p>题目描述：<br>给定n个元素的数组，从左到右，假设当前元素是q，如果x可以整除q，则在数组末尾增加x个$\frac{q}{x}$，如果x不可以整除q，则停止。<br/><br>问最终所有元素的和。</p>
<p>题解：<br>实际上如果q可以被x整除，则总和加上q，且如果$\frac{q}{x}$可以被x整除，总和仍然是加上q。<br>因此就简单了，因为x至少为2，则每个数最多被加上$log_{2}{n}$，这样纯模拟就行了，不过也可以稍作优化。<br>即记下每个数最多可以整除x的多少次方，取所有中最小的，假设都能被$x^k$整除，则接下来只有模拟至多n次。<br>复杂度就可以从$O(nlogn)$降低到$O(n)$</p>
<details>
    <summary>参考代码</summary>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,x;</span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="keyword">int</span> cnt[N],a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;x);</span><br><span class="line">        cnt[<span class="number">0</span>]=<span class="number">1e9</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">            <span class="keyword">int</span> p=a[i];</span><br><span class="line">            cnt[i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(p%x==<span class="number">0</span>)&#123;</span><br><span class="line">                ++cnt[i];</span><br><span class="line">                p/=x;</span><br><span class="line">            &#125;</span><br><span class="line">            cnt[i]=min(cnt[i],cnt[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">            cnt[i]=min(cnt[i],cnt[n]+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">            ans+=a[i]*<span class="number">1ll</span>*cnt[i];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<h2 id="C-Strange-Birthday-Party"><a href="#C-Strange-Birthday-Party" class="headerlink" title="C.Strange Birthday Party"></a>C.Strange Birthday Party</h2><p><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLm1sL2NvbnRlc3QvMTQ3MS9wcm9ibGVtL0M=">题目链接<i class="fa fa-external-link-alt"></i></span></p>
<p>题目描述：<br>略。</p>
<p>题解：<br>题目中有个很关键的条件，<del>结果我半天没看到</del></p>
<p>考虑 ( i , j ) ，假设 i 选的是$c_a$， j 选的是$c_b$，且$b\geq a$，$a\leq k_i,b\leq k_j$<br/><br>$\because c_1\leq c_2\leq c_3…\leq c_n$<br/><br>1.当$b\leq k_i$时，$c_a+c_b \leq c_b+c_a$，即交换后不变。<br/><br>2.当$b&gt; k_i$时，且$k_i$内还有未选的时，将$c_b$换成$k_i$内未选的更优，此时情况转化为第一种。<br/><br>3.当$b&gt; k_i$时，且$k_i$内已满时，将$c_b$换成$c_a$，将$c_a$换成$c_{k_i}$更优。<br/><br>因此可以得到一个贪心策略，即序号大的优先选择较小的 c ，且必定从c的第一个开始连续取，否则总能变得更优。<br>可能说的不是很清楚，看代码吧。</p>
<details>
    <summary>参考代码</summary>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> T,n,m;</span><br><span class="line"><span class="keyword">int</span> k[N];</span><br><span class="line"><span class="keyword">int</span> c[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> a&gt;b;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;k[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;c[i]);</span><br><span class="line">        sort(k+<span class="number">1</span>,k+<span class="number">1</span>+n,cmp);</span><br><span class="line">        <span class="keyword">int</span> fir=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(k[i]&gt;=fir)</span><br><span class="line">                ans+=c[fir++];</span><br><span class="line">            <span class="keyword">else</span> ans+=c[k[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

]]></content>
      <tags>
        <tag>cf比赛</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces Round 698(Div.2)</title>
    <url>/codeforcesR698/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>（其实是吐槽<br>昨天比赛刚开始换了三次网，换了两次镜像网站才勉强能看到题…<br>游戏体验极差，而且最后还掉了一点分。</p>
<span id="more"></span>
<h2 id="A-Nezzar-and-Colorful-Balls"><a href="#A-Nezzar-and-Colorful-Balls" class="headerlink" title="A.Nezzar and Colorful Balls"></a>A.Nezzar and Colorful Balls</h2><p><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLm1sL2NvbnRlc3QvMTQ3OC9wcm9ibGVtL0E=">题目链接<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给定 n 个球，每个球上有一个数字 a ，现在为每个球染色，要使得相同颜色球上的数组 a 是严格递增的，且 a 数组是递增的，求最小颜色数。</p>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>其实即 a 数组中出现次数最多的次数。<br>证明、代码略。</p>
<h2 id="B-Nezzar-and-Lucky-Number"><a href="#B-Nezzar-and-Lucky-Number" class="headerlink" title="B.Nezzar and Lucky Number"></a>B.Nezzar and Lucky Number</h2><p><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLm1sL2NvbnRlc3QvMTQ3OC9wcm9ibGVtL0I=">题目链接<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给定一个整数 $d(d\in[1,9])$ ，称一个数字为幸运数字当且仅当这个数字是正整数且至少有一位是 d ，给出 n 个数，对于每个数如果能由若干个幸运数字相加得到，则输出”YES”，否则输出”NO”。</p>
<h3 id="题解：-1"><a href="#题解：-1" class="headerlink" title="题解："></a>题解：</h3><p>我是真没想到这又是一场猜结论场…<br>（是我很菜，所以不能及时推出结论…</p>
<ul>
<li>若 $x \geq 10*d$ ，则一定是 YES<br/><br>如果$x\in[10*d,11*d)$，则是 YES<br/><br>如果$x\geq 11*d$，则减去若干个 d 后必定能得到$x’\in[10*d,11*d)$，则是 YES <br/></li>
<li>若 $x &lt; 10* d$<br>此时暴力判断即可，最简单的判断方式就是 x 减去若干个 d ，判断个位是否为 0 ，因为十位可以任取所以可以不管，如果个位为 0 则一定可以。</li>
</ul>
<p>参考代码如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="keyword">int</span> q,d;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;q,&amp;d);</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;++i)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">            <span class="keyword">if</span>(x&gt;=<span class="number">10</span>*d)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">bool</span> f=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">9</span>;++j)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(x&gt;=j*d&amp;&amp;((x-j*d)%<span class="number">10</span>==<span class="number">0</span>))&#123;</span><br><span class="line">                        f=<span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(f)<span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">                <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="C-Nezzar-and-Symmetric-Array"><a href="#C-Nezzar-and-Symmetric-Array" class="headerlink" title="C.Nezzar and Symmetric Array"></a>C.Nezzar and Symmetric Array</h2><p><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLm1sL2NvbnRlc3QvMTQ3OC9wcm9ibGVtL0M=">题目链接<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="题目描述：-2"><a href="#题目描述：-2" class="headerlink" title="题目描述："></a>题目描述：</h3><p>某数组有 2*n 个互不相同的数，每个数都能在数组中找到一个相反数。<br>令$d_i=\sum_{j=1}^{2n}|a_i-a_j|$，现在给了你数组 d ，试判断是否存在至少一种可能的原数组 a 。</p>
<h3 id="题解：-2"><a href="#题解：-2" class="headerlink" title="题解："></a>题解：</h3><p>前四题三个数学题…<br>首先互不相同且能找出相反数，可以得到不能有 0 ，如果仅存在一个 0 ，则 必定有一个数在原数组中无相反数。<br>然后我们将 a 数组从大到小排序，则前 n 个是正数，后 n 个是负数，并且因为从大到小排序，可以得到：</p>
<script type="math/tex; mode=display">
d_{i}=(a_1-a_i)+(a_2-a_i)+...+(a_i-a_i)+(a_i-a_{i+1})+(a_i-a_{i+2})...+(a_i-a_{2n})</script><p>然后根据相反数的条件，继续化简得到：</p>
<script type="math/tex; mode=display">
\begin{aligned}
d_{i}&=(a_1-a_i)+...+(a_i-a_i)+(a_i-a_{i+1})...+(a_i-a_{n})+(a_i+a_{n})+(a_i+a_{n-1})...+(a_i+a_1) \\
&=2(a_1+a_2+...+a_i)+(2n-2i)a_i
\end{aligned}</script><p>因为原数组从大到小排序了，则 d 应该是先递减后递增，且$d_{i}=d_{2<em>n-i+1}$<br/><br>为了方便，直接将 d 从小到大排序或者从大到小排序然后每两个判断下是否相同，即初步判断是否合法。<br>然后根据上述的式子推出原数组即可，例如 $2n\</em>a_1=d_1$ ，然后后面的做差即可求出。<br>我当时脑子有点乱，所以代码写的有点乱…<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> T ;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> d[N],a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;++i)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;d[i]);</span><br><span class="line">        sort(d+<span class="number">1</span>,d+<span class="number">2</span>*n+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">bool</span> f=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i+=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(d[i]!=d[i+<span class="number">1</span>])&#123;</span><br><span class="line">                f=<span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(d[<span class="number">2</span>*n]%(<span class="number">2</span>*n)!=<span class="number">0</span>||d[<span class="number">2</span>*n]==<span class="number">0</span>)f=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(!f)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        a[n]=d[<span class="number">2</span>*n]/(<span class="number">2</span>*n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;--i)&#123;</span><br><span class="line">            <span class="keyword">int</span> j=n-i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> p=(<span class="number">2</span>*n<span class="number">-2</span>*j+<span class="number">2</span>)*a[i+<span class="number">1</span>]+d[<span class="number">2</span>*i]-d[<span class="number">2</span>*(i+<span class="number">1</span>)];</span><br><span class="line">            <span class="keyword">if</span>(p%(<span class="number">2</span>*n<span class="number">-2</span>*j+<span class="number">2</span>)!=<span class="number">0</span>)&#123;</span><br><span class="line">                f=<span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            a[i]=p/(<span class="number">2</span>*n<span class="number">-2</span>*j+<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span>(!a[i]||a[i]==a[i+<span class="number">1</span>]||a[i]&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                f=<span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!f)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="D-Nezzar-and-Board"><a href="#D-Nezzar-and-Board" class="headerlink" title="D.Nezzar and Board"></a>D.Nezzar and Board</h2><p><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLm1sL2NvbnRlc3QvMTQ3OC9wcm9ibGVtL0Q=">题目链接<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="题目描述：-3"><a href="#题目描述：-3" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给出 n 个数，每次任选两个数 x , y ，并向数组中加一个数 2x - y ，问是否能得到 k </p>
<h3 id="题解：-3"><a href="#题解：-3" class="headerlink" title="题解："></a>题解：</h3><ol>
<li>若 n = 2 ，则可以得到的数是 x + k ( x - y ) ，即得到的数相差均为 ( x - y ) 的倍数，并且 x 和 y 均在得到的数中（这不是废话么</li>
<li>若 n = 3 ，任意取一个前两个数能得到的数 o ，则可以得到所有和 o 相差 x - y 和 z - o （z为第三个数）的数，然后这些数相差最小为 gcd( x - y , z - o )，既可以得到所有和 o 相差 gcd( x - y , z - o )的数<br>然后 o 随便取都行，只要是前两个数能得到的数即可，反正最后不会影响 gcd 的取值</li>
<li>n 无限制，即求出查分数组的 gcd ，然后判断 gcd 是否能整除 $k-a_1$即可。</li>
</ol>
<p>参考代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">gcd</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> b)</span></span>&#123;<span class="keyword">return</span> !b?a:gcd(b,a%b);&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T,n;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%lld&quot;</span>,&amp;n ,&amp;k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> GCD=<span class="built_in">abs</span>(a[<span class="number">2</span>]-a[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=n;++i)</span><br><span class="line">            GCD=gcd(GCD,<span class="built_in">abs</span>(a[i]-a[i<span class="number">-1</span>]));</span><br><span class="line">        <span class="keyword">if</span>((k-a[<span class="number">1</span>])%GCD==<span class="number">0</span>)<span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>cf比赛</tag>
      </tags>
  </entry>
  <entry>
    <title>wust菜鸟杯题目&amp;题解</title>
    <url>/wust%E8%8F%9C%E9%B8%9F%E6%9D%AF%E9%A2%98%E7%9B%AE-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>如果有想看详细题目却没有纸质文件的，可以找有纸质文件的人。</p>
<h2 id="A-mqy爱回文串"><a href="#A-mqy爱回文串" class="headerlink" title="A.mqy爱回文串"></a>A.mqy爱回文串</h2><p>题目描述：<br>给定<script type="math/tex">T</script>个长度为<script type="math/tex">n</script>的字符串，要求你判断是否为回文串（从左到右和从右到左相同的字符串），若是则输出<script type="math/tex">1</script>，否则输出<script type="math/tex">0</script>。</p>
<span id="more"></span>
<p>题解：<br>签到题。你可以就直接比较从左到右和从右到左的这两个字符串是否相同，当然这个可以不同新建一个字符串实现，只要判断从左到右的第<script type="math/tex">i</script>个字符是否等于从右到左的第<script type="math/tex">i</script>个字符即可，如果全部相同则是，否则不是。</p>
<p>对于回文串，其实只用比较一半的长度即可，当长度为偶数时很显然，当长度为奇数时中间一个字符就等于它本身。</p>
<h2 id="B-拳王mqy"><a href="#B-拳王mqy" class="headerlink" title="B.拳王mqy"></a>B.拳王mqy</h2><p>题目描述：<br>给定<script type="math/tex">N</script>个数<script type="math/tex">a_1,a_2...a_N</script>，<script type="math/tex">Q</script>组询问<script type="math/tex">[L,R]</script>,求<script type="math/tex">a_{L}+a_{L+1}+...+a_{R}</script>。</p>
<script type="math/tex; mode=display">1\leq N,Q\leq 1000000</script><p>题解：<br>我估计很多人是超时了，超时的人大多是没学过时间复杂度吧，关于时间复杂度的详细解读请看下图（源自数据结构与算法分析，这本书较难，不要轻易尝试），后面会涉及到复杂度，不会再做解释，建议仔细看看这里的详解。<br><img data-src="https://s3.ax1x.com/2020/12/06/DjO7zd.md.jpg" alt=""><br><img data-src="https://s3.ax1x.com/2020/12/06/DjO7zd.md.jpg" alt=""><br>计算机每秒计算次数在<script type="math/tex">10^8\sim 5*10^8</script>之间。<br>超时的人，你们可以算算自己的最坏时间复杂度为多少，会不会超时。<br>正解是维护前缀和。前缀和很常用的，适用于静态的不会改变的求区间问题。<br>例如这题，求<script type="math/tex">a_{L}+a_{L+1}+...+a_{R}</script>，那么我只需要用<script type="math/tex">(a_{1}+a_{2}+...a_{R})-(a_1+a_2+...a_{L-1})</script>，我令<script type="math/tex">s[i]=a_1+a_2+...+a_i</script>，这样每次答案就是输出<script type="math/tex">s_R-s_{L-1}</script>。<br>但是如果我能修改其中的数呢？这样子每次修改一个<script type="math/tex">a_i</script>会修改很多的<script type="math/tex">s</script>，前缀和就不使用了，就需要用到树状数组或者线段树，感兴趣的可以学学前缀和做几道题后再学学树状数组、线段树。</p>
<h2 id="C-mqy的女装"><a href="#C-mqy的女装" class="headerlink" title="C.mqy的女装"></a>C.mqy的女装</h2><p>题目描述：<br>有一个村庄的村民不能相互交流，也看不到自己的着装，但每一天早晨，他们都能看到<strong>除自己外</strong>的其他人的着装。<br>有一天有个旅行家告诉他们有人穿了女装，但没说多少人，也没指出是谁就走了。<br>该村村民都很聪明，如果他们能根据已有线索推出自己穿着女装，他们就会在当天下午脱下女装。<br>如果将旅行家来的第一天当做第一天，mqy想知道自己是哪一天脱下的女装。<br>输入n,m分别为村民个数和女装大佬个数。<br>题解：<br>注意到在任何一个女装大佬眼里看到的都一样，因此如果有一个人判断出了自己就是，那么应该所有女装的都能判断出来。<br>假设我现在就是其中一个女装大佬，我看到有k个人女装了。<br>我现在如果认为我不是女装大佬，并且k个人女装应该在第f(k)天全部脱下女装，如果在第f(k)+1天我看到他们均没有脱下女装，那么这与我不是相违背，即我能判断出我一定是一个女装大佬。<br>事实上村民个数无关紧要，如果m=1，那么答案很简单就是1，因为唯一的那个看到别人都不是，那么自己肯定是。<br>如果m=2,因为mqy只看到1个女装，但是那个人第二天还在穿女装(女装只有1次和无数次！)，那么说明肯定自己也是。<br>同理m=3,因为mqy看到3个女装，如果自己不是，应该第三天就都不是女装了，但实际不然，所以可以判断自己是女装。<br>因此我们可以得出结论，输出m即可。<br>思维题，比较有趣。</p>
<h2 id="D-mqy与地下城"><a href="#D-mqy与地下城" class="headerlink" title="D.mqy与地下城"></a>D.mqy与地下城</h2><p>题目描述：<br>输入一个<script type="math/tex">n</script>，判断是否是素数。</p>
<p>题解：<br>这题<script type="math/tex">n<10^6</script>,因此暴力<script type="math/tex">2\sim i</script>都可以过，如果存在<script type="math/tex">n\%i==0</script>，说明不是素数，否则是素数。<br>拓展：考试确实要以最快的方法优先，怎样你觉得写得快并且能过就怎样写，但是考完了就要想是否能有更好的方法？<br>我们如果对于n分解质因数，那么实际上n的最大质因数超过<script type="math/tex">\sqrt{n}</script>的不会超过1个，如果超过了1个，则乘起来必定大于n。<br>如果n是素数，那么分解除的素数就是n本身;如果n不是素数，则分解出来的素数个数至少是2个，且因为超过<script type="math/tex">\sqrt{n}</script>的至多一个，则我们必定能在<script type="math/tex">2\sim \sqrt{n}</script>之内找到一个数能整除n<br>因此我们只用判断<script type="math/tex">\sqrt{n}</script>以内的即可。(注意：不要从1开始，且1，2要特判)<br>这样时间复杂度是<script type="math/tex">O(\sqrt{n})</script><br>下次即便将n开到<script type="math/tex">10^{12}</script>你都可以过。</p>
<h2 id="E-mqy去军训"><a href="#E-mqy去军训" class="headerlink" title="E.mqy去军训"></a>E.mqy去军训</h2><p>题目描述：<br>给定一个字符串，求出其中有多少个<script type="math/tex">"MQY"</script>(这里的MQY不一定需要连续，只要是M出现在Q前，Y出现在Q后即可)</p>
<p>题解：<br>还记得第二题的前缀和吗，因为只要M在Q前，Y在Q后即可，那么我们不妨对于每一个Q，找出他前面的所有的M个数为q，他后面所有的Y为w，则ans+=q*w即可。<br>另一种做法（此方法不要求掌握，但能理解更好）就是我记一个二维数组<script type="math/tex">dp[i][j]</script>，<script type="math/tex">dp[i][0]</script>表示前i个字符中空串的个数(实际上一直为1)，<script type="math/tex">dp[i][1]</script>表示前<script type="math/tex">i</script>个字符中<script type="math/tex">"M"</script>出现个数，<script type="math/tex">dp[i][2]</script>表示前i个字符中<script type="math/tex">"MQ"</script>出现个数,<script type="math/tex">dp[i][3]</script>表示前i个字符中<script type="math/tex">"MQY"</script>出现个数。</p>
<p>对于第i个位置，有</p>
<script type="math/tex; mode=display">
dp[i][0]=dp[i-1][0],dp[i][1]=dp[i-1][1],
dp[i][2]=dp[i-1][2],dp[i][3]=dp[i-1][3]</script><p>即不考虑当前字符时答案。</p>
<p>之后考虑当前位置的字符，如果是‘M’,前面的空串加上’M’构成了”M”，则<script type="math/tex">dp[i][1]+=dp[i-1][0]</script>；如果是’Q’，前面的”M”加上’Q’变成”MQ”，则<script type="math/tex">dp[i][2]+=dp[i-1][1]</script>；如果是’Y’，前面的”MQ”加上’Y’变成”MQY”，则<script type="math/tex">dp[i][3]+=dp[i-1][2]</script>。<br>最后答案显然就是<script type="math/tex">dp[n][3]</script>。在这样递推前注意<script type="math/tex">dp[0][0]=1,dp[0][1]=dp[0][2]=dp[0][3]=0</script> 这个根据定义不难解释。</p>
<h2 id="F-mqy拯救世界"><a href="#F-mqy拯救世界" class="headerlink" title="F.mqy拯救世界"></a>F.mqy拯救世界</h2><p>题目描述：<br>$A\sim J$表示$0\sim 9$，给定一个由$A\sim J$构成的字符串，设number为这个字符串代表的数字，求[1,number]中所有数字代表的字符串中H出现的次数。</p>
<p>题解：<br>题目听迷惑人的，什么字符串转数字啊，数字转字符串啊，实际上这题很友好，是十进制，就比较好做了，不妨求出number先(这个不用讲吧)</p>
<p>然后就是找出[1,number]中所有数字7出现的次数嘛。</p>
<h2 id="G-mqy开运动会"><a href="#G-mqy开运动会" class="headerlink" title="G.mqy开运动会"></a>G.mqy开运动会</h2><p>题目描述：<br>计院要派出4个人参加4*100m接力赛，其中2人只跑直道，另外2人只跑弯道，先给出n个人每个人跑直道和弯道的速度(单位:m/s)</p>
<script type="math/tex; mode=display">n\leq 100</script><p>题解：<br>注意到n很小，我们直接从100个人出取出4个人即可，这样总共<script type="math/tex">C(n,4)</script>次，然后选出4人要计算4次，这样绝对是不会超时的。（dfs或者四层for都行）</p>
<p>但是这种做法在n=1000或者更大就会超时了，毕竟<script type="math/tex">n^4</script>就是<script type="math/tex">10^{12}</script>了。</p>
<p>假如我们只需要选出4个直道，那么我们按照直道速度从大到小排序，选出其中4个即可；弯道同理。<br>对于选出两个直道，两个弯道，我们不妨将直道前4和弯道前4选出来，我们可以证明最优解不会是既不是直道前4又不是弯道前4的。<br>假设存在这样一个人wjr是既不是直道前4，又不是弯道前4，则直道和弯道中至少都剩下一个人可以选，当且仅当其余三个人都是直道和弯道前4时是直道和弯道都剩1个人可以选，其余情况都会有更多可以选的。<br>如果wjr是直道的，直道还剩下至少一人可以选，我们不妨将wjr换成那个可以选的；弯道同理。<br>因此这样就可以把题目变成在直道前4<strong>或者</strong>弯道前4的最多8个人中选4个出来(既是直道前4又是弯道前4算一人)<br>然后n就算很大也可以很快做出来。</p>
<h2 id="H-mqy和DP"><a href="#H-mqy和DP" class="headerlink" title="H.mqy和DP"></a>H.mqy和DP</h2><p>题目描述：<br>mqy给了你一段代码，让你帮他求出结果。</p>
<p>题解：<br>注意到原代码复杂度是<script type="math/tex">O(T*n^2)</script>，直接将代码交上去肯定是过不了的，我们要想出更快的方法来做。<br>我们假设考虑每个<script type="math/tex">dp[i][j]</script>对答案的贡献(常用思想)</p>
<script type="math/tex; mode=display">dp[n][1]:1</script><script type="math/tex; mode=display">dp[n-1][1]:1\ dp[n-1][2]:1</script><script type="math/tex; mode=display">dp[n-2][1]:1\ dp[n-2][2]:2\ dp[n-2][3]:1</script><script type="math/tex; mode=display">dp[n-3][1]:1\ dp[n-3][2]:3\ dp[n-3][3]:3\ dp[n-3][4]:1</script><p>…</p>
<p>这个是怎么算出来的呢？我们考虑dp[i][j]会被哪些数加起来，可以发现<script type="math/tex">dp[i+1][j]=dp[i][j]+dp[i][j+1],dp[i+1][j-1]=dp[i][j-1]+dp[i][j]</script></p>
<p>设<script type="math/tex">dp[i][j]</script>被加了<script type="math/tex">f[i][j]</script>次</p>
<p>这样<script type="math/tex">dp[i][j]</script>在<script type="math/tex">dp[i+1][j]</script>和<script type="math/tex">dp[i+1][j-1]</script>都被算了一次，即<script type="math/tex">dp[i][j]</script>算了<script type="math/tex">f[i+1][j-1]+f[i+1][j]</script>次，即<script type="math/tex">f[i][j]=f[i+1][j-1]+f[i+1][j]</script><br>这个式子看着和<script type="math/tex">C(i,j)=C(i-1,j-1)+C(i-1,j)</script>很像吧？<br>其实最后很容易就能求出来<script type="math/tex">f[1][1]=C(n-1,1),f[1][2]=C(n-1,2),f[1][i]=C(n-1,i)</script><br>最后就是求<script type="math/tex">(\sum_{i=1}^{n}A[i]*f[1][i]) \% 2</script></p>
<p><script type="math/tex">C(n,i)=\frac{n!}{i!(n-i)!}</script>，这样我们不妨求出<script type="math/tex">pr2[i]</script>表示i分解质因数后有多少个2，如果<script type="math/tex">pr2[n]-pr2[i]-pr2[n-i]==0</script>说明<script type="math/tex">C(n,i)</script>是奇数，否则就是偶数，这样对2取模后也能知道为多少。</p>
<p>预处理下<script type="math/tex">pr2</script>，然后对于每组询问<script type="math/tex">O(n)</script>，总时间复杂度为<script type="math/tex">O(T*n)</script>。</p>
<h2 id="I-mqy劝你耗子尾汁"><a href="#I-mqy劝你耗子尾汁" class="headerlink" title="I.mqy劝你耗子尾汁"></a>I.mqy劝你耗子尾汁</h2><p>题目描述：<br>出题人不讲武德，来骗，来偷袭。逆序输出害死多少人。 </p>
<p>这题就是给了十个问题，让你逆序输出答案。<br>题解：<br>无</p>
<h2 id="J-mqy和高木同学"><a href="#J-mqy和高木同学" class="headerlink" title="J.mqy和高木同学"></a>J.mqy和高木同学</h2><p>题目描述：<br>mqy又双叒叕被高木骗了，他现在要点5个菜，每个菜有一个上菜时间，并且他只能在10的倍数分钟(如0，10，20，30…)点菜，请问这5个菜最早上完的时间。</p>
<p>题解：<br>因为只能在10的倍数分钟点菜，假设点的菜上菜时间为x，当前是在10*k分钟点菜<br>1.x是10的倍数，则下次是10*k+x分钟才能点菜，间隔了x分钟。<br>2.x不是10的倍数，则下次是10*k+int(x/10+1)*10分钟才能点菜，间隔int(x/10+1)*10分钟。</p>
<p>当且仅当最后一次点菜时，间隔时间始终是x，非最后一次点菜，下一次点菜与这一次间隔时间是个定值，，所以其实我只要最后一次点的菜%10最小就行了。(说白了前4个菜无论啥顺序时间都一样)</p>
<h2 id="K-mqy爱数数"><a href="#K-mqy爱数数" class="headerlink" title="K.mqy爱数数"></a>K.mqy爱数数</h2><p>题目描述：<br>给了一个’#’构成的WUSTACM图样，求图中’#’个数对(11/(45-1)*4)取模的结果。</p>
<p>题解：<br>这题hhh，有多少人是没注意到模数是1就数了的，有的举个爪。(我第一次看也是看成这样了，然后果然跳了)<br>任何整数对1取模都是0，然后输出0就行。</p>
<p>什么？你问如果模数不是1咋办？<del>那就数呗，分数不要白不要</del>。<br>其实你可以将这个图读入进来(复制粘贴)，然后你自己写个数’#’的，这样肯定比你数快一些吧(这次我没试过，不知道行不行，反正大多数情况这种题就是这样吧)</p>
<h2 id="L-欢乐时光开始了"><a href="#L-欢乐时光开始了" class="headerlink" title="L.欢乐时光开始了"></a>L.欢乐时光开始了</h2><p>题目描述：<br>输出”Hello WUST’ACM”</p>
<p>题解：<br><del>你送分的样子很帅，但你把这题放到最后的样子真的很狼狈</del></p>
<p>题外话：评论区资瓷 昵称输入QQ号自动变成QQ昵称和QQ头像，以及资瓷500个左右的b站表情包，欢迎评论！</p>
]]></content>
  </entry>
  <entry>
    <title>codeforces美化</title>
    <url>/codeforces%E7%BE%8E%E5%8C%96/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>谷歌浏览器的codeforces美化方法。</p>
<span id="more"></span>
<p>点击谷歌浏览器右上角自定义及控制（竖着的三个点）<br><img data-src="https://tu.sunpma.com/imgs/2021/01/f4e7104bfe4762d7.png" alt=""><br>点击更多工具并进入扩展程序<br><img data-src="https://tu.sunpma.com/imgs/2021/01/17a05f81538ff962.png" alt=""><br>点击左上角扩展程序并点击弹出的窗口下面的“打开Chrome网上商店”<br><img data-src="https://tu.sunpma.com/imgs/2021/01/f3265b52ed36e54c.png" alt=""><br><img data-src="https://tu.sunpma.com/imgs/2021/01/649074f270b6af0f.png" alt=""><br>在搜索框内搜索stylus<br><img data-src="https://tu.sunpma.com/imgs/2021/01/ab28eb144e5d21e1.png" alt=""><br>点击第一个并添加到Chrome</p>
<p><span class="exturl" data-url="aHR0cHM6Ly91c2Vyc3R5bGVzLm9yZy9zdHlsZXMvMTkxNjY1L2NvZGVmb3JjZXM=">下载codeforces美化脚本<i class="fa fa-external-link-alt"></i></span></p>
<p>(可能会比较慢)</p>
<p>脚本有一个开启/关闭顶栏动画可选。</p>
<p>Customize Settings中选择turn off即可关闭顶栏动画。（顶栏动画为动态）</p>
<p>这里还有个wusoj的美化脚本（wustoj是武汉科技大学的OJ）<br><span class="exturl" data-url="aHR0cHM6Ly91c2Vyc3R5bGVzLm9yZy9zdHlsZXMvMTkwNDcxL3d1c3Rvag==">wustoj美化脚本<i class="fa fa-external-link-alt"></i></span></p>
<p>为了方便起见，可以固定该扩展<br><img data-src="https://tu.sunpma.com/imgs/2021/01/c86897a69b90d969.png" alt=""></p>
<p>如果想取消某个网站的所有脚本<br><img data-src="https://tu.sunpma.com/imgs/2021/01/3614a2eda352e992.png" alt=""></p>
<p>如果想更换脚本或者更新脚本请在管理样式界面操作。</p>
]]></content>
      <tags>
        <tag>网站美化</tag>
      </tags>
  </entry>
  <entry>
    <title>备忘录</title>
    <url>/%E5%A4%87%E5%BF%98%E5%BD%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="加密博文格式可能会出现问题"><a href="#加密博文格式可能会出现问题" class="headerlink" title="加密博文格式可能会出现问题"></a>加密博文格式可能会出现问题</h2><p>出现问题需要刷新几次。</p>
<span id="more"></span>
<h2 id="嵌入b站视频的方法"><a href="#嵌入b站视频的方法" class="headerlink" title="嵌入b站视频的方法"></a>嵌入b站视频的方法</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;position: relative; padding: 0% 0%;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">style</span>=<span class="string">&quot;position: absolute; width: 100%; </span></span></span><br><span class="line"><span class="tag"><span class="string">height: 100%; left: 0; top: 0;&quot;</span> </span></span><br><span class="line"><span class="tag"><span class="attr">src</span>=<span class="string">&quot;//player.bilibili.com/player.html?aid=52516662&amp;bvid=BV1o4411E7xW</span></span></span><br><span class="line"><span class="tag"><span class="string">&amp;cid=91907659&amp;page=1&amp;as_wide=1&amp;high_quality=1&amp;danmaku=1&quot;</span> <span class="attr">scrolling</span>=<span class="string">&quot;no&quot;</span> <span class="attr">border</span>=<span class="string">&quot;0&quot;</span> </span></span><br><span class="line"><span class="tag"><span class="attr">frameborder</span>=<span class="string">&quot;no&quot;</span> <span class="attr">framespacing</span>=<span class="string">&quot;0&quot;</span> <span class="attr">allowfullscreen</span>=<span class="string">&quot;true&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>效果如下</p>
<div style="position: relative; padding: 0% 0%;">
<iframe style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;" src="//player.bilibili.com/player.html?aid=52516662&bvid=BV1o4411E7xW&cid=91907659&page=1&as_wide=1&high_quality=1&danmaku=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"></iframe>
</div>


<h2 id="加密格式"><a href="#加密格式" class="headerlink" title="加密格式"></a>加密格式</h2><p>encrypt: true<br>enc_pwd: 密码</p>
<h2 id="图片出现403"><a href="#图片出现403" class="headerlink" title="图片出现403"></a>图片出现403</h2><p>尝试在文章开头加上<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;referrer&quot;</span> <span class="attr">content</span>=<span class="string">&quot;no-referrer&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></p>
]]></content>
  </entry>
  <entry>
    <title>Educational Codeforces Round 103 (Rated for Div. 2)</title>
    <url>/eduRound103/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我居然能在B题上因为 long long 和向上取整错四次…（人才<br>好在之后几题比较顺<br><span id="more"></span></p>
<h2 id="A-K-divisible-Sum"><a href="#A-K-divisible-Sum" class="headerlink" title="A. K-divisible Sum"></a>A. K-divisible Sum</h2><p><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9jb250ZXN0LzE0NzYvcHJvYmxlbS9B">题目链接<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给出 n 和 k ，你要构造一个 n 个元素的数组 a ，a 所有元素的和可以被 k 整除，求出 a 最大元素最小可能是多少。</p>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>假设 a 中最大元素是 MAX ，则可以得到的数是 $MAX+n-1\sim n*MAX$<br/></p>
<ul>
<li>$k\geq n$时，找到最小的MAX使得$n*MAX\geq k$即可，即$\lceil\frac{k}{n}\rceil$<br/></li>
<li>$k &lt; n$时，如果$n\%k=0$则 MAX = 1 即可满足题意，如果$n\%k\neq 0$，当 MAX = 2 时，可以得到$n+1 \sim 2n$，必定存在一个数能被 k 整除。</li>
</ul>
<p>参考代码如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,x,T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;x);</span><br><span class="line">        <span class="keyword">if</span>(n&gt;x)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n%x==<span class="number">0</span>)</span><br><span class="line">            	<span class="built_in">printf</span>(<span class="string">&quot;1\n&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            	<span class="built_in">printf</span>(<span class="string">&quot;2\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x%n==<span class="number">0</span>)<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,x/n);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,x/n+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="B-Inflation"><a href="#B-Inflation" class="headerlink" title="B. Inflation"></a>B. Inflation</h2><p><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9jb250ZXN0LzE0NzYvcHJvYmxlbS9C">题目链接<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给定一个数组$p_0,p_1…p_{n-1}$，可以令每个$p_i$加上一个非负整数$a_i$，使得$\frac{p_i}{p_0+p_1+…+p_{i-1}}\leq k\%$，要求$\sum_{i=0}^{n-1}a_i$的最小值。</p>
<h3 id="题解：-1"><a href="#题解：-1" class="headerlink" title="题解："></a>题解：</h3><p>这题我花了23分钟，还错了4次…<br>这题是贪心，结论其实可以直接猜出来。<br>我们从前往后处理每个数，如果$\frac{p_i}{p_0+p_1+…+p_{i-1}} &gt; k\%$，则将$p_i$加到使得$\frac{p_i}{p_0+p_1+…+p_{i-1}} \leq k\%$，顺便更新答案即可。<br/><br>这样我们确实前面的是最小化了，但是能否保证后面也能最小化答案呢？<br>如果 $\frac{x}{y}=\frac{k}{100}$ ，则当 y 变化 100 时， x 只变化 k <br/><br>我们假设我们贪心到 i 有 $\frac{p_i+a_i}{p_0+p_1+…+p_{i-1}+x}=\frac{k}{100}$ ，如果分母增大，则分子减少的小于等于分母增加的，因此不会更优，往后处理时均如此。<br/><br>因此这个贪心策略是正确的。</p>
<p>参考代码如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span>  T,n,k;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">105</span>],d[<span class="number">105</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> s=a[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]*<span class="number">100ll</span>&gt;k*s)&#123;</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> x=<span class="built_in">ceil</span>((<span class="number">100ll</span>*a[i]-k*s)*<span class="number">1.0</span>/k);</span><br><span class="line">                ans+=x;</span><br><span class="line">                s+=x;</span><br><span class="line">            &#125;</span><br><span class="line">            s+=a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>那个向上取整其实可以用更好的写法，即$long long x=(100ll*a[i]+k-1)/k-s;$，这样避免了精度问题。</p>
<h2 id="C-Longest-Simple-Cycle"><a href="#C-Longest-Simple-Cycle" class="headerlink" title="C. Longest Simple Cycle"></a>C. Longest Simple Cycle</h2><p><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9jb250ZXN0LzE0NzYvcHJvYmxlbS9D">题目链接<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="题目描述：-2"><a href="#题目描述：-2" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给出 n 条链，每条链的首、尾与上一条链的两个点相连，请求出最大的简单环。<br><img data-src="https://espresso.codeforces.com/f5b742ef7ad02ab00141f54a6dda3eb9bc79d4d3.png" alt=""></p>
<h3 id="题解：-2"><a href="#题解：-2" class="headerlink" title="题解："></a>题解：</h3><p>其实真的很简单。<br>我们设$dp_i$表示第 i 条链和在其之前的链构成的最大简单环的长度，则很显然第 i 条链要么通过与上一条链连接的两个点以及自己构成一个简单环，要么是通过与上一条链构成的最大简单环构成一个新的最大简单环（需要减去重复部分）<br>因此顺着这样求就行了，我为了简便书写就改了一点变量（感觉貌似更复杂了，服了我自己</p>
<p>参考代码如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> T,n;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,inf=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> a[N],b[N],c[N];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;c[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;b[i]);</span><br><span class="line">        dp[<span class="number">1</span>]=-inf;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            dp[i]=<span class="number">2</span>+<span class="built_in">abs</span>(a[i]-b[i]);</span><br><span class="line">            <span class="keyword">int</span> L=min(a[i],b[i]),R=max(a[i],b[i]);</span><br><span class="line">            <span class="keyword">if</span>(a[i]!=b[i])</span><br><span class="line">                dp[i]=max(dp[i],<span class="number">2</span>+dp[i<span class="number">-1</span>]+L<span class="number">-1</span>+c[i<span class="number">-1</span>]-R);</span><br><span class="line">            ans=max(ans,dp[i]+c[i]<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="D-Journey"><a href="#D-Journey" class="headerlink" title="D. Journey"></a>D. Journey</h2><p><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9jb250ZXN0LzE0NzYvcHJvYmxlbS9E">题目链接<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="题目描述：-3"><a href="#题目描述：-3" class="headerlink" title="题目描述："></a>题目描述：</h3><p>n + 1 个城市，从 $0\sim n$<br/><br>给出一个长度为 n 的字符串，如果第 i 位是 L ，表示有一条从 i 到 i-1 的有向边；如果是 R ，表示有一条从 i-1 到 i 的有向边。<br>且每次经过一条边后所有边的朝向改变，对于每一个城市，求出以其为初始位置时能经过的最多城市数。</p>
<h3 id="题解：-3"><a href="#题解：-3" class="headerlink" title="题解："></a>题解：</h3><p>每次朝向会改变，我想都没想直接以时间点为奇数/偶数拆点建图了，初始时间为 0 。<br>然后把样例手模一下，发现一个简单的并查集就能做了，因为每条边都是双向边，并且连接着的是相邻且时间奇偶性不同的连个点，这样一来既不会有一个城市既能在偶数时间点被访问又在奇数时间点被访问，而且因为双向可以互相到达。<br>那么其实缩点也可以做到，不过我这里为了代码书写起来简单直接写了个并查集，其他方法没想过了，反正我觉得拆点后可以秒出。</p>
<p>参考代码如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> fa[N&lt;&lt;<span class="number">1</span>],siz[N&lt;&lt;<span class="number">1</span>],T,n;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> x==fa[x]?x:fa[x]=get(fa[x]);&#125;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    x=get(x),y=get(y);</span><br><span class="line">    <span class="keyword">if</span>(x==y)<span class="keyword">return</span>;</span><br><span class="line">    fa[x]=y;</span><br><span class="line">    siz[y]+=siz[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> c=<span class="number">2</span>*(n+<span class="number">1</span>),S=n+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=c;++i)</span><br><span class="line">            fa[i]=i,siz[i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;L&#x27;</span>)</span><br><span class="line">                link(i+<span class="number">1</span>,i+S);</span><br><span class="line">            <span class="keyword">else</span> link(i,i+<span class="number">1</span>+S);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=S;++i)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,siz[get(i)]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h2 id="E-Pattern-Matching"><a href="#E-Pattern-Matching" class="headerlink" title="E. Pattern Matching"></a>E. Pattern Matching</h2><p><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9jb250ZXN0LzE0NzYvcHJvYmxlbS9F">题目链接<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="题目描述：-4"><a href="#题目描述：-4" class="headerlink" title="题目描述："></a>题目描述：</h3><p>见题目。</p>
<h3 id="题解：-4"><a href="#题解：-4" class="headerlink" title="题解："></a>题解：</h3><p>想清楚就不难，但就是想不清楚，想出来后又觉得我当时为啥这么蠢。</p>
<p>其实每个字符串最多能匹配$2^4$个模式串，利用拓扑排序的方式即可，如果字符串能匹配 mt 模式串，则将 mt 模式串与其他所有该字符串能匹配的模式串连有向边（起点是 mt ）；如果不能匹配则说明无解。<br>之后拓扑排序即可的出答案。<br>然后就要考虑如何快速得到字符串能匹配到的所有模式串了，可以字典树或者map，具体就不细讲了。</p>
<p>参考代码如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> ch[N&lt;&lt;<span class="number">2</span>][<span class="number">27</span>],val[N&lt;&lt;<span class="number">2</span>],cnt;</span><br><span class="line"><span class="keyword">int</span> d[N&lt;&lt;<span class="number">1</span>],nxt[N&lt;&lt;<span class="number">4</span>],to[N&lt;&lt;<span class="number">4</span>],tot;</span><br><span class="line"><span class="keyword">int</span> deg[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line"><span class="keyword">int</span> ans[N&lt;&lt;<span class="number">1</span>],ans2[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    to[++tot]=b;</span><br><span class="line">    nxt[tot]=d[a];</span><br><span class="line">    d[a]=tot;</span><br><span class="line">    ++deg[b];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m,k;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span>*s,<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;_&#x27;</span>)j=<span class="number">26</span>;</span><br><span class="line">        <span class="keyword">else</span> j=s[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!ch[p][j])ch[p][j]=++cnt;</span><br><span class="line">        p=ch[p][j];</span><br><span class="line">    &#125;</span><br><span class="line">    val[p]=id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> f;</span><br><span class="line"><span class="keyword">bool</span> g;</span><br><span class="line"><span class="keyword">int</span> num,mt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">char</span>*s,<span class="keyword">int</span> now)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(now&gt;k)&#123;</span><br><span class="line">        <span class="keyword">if</span>(val[p]==mt)&#123;</span><br><span class="line">            g=<span class="literal">true</span>;</span><br><span class="line">            ins(mt,num+n);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ins(num+n,val[p]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    work(ch[p][s[now]-<span class="string">&#x27;a&#x27;</span>],s,now+<span class="number">1</span>);</span><br><span class="line">    work(ch[p][<span class="number">26</span>],s,now+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">    cnt=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>),insert(s,i);</span><br><span class="line">    f=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">        num=i;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>,s+<span class="number">1</span>,&amp;mt);</span><br><span class="line">        g=<span class="literal">false</span>;</span><br><span class="line">        work(<span class="number">1</span>,s,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(!g)f=<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!f)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!deg[i])</span><br><span class="line">            q.push(i);</span><br><span class="line">    &#125;<span class="keyword">int</span> Tim=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> x=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">if</span>(x&lt;=n)</span><br><span class="line">            ans[x]=++Tim;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=d[x];i;i=nxt[i])&#123;</span><br><span class="line">            <span class="keyword">int</span> u=to[i];</span><br><span class="line">            <span class="keyword">if</span>(--deg[u]==<span class="number">0</span>)q.push(u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">if</span>(deg[i])&#123;</span><br><span class="line">            f=<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span>(!f)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">if</span>(!ans[i])</span><br><span class="line">            ans[i]=++Tim;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        ans2[ans[i]]=i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,ans2[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>cf比赛</tag>
      </tags>
  </entry>
  <entry>
    <title>合并回文子串</title>
    <url>/%E5%90%88%E5%B9%B6%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>经典的回文串相关的 DP 题，理解了如何用$O(n^2)$求解回文串，这题会比较简单。</p>
<span id="more"></span>
<p>对于求解最长回文串，可以用复杂度为$O(n)$的 Manacher 算法，或者回文自动机，但是此题只需要 DP 即可。<br>对于 DP 求解回文串，记 dp[i][j] 为 i 到 j 是否是回文串即可，转移很简单，当 s[i] == s[j] 时 dp[i][j] = dp[i+1][j-1] 即可<br>如果 i+1 到 j-1 是回文串，则 i 到 j 也是回文串，反之则不是。</p>
<p>此题有两个字符串，但其实 DP 只用略微修改即可<br>因为合并出的字符串中连续的一段必定是原来的分别来自两个字符串中连续的一段合并而来的（可以为空）<br>这样的话用个四维 dp 即可，记 dp[i][j][k][l] 表示第一个串 i 到 j 和第二个串 k 到 l 构成的串是否能是回文串<br>此时注意，转移有四种，转移：</p>
<script type="math/tex; mode=display">
\begin{aligned}
dp[i][j][k][l]|=dp[i+1][j-1][k][l]\;(s[i]==s[j]) \\
dp[i][j][k][l]|=dp[i+1][j][k][l-1]\;(s[i]==g[l]) \\
dp[i][j][k][l]|=dp[i][j-1][k+1][l]\;(s[j]==g[k]) \\
dp[i][j][k][l]|=dp[i][j][k+1][l-1]\;(g[k]==g[l])
\end{aligned}</script><p>若某个 dp[i][j][k][l] 为 1 ，则说明这是一个回文串，更新下答案即可。</p>
<p>参考代码如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">52</span>;</span><br><span class="line"><span class="keyword">char</span> s[N], g[N];</span><br><span class="line"><span class="keyword">int</span> dp[N][N][N][N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>, s + <span class="number">1</span>, g + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">strlen</span>(s + <span class="number">1</span>), m = <span class="built_in">strlen</span>(g + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l + i - <span class="number">1</span> &lt;= n; ++l) &#123;</span><br><span class="line">                    <span class="keyword">int</span> r = l + i - <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> L = <span class="number">1</span>; L + j - <span class="number">1</span> &lt;= m; ++L) &#123;</span><br><span class="line">                        <span class="keyword">int</span> R = L + j - <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">if</span> (i + j &lt;= <span class="number">1</span>)</span><br><span class="line">                            dp[l][r][L][R] = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            dp[l][r][L][R] = <span class="number">0</span>;</span><br><span class="line">                            <span class="keyword">if</span> (s[l] == s[r])dp[l][r][L][R] |= dp[l + <span class="number">1</span>][r - <span class="number">1</span>][L][R];</span><br><span class="line">                            <span class="keyword">if</span> (s[l] == g[R])dp[l][r][L][R] |= dp[l + <span class="number">1</span>][r][L][R - <span class="number">1</span>];</span><br><span class="line">                            <span class="keyword">if</span> (g[L] == s[r])dp[l][r][L][R] |= dp[l][r - <span class="number">1</span>][L + <span class="number">1</span>][R];</span><br><span class="line">                            <span class="keyword">if</span> (g[L] == g[R])dp[l][r][L][R] |= dp[l][r][L + <span class="number">1</span>][R - <span class="number">1</span>];</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (dp[l][r][L][R])ans = max(ans, i + j);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>城市网络</title>
    <url>/%E5%9F%8E%E5%B8%82%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>有一个树状的城市网络（即 n 个城市由 n-1 条道路连接的连通图），首都为 1 号城市，每个城市售卖价值为 $a_i$ 的珠宝。<br/><br>你是一个珠宝商，现在安排有 q 次行程，每次行程为从 u 号城市前往 v 号城市（走最短路径），保证 v 在 u 前往首都的最短路径上。 在每次行程开始时，你手上有价值为 c 的珠宝（每次行程可能不同），并且每经过一个城市时（包括 u 和 v ），假如那个城市中售卖的珠宝比你现在手上的每一种珠宝都要优秀（价值更高，即严格大于），那么你就会选择购入。<br>现在你想要对每一次行程，求出会进行多少次购买事件。</p>
<span id="more"></span>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>树上倍增题<br>设 dp[x][i] 表示从 x 走向根节点时第 $2^i$ 次购买时的点<br/><br>不难得出 $dp[x][i]=dp[dp[x][i-1]][i-1] (i&gt;=1)$<br/><br>然后重点是求 dp[x][0] ，其实也挺简单，从 fa[x] 跳到最上面的一个点 y 且 val[y] &lt; = val[x] 即可，这样 dp[y][0] 即 dp[x][0] （此时 dp[y][0] 即 fa[y] ）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,q;</span><br><span class="line"><span class="keyword">int</span> d[N],nxt[N&lt;&lt;<span class="number">1</span>],to[N&lt;&lt;<span class="number">1</span>],tot;</span><br><span class="line"><span class="keyword">int</span> dp[N][<span class="number">20</span>],dep[N],val[N];</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> u,v,c,x;</span><br><span class="line">&#125;a[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    to[++tot]=b;</span><br><span class="line">    nxt[tot]=d[a];</span><br><span class="line">    d[a]=tot;</span><br><span class="line">&#125;<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    dep[x]=dep[fa]+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(val[fa]&gt;val[x])dp[x][<span class="number">0</span>]=fa;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> p=fa;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">19</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[p][i]&amp;&amp;val[dp[p][i]]&lt;=val[x])p=dp[p][i];</span><br><span class="line">        &#125;</span><br><span class="line">        dp[x][<span class="number">0</span>]=dp[p][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">19</span>;++i)</span><br><span class="line">        dp[x][i]=dp[dp[x][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = d[x]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> u=to[i];</span><br><span class="line">        <span class="keyword">if</span>(u==fa)<span class="keyword">continue</span>;</span><br><span class="line">        dfs(u,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;q);</span><br><span class="line">    <span class="keyword">int</span> u,v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;val[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);</span><br><span class="line">        ins(u,v),ins(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a[i].u,&amp;a[i].v,&amp;a[i].c);</span><br><span class="line">        ins(a[i].u,a[i].x=n+i);</span><br><span class="line">        ins(a[i].x,a[i].u);</span><br><span class="line">        val[a[i].x]=a[i].c;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>,x=a[i].x;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">19</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dep[dp[x][j]] &gt;= dep[a[i].v]) &#123;</span><br><span class="line">                ans+=<span class="number">1</span>&lt;&lt;j;</span><br><span class="line">                x=dp[x][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>牛客每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>寒假学习计划</title>
    <url>/%E5%AF%92%E5%81%87%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>知识点：<br><span id="more"></span><br>1.线性基<br>2.最小斯坦纳树<br>3.bitset<br>4.点分治<br>5.边分治<br>6.莫比乌斯反演<br>7.杜教筛<br>8.DP<br>9.SAM<br>10.序列自动机<br>11.splay<br>12.替罪羊树<br>13.LCT<br>14.treap及可持久化<br>15.主席树<br>16.线段树合并<br>17.启发式合并<br>18.可撤销并查集<br>19.整体二分<br>20.2-SAT<br>21.欧拉回路<br>22.哈密顿回路<br>23.哈夫曼树<br>24.最大流最小割<br>25.次小生成树<br>26.k小生成树<br>27.差分约束<br>28.中国剩余定理<br>29.欧拉函数<br>30.欧几里得定理<br>31.扩展欧几里得<br>32.容斥原理<br>33.Ploya<br>34.Burnside<br>35.斯特林数<br>36.Min-25筛<br>37.凸包<br>38.半平面交<br>39.FFT<br>40.NTT<br>未完待续…</p>
]]></content>
  </entry>
  <entry>
    <title>大数进制转换</title>
    <url>/%E5%A4%A7%E6%95%B0%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>对于一个大数可以使用分治法+FFT做到$O(nlog^2n)$进行任意进制转换。</p>
<p>假设从$a$进制转换到$b$进制，设$x_i$表示待转换的数的第$i$位，共$n$位，设$s_i$表示转换后的数的第$i$位，共$m$位：  </p>
<p>则有$\sum_{i=0}^{n-1}x_i<em>a^i=\sum_{i=0}^{m-1}s_i</em>b^i$</p>
<p>不妨令$mid=\lfloor\frac{n}{2}\rfloor$，则有</p>
<script type="math/tex; mode=display">
\sum_{i=0}^{mid-1}x_i*a^i+\sum_{i=mid}^{n-1}x_i*a^i=\sum_{i=0}^{m-1}s_i*b^i  \\
\sum_{i=0}^{mid-1}x_i*a^i+a^{mid}*\sum_{i=mid}^{n-1}x_i*a^{i-mid}=\sum_{i=0}^{m-1}s_i*b^i</script><p>则只需要分别对于$[0,mid)$位和$[mid,n)$求出转换后的数$L,R$，然后在$b$进制下令$s=L+R*a^{mid}$即可。</p>
<p>对于长度小于某个阈值时应暴力计算。</p>
<p>复杂度分析：  </p>
<p>$f(n)=2<em>f(\frac{n}{2})+2</em>g(\frac{n}{2})$（其中$g(n)$为$n$位乘$n$位的时间复杂度，使用$FFT$时有$g(n)=nlogn$）</p>
<p>其中$2g(\frac{n}{2})$是求$a^{mid}和R*a^{mid}$的时间复杂度，对于$a^{mid}$其实可以预处理出来。</p>
<p>得出$f(n)=nlog^2n$</p>
<p>实际测得常数较小</p>
<p>在此附上已经封装好的大数类，包含10进制大数，2进制大数，二进制和十进制转化等。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dqci16L0FsZ29yaXRobUFuZERhdGFTdHJ1Y3R1cmU=">https://github.com/wjr-z/AlgorithmAndDataStructure<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <tags>
        <tag>大整数</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入b站视频</title>
    <url>/%E5%B5%8C%E5%85%A5b%E7%AB%99%E8%A7%86%E9%A2%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>嵌入b站视频的方法<br><span id="more"></span><br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div style=<span class="string">&quot;position: relative; padding: 0% 0%;&quot;</span>&gt;</span><br><span class="line">&lt;iframe style=<span class="string">&quot;position: absolute; width: 100%; height: 100%; left: 0; top: 0;&quot;</span> src=<span class="string">&quot;//player.bilibili.com/player.html?aid=52516662&amp;bvid=BV1o4411E7xW&amp;cid=91907659&amp;page=1&amp;as_wide=1&amp;high_quality=1&amp;danmaku=1&quot;</span> scrolling=<span class="string">&quot;no&quot;</span> border=<span class="string">&quot;0&quot;</span> frameborder=<span class="string">&quot;no&quot;</span> framespacing=<span class="string">&quot;0&quot;</span> allowfullscreen=<span class="string">&quot;true&quot;</span>&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><br>效果如下</p>
<div style="position: relative; padding: 0% 0%;">
<iframe style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;" src="//player.bilibili.com/player.html?aid=52516662&bvid=BV1o4411E7xW&cid=91907659&page=1&as_wide=1&high_quality=1&danmaku=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"></iframe>
</div>

]]></content>
  </entry>
  <entry>
    <title>常用markdown介绍</title>
    <url>/%E5%B8%B8%E7%94%A8markdown%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p> 效果如下：</p>
<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><h2 id="插入代码"><a href="#插入代码" class="headerlink" title="插入代码"></a>插入代码</h2><p><img data-src="https://tu.sunpma.com/imgs/2021/01/36de521bd3107ef2.png" align='left'><br><br/><br><br/><br><br/><br>效果如下<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此处以C++为例，```后面是代码语言。</p>
<h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">**我是sb** （粗体）</span><br><span class="line">*tql* （斜体）</span><br><span class="line">~~啊这~~ （划线）</span><br></pre></td></tr></table></figure>
<p>效果如下：<br><strong>我是sb</strong> （粗体）<br><em>tql</em> （斜体）<br><del>啊这</del> （划线）</p>
<h2 id="插入链接"><a href="#插入链接" class="headerlink" title="插入链接"></a>插入链接</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[链接文本](链接地址)</span><br></pre></td></tr></table></figure>
<p>效果如下：<br><a href="https://wjr-z.com/">myblog</a></p>
<h2 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![图片文字描述](图片地址)</span><br></pre></td></tr></table></figure>
<p>效果如下：<br><img data-src="https://tu.sunpma.com/imgs/2021/01/dce480b807f1e9fe.webp" alt="我和德狗贴贴"></p>
<p>若觉得图片位置或者大小不太适合，可以尝试用html语言设置高度和宽以及位置等。</p>
<h2 id="插入引用"><a href="#插入引用" class="headerlink" title="插入引用"></a>插入引用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; 啊这</span><br></pre></td></tr></table></figure>
<blockquote>
<p>啊这</p>
</blockquote>
<h2 id="插入表格"><a href="#插入表格" class="headerlink" title="插入表格"></a>插入表格</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">|name|age|address|</span><br><span class="line">|---|:----:|---:|</span><br><span class="line">|zhang|18|beijing|</span><br><span class="line">|wang|22|shandong|</span><br></pre></td></tr></table></figure>
<blockquote>
<p>居中 <code>:------</code><br>局左 <code>-------</code> 或 <code>:-----:</code><br>居右 <code>------:</code></p>
</blockquote>
<p>效果如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>name</th>
<th style="text-align:center">age</th>
<th style="text-align:right">address</th>
</tr>
</thead>
<tbody>
<tr>
<td>zhang</td>
<td style="text-align:center">18</td>
<td style="text-align:right">beijing</td>
</tr>
<tr>
<td>wang</td>
<td style="text-align:center">22</td>
<td style="text-align:right">shandong</td>
</tr>
</tbody>
</table>
</div>
<h2 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h2><p>两个空格一个回车</p>
<h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LCT</span><br><span class="line"></span><br><span class="line">--- </span><br><span class="line">splay</span><br></pre></td></tr></table></figure>
<p>效果如下：<br>LCT</p>
<hr>
<p>splay</p>
<p>(yysy这个分割线好丑，以后改一下样式)</p>
<h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- a</span><br><span class="line">- b</span><br><span class="line">- c</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<ul>
<li>a</li>
<li>b</li>
<li>c</li>
</ul>
<blockquote>
<p>参考文章  <span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vemhhbmdqaW56aGUvcC84MjUyODkzLmh0bWw=">常用Markdown语法归纳<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>失衡天平</title>
    <url>/%E5%A4%B1%E8%A1%A1%E5%A4%A9%E5%B9%B3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>给了 n 个武器，每个武器有一个重量 a ，并且给了一个天平，现在你每次都可以从这些武器中选择若干个武器并放到天平上，但是只有天平两边重量相差 m 以内你才能拿走，并且拿走的武器不能再放到天平上，问你最多能拿走的武器总重量。</p>
<span id="more"></span>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>实际上如果答案最优，则拿若干次一定不优于拿一次。<br>假设拿的第一次左右两边相差 x ，第二次左右两边相差 y ，则一定有 $|x-y|\leq m$（第二次重的一边放到第一次轻的一边），所以其实无论拿多少次都可以变成只拿一次。<br/><br>这样就是个简单 dp 了。<br>设 $dp[i][j]$ 表示前 i 个武器天平重量相差 j 能拿走的最大武器重量<br/><br>转移：</p>
<script type="math/tex; mode=display">
dp[i][j]=max(dp[i-1][j],dp[i-1][j+a[i]],dp[i-1][|j-a[i]|])</script><p>参考代码如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">105</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">2</span>][N*N],a[N];<span class="comment">//dp[i][j]表示前i个左右两边相差j的最大重量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> now=<span class="number">0</span>,las=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0xf3</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        now^=<span class="number">1</span>,las^=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">10000</span>;++j)&#123;</span><br><span class="line">            <span class="keyword">int</span> x;</span><br><span class="line">            x=<span class="built_in">abs</span>(j-a[i]);</span><br><span class="line">            dp[now][j]=dp[las][j];</span><br><span class="line">            dp[now][j]=max(dp[now][j],dp[las][x]+a[i]);</span><br><span class="line">            x=j+a[i];</span><br><span class="line">            <span class="keyword">if</span>(x&lt;=<span class="number">10000</span>)</span><br><span class="line">                dp[now][j]=max(dp[now][j],dp[las][x]+a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=m;++i)</span><br><span class="line">        ans=max(ans,dp[now][i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>用了下滚动数组优化。</p>
]]></content>
      <tags>
        <tag>DP</tag>
        <tag>牛客每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>曼哈顿距离转切比雪夫距离</title>
    <url>/%E6%9B%BC%E5%93%88%E9%A1%BF%E8%B7%9D%E7%A6%BB%E8%BD%AC%E5%88%87%E6%AF%94%E9%9B%AA%E5%A4%AB%E8%B7%9D%E7%A6%BB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>设第$i$个点坐标为$(x_i,y_i)$</p>
<h3 id="曼哈顿距离："><a href="#曼哈顿距离：" class="headerlink" title="曼哈顿距离："></a>曼哈顿距离：</h3><script type="math/tex; mode=display">
|x_i-x_j|+|y_i-y_j|</script><h3 id="切比雪夫距离："><a href="#切比雪夫距离：" class="headerlink" title="切比雪夫距离："></a>切比雪夫距离：</h3><script type="math/tex; mode=display">
max(|x_i-x_j|,|y_i-y_j|)</script><p>曼哈顿距离可以和切比雪夫距离互相转化！  </p>
<p>将每个点从$(x_i,y_i)$变为$(x_i+y_i,x_i-y_i)$即可将求曼哈顿距离转为求切比雪夫距离。  </p>
<span id="more"></span>
<p>曼哈顿距离又可以表示为  </p>
<p>$max(\pm(x_i-x_j)\pm(y_i-y_j))$</p>
<p>转化后的切比雪夫距离可以表示为  </p>
<p>$max(|x_i-x_j|\pm|y_i-y_j|)$</p>
<p>两者实际上是等价的。  </p>
<h3 id="实际应用："><a href="#实际应用：" class="headerlink" title="实际应用："></a>实际应用：</h3><p>求与某一个点曼哈顿距离小于等于C的点数，如果问题可以离线，则可以转换为求切比雪夫距离小于等于C的点数，此时需要求一个矩形内的点数，有很多方式都可以实现。</p>
<p>例题：<span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDI5MDY=">P2906 [USACO08OPEN]Cow Neighborhoods G - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)<i class="fa fa-external-link-alt"></i></span></p>
<p>此题只用将x排序后，维护y即可。</p>
]]></content>
  </entry>
  <entry>
    <title>已学知识点汇总</title>
    <url>/%E5%B7%B2%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="已学知识点："><a href="#已学知识点：" class="headerlink" title="已学知识点："></a>已学知识点：</h2><h3 id="本博客内写过讲解的："><a href="#本博客内写过讲解的：" class="headerlink" title="本博客内写过讲解的："></a>本博客内写过讲解的：</h3><span id="more"></span>
<ul>
<li><a href="https://wjr-z.com/Linear%20basis/">线性基</a></li>
<li><a href="https://wjr-z.com/Linear%20sieve/">线性筛</a></li>
<li><a href="https://wjr-z.com/KMP/">KMP</a></li>
<li><a href="https://wjr-z.com/SAM">SAM</a></li>
<li><a href="http://wjr-z.com/FFT">FFT</a></li>
<li><a href="https://wjr-z.com/Minimum%20Steiner%20tree/">最小斯坦纳树</a></li>
<li><a href="https://wjr-z.com/莫比乌斯反演学习/">莫比乌斯反演</a><h3 id="本博客内尚未写过讲解的（待填坑）："><a href="#本博客内尚未写过讲解的（待填坑）：" class="headerlink" title="本博客内尚未写过讲解的（待填坑）："></a>本博客内尚未写过讲解的（待填坑）：</h3></li>
<li><a href="https://wjr-z.com">树状数组</a></li>
<li><a href="https://wjr-z.com">线段树</a></li>
<li><a href="https://wjr-z.com">树链剖分</a></li>
<li><a href="https://wjr-z.com">splay</a></li>
<li><a href="https://wjr-z.com">DP</a></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93anItei9jb20=">单调队列<i class="fa fa-external-link-alt"></i></span></li>
<li><a href="https://wjr-z.com">二分</a></li>
<li><a href="https://wjr-z.com">点分治</a></li>
<li><a href="https://wjr-z.com">树上倍增</a></li>
<li><a href="https://wjr-z.com">RMQ</a></li>
<li><a href="https://wjr-z.com">LCT</a></li>
</ul>
<h2 id="准备学习的知识点："><a href="#准备学习的知识点：" class="headerlink" title="准备学习的知识点："></a>准备学习的知识点：</h2><ul>
<li>KD-tree</li>
<li></li>
</ul>
]]></content>
      <tags>
        <tag>汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>关于cin和cout</title>
    <url>/%E5%85%B3%E4%BA%8Ecin%E5%92%8Ccout/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在我ICPC 昆明赛区因为使用 cin 和 cout TLE一发后，我改成了scanf和printf，从 2s 的TLE变成了 267 ms …</p>
<p>然后我在赛后进行了一些测试</p>
<span id="more"></span>
<p>cin和cout是挺慢的，但我真没想到能差这么多，以至于比我的$O(nlogn)$算法还慢上几倍。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL2NvbnRlc3QvMTI1NDgvTA==">测试题目<i class="fa fa-external-link-alt"></i></span></p>
<p>效率测试：</p>
<ol>
<li><p>scanf和printf</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL2NvbnRlc3Qvdmlldy1zdWJtaXNzaW9uP3N1Ym1pc3Npb25JZD00NzM4MzU5NQ==">测试代码<i class="fa fa-external-link-alt"></i></span></p>
<p>用时：267ms</p>
</li>
<li><p>cin和cout（不关闭流同步以及使用endl）</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL2NvbnRlc3Qvdmlldy1zdWJtaXNzaW9uP3N1Ym1pc3Npb25JZD00NzM4MzY2NQ==">测试代码<i class="fa fa-external-link-alt"></i></span></p>
<p>用时：2001 ms（TLE)</p>
</li>
<li><p>cin和cout（关闭流同步以及使用endl）</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL2NvbnRlc3Qvdmlldy1zdWJtaXNzaW9uP3N1Ym1pc3Npb25JZD00NzM4MzY5MA==">测试代码<i class="fa fa-external-link-alt"></i></span></p>
<p>用时：2001ms（TLE）</p>
</li>
<li><p>cin和cout(不关闭流同步和不使用endl)</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL2NvbnRlc3Qvdmlldy1zdWJtaXNzaW9uP3N1Ym1pc3Npb25JZD00NzM4MzY2Nw==">测试代码<i class="fa fa-external-link-alt"></i></span></p>
<p>用时：1425ms</p>
</li>
<li><p>cin和cout（关闭流同步和不使用endl）</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL2NvbnRlc3Qvdmlldy1zdWJtaXNzaW9uP3N1Ym1pc3Npb25JZD00NzM4MzY5NA==">测试代码<i class="fa fa-external-link-alt"></i></span></p>
<p>用时：218ms</p>
</li>
</ol>
<p>关闭流同步会使得cin和cout速度变快，这我早就知道了</p>
<p>从 4 和 5 的对比就能看得出来，还是快了很多的</p>
<p>并且可以发现<strong>频繁使用endl刷新缓冲区</strong>会导致速度严重降低，即便关闭了流同步也会导致效率相差很大</p>
<p>题外话：</p>
<p>我第一次TLE后，我是真的不太相信就是cin 和 cout 会导致效率低那么多…</p>
<p>然后犹豫了几分钟后才抱着试试的心态交了一发，结果过了…</p>
]]></content>
  </entry>
  <entry>
    <title>快速查找文件代码</title>
    <url>/%E5%BF%AB%E9%80%9F%E6%9F%A5%E6%89%BE%E6%96%87%E4%BB%B6%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="Update-at-2021-3-28"><a href="#Update-at-2021-3-28" class="headerlink" title="Update at 2021.3.28"></a>Update at 2021.3.28</h3><h4 id="使用了Qt进行了可视化"><a href="#使用了Qt进行了可视化" class="headerlink" title="使用了Qt进行了可视化"></a>使用了Qt进行了可视化</h4><p>现在界面是这样的</p>
<span id="more"></span>
<p><img data-src="https://tu.sunpma.com/imgs/2021/03/ce21e6de21837bd3.png" alt=""></p>
<p>对于搜索速度以及磁盘利用率进行了进一步优化</p>
<p>并且新增一些小功能</p>
<ul>
<li><p>每一页显示100个结果，并且可以通过点击“文件内容”，“路径”，“大小”进行递增、递减排序-</p>
</li>
<li><p>支持大小写敏感</p>
</li>
</ul>
<p>暂不支持正则表达式，并且没有建立索引。</p>
<p>对于查找文件内容的速度我还是较为自信的。</p>
<p>搜索1G以内文件的某个文件内容，10s内基本是稳的吧。</p>
<p>不过因为多线程可能导致任务分配不均，所以可能导致效率在最坏情况变为最优的两倍。</p>
<p>尝试过解决，解决方案严格的均分任务，但是效果不佳，于是暂时放弃该方案。</p>
<p>可以来提提建议！</p>
<p>需要源码或者可运行程序的评论留言。</p>
]]></content>
  </entry>
  <entry>
    <title>明日方舟抽卡概率计算</title>
    <url>/%E6%98%8E%E6%97%A5%E6%96%B9%E8%88%9F%E6%8A%BD%E5%8D%A1%E6%A6%82%E7%8E%87%E8%AE%A1%E7%AE%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>明日方舟抽卡概率计算。<br><span id="more"></span><br>我们定义$dp[i][j]$表示抽卡到第$j$次时出了第$i$次货的概率，则有</p>
<script type="math/tex; mode=display">
dp[i][j]=\sum_{k=i-1}^{j-1}{dp[i-1][k]*dp[1][j-k]}(i>1)</script><p>预处理$dp[1][i]$即可。</p>
<p>上代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1010</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">double</span> dp[<span class="number">12</span>][N],s[N],f[N];</span><br><span class="line"><span class="comment">//dp[i][j]表示抽卡第j次时第i次出货的概率</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">double</span> p=<span class="number">0.02</span>,q=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;<span class="number">50</span>)</span><br><span class="line">            p+=<span class="number">0.02</span>;</span><br><span class="line">        dp[<span class="number">1</span>][i]=q*p;</span><br><span class="line">        q*=(<span class="number">1</span>-p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;第%d次时第一次出货的概率为%.10Lf\n&quot;</span>,i,dp[<span class="number">1</span>][i]);</span><br><span class="line">    <span class="comment">//这里均指第一次出货。</span></span><br><span class="line">    <span class="keyword">double</span> E_dp=<span class="number">0</span>;<span class="comment">//期望出货所需抽卡次数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;++i)</span><br><span class="line">        E_dp+=i*dp[<span class="number">1</span>][i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;期望出货一次所需抽卡次数:%.10Lf\n&quot;</span>,E_dp);</span><br><span class="line">    f[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;++i)&#123;</span><br><span class="line">        s[i]=s[i<span class="number">-1</span>]+dp[<span class="number">1</span>][i];</span><br><span class="line">        f[i]=<span class="number">1</span>-s[i];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;出货一次&lt;=%d抽卡次数的概率%.10Lf\n&quot;</span>,i,s[i]);<span class="comment">//即dp[1][1]+...+dp[1][i]</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">10</span>;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">1000</span>;++j)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=i<span class="number">-1</span>;k&lt;j;++k)</span><br><span class="line">                dp[i][j]+=dp[i<span class="number">-1</span>][k]*dp[<span class="number">1</span>][j-k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">double</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> X=<span class="number">700</span>,ans_id=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=X<span class="number">-100</span>;i&lt;=X;++i)&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">double</span> z_ans=dp[<span class="number">10</span>][i]*f[X-i];</span><br><span class="line">        <span class="keyword">if</span>(z_ans&gt;ans)&#123;</span><br><span class="line">            ans=z_ans;</span><br><span class="line">            ans_id=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;当第%d次出货第10次且总抽卡次数为%d时的最大概率为%.14Lf\n&quot;</span>,ans_id,X,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注：上面代码的q指的是前面均为出货的概率，p代表当前出货率。</p>
<p>接下来我们对此进行分析。<br>代码运行结果显示，期望出货抽卡次数为35次。<br>35次内出货概率约为50%，50次内出货概率约为63.5%，70次内出货概率99.84%，88次内<strong>不出货</strong>概率约为$ 2*10^{-8}\\%$</p>
<p>这是什么概念呢？</p>
<p>十连中出五个六星的概率是$0.02^{5}*0.98 ^{5} * C(10,5)$约为$7*10^{-5} \\% $</p>
<p>好家伙，你88次还不出货的概率比十连中出五星概率小几千倍。<br>接下来考虑平均出货。<br>有的人说自己80级平均70次出一个六星？<br>我们假设他抽了700次10个六星吧，设这个概率最大为$ans$，则有</p>
<script type="math/tex; mode=display">
ans=max\{dp[10][i]*f[700-i]\}(600\leq i\leq 700,其中f[i]表示i发不出的概率)</script><p>我们可以得到当第640次出第10次且后60次不出货的概率是最大的，即700次平均70次1六星的最大概率，其约为$9.15*10^{-10}\\%$<br><br>当然，这只是700次出了10次的概率，如果是出了&lt;=10次的概率求到的仍约为$9.15*10^{-10}\\%$，因为&lt;=9次的远小于=10次的<br><br>这个概率极其的小，比十连出五个六星概率小的多得多，然而我们总是能看到说自己什么90发出货，什么高等级平均70次一个之类的，却很少见到有十连四个，五个六星的，这原因相信不说也应该懂了吧…<br><br>且根据期望的相关性质，出货k次的期望抽卡次数为35*k。<br>如有错误，请留言指出！</p>
]]></content>
      <tags>
        <tag>明日方舟</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客挑战赛47</title>
    <url>/%E7%89%9B%E5%AE%A2%E6%8C%91%E6%88%98%E8%B5%9B47/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><span class="exturl" data-url="aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL2NvbnRlc3QvMTA3NDM=">比赛链接<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cubm93Y29kZXIuY29tL2Rpc2N1c3MvNTg3MjgzP3R5cGU9MTAx">官方题解<i class="fa fa-external-link-alt"></i></span></p>
<span id="more"></span>
<h2 id="A-一道GCD问题"><a href="#A-一道GCD问题" class="headerlink" title="A.一道GCD问题"></a>A.一道GCD问题</h2><p><span class="exturl" data-url="aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL2NvbnRlc3QvMTA3NDMvQQ==">题目链接<i class="fa fa-external-link-alt"></i></span></p>
<p>题目描述：<br>给定一个数组a，求每个数加上k后能得到的最大gcd，并求出最小的非负整数k。</p>
<p>题解：<br>假设最大的gcd值为GCD，则<br>a[1]+k=GCD*b[1]<br>a[2]+k=GCD*b[2]<br>a[3]+k=GCD*b[3]<br>…<br>做个差分，可以发现与k无关了，GCD为查分数组的gcd，然后就做出来了。</p>
<details>
    <summary>参考代码</summary>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> !b?a:gcd(b,a%b);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">int</span> GCD=<span class="built_in">abs</span>(a[<span class="number">2</span>]-a[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        GCD=gcd(GCD,<span class="built_in">abs</span>(a[i]-a[i<span class="number">-1</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">if</span>(a[<span class="number">1</span>]%GCD==<span class="number">0</span>)k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> k=GCD-a[<span class="number">1</span>]%GCD;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,GCD,k);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<h2 id="B-又一道-GCD-问题"><a href="#B-又一道-GCD-问题" class="headerlink" title="B.又一道 GCD 问题"></a>B.又一道 GCD 问题</h2><p><span class="exturl" data-url="aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL2NvbnRlc3QvMTA3NDMvQg==">题目链接<i class="fa fa-external-link-alt"></i></span></p>
<p>题目描述：略。</p>
<p>题解：<br>经典套路题。将比较难直接求的问题转化为求可行性。<br>假设i+1个gcd为x，则必定有大于等于i+1个a是x的倍数。<br>因为求最大的gcd，则求出一个ans，有大于等于i+1个是ans的倍数，且ans最大化即可。</p>
<p>我们令s[i]表示可以整除i的个数，令ans[i]表示s[x]=i的所有x的最大值。<br>这样ans[i]即表示恰好有i个是ans[i]的倍数，且ans[i]最大化。</p>
<p>最后因为需要求的是大于等于而非等于，从后往前ans[i]=max(ans[i],ans[i+1])即可。</p>
<details>
    <summary>参考代码</summary>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="keyword">int</span> s[N],ans[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">int</span> x,m=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x),++a[x],m=max(m,x);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=m;j+=i)</span><br><span class="line">            s[i]+=a[j];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">        ans[s[i]]=max(ans[s[i]],i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;--i)ans[i]=max(ans[i],ans[i+<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,ans[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<h2 id="C-条件"><a href="#C-条件" class="headerlink" title="C.条件"></a>C.条件</h2><p><span class="exturl" data-url="aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL2NvbnRlc3QvMTA3NDMvQw==">题目链接<i class="fa fa-external-link-alt"></i></span></p>
<p>题目描述：略。</p>
<p>题解：<br>给定若干有向边，判断x是否能到达y，并且询问次数q大，n较大，一般是用floyd进行预处理。<br>但是floyd复杂度是$O(n^3)$，显然是过不了的。<br>因为此题只是判断是否能否到达，并否最短路什么的，因此可以用bitset优化，复杂度$O(n^3/w)$。(w为32/64)<br>将两种情况的边用两个bitset存起来，一个是所有一定存在的边，一个是一定和可能存在的边，其他就和普通floyd差不多了。</p>
<details>
    <summary>参考代码</summary>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> n,m1,m2,q;</span><br><span class="line"><span class="built_in">bitset</span>&lt;N&gt;a[N],b[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;n,&amp;m1,&amp;m2,&amp;q);</span><br><span class="line">    <span class="comment">//a[i]表示所有一定存在的边可以到达的点</span></span><br><span class="line">    <span class="comment">//b[i]表示所有可能和一定存在的边可以到达的点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;++j)&#123;</span><br><span class="line">            b[i][j]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i==j)a[i][j]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m1;++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        a[x][y]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!a[j][i])<span class="keyword">continue</span>;</span><br><span class="line">            a[j]|=a[i];</span><br><span class="line">            <span class="comment">//如果j可以到达i，则j可以到达的点包含i可以到达的点</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m2;++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        b[x][y]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!b[j][i])<span class="keyword">continue</span>;</span><br><span class="line">            b[j]|=b[i];</span><br><span class="line">            <span class="comment">//如果j可以到达i，则j可以到达的点包含i可以到达的点</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        <span class="keyword">if</span>(a[x][y])<span class="built_in">printf</span>(<span class="string">&quot;Yes &quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;No &quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(b[x][y])<span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="D-Lots-of-Edges"><a href="#D-Lots-of-Edges" class="headerlink" title="D.Lots of Edges"></a>D.Lots of Edges</h2><p><span class="exturl" data-url="aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL2NvbnRlc3QvMTA3NDMvRA==">题目链接<i class="fa fa-external-link-alt"></i></span></p>
<p>题目描述：<br>有n个点，每个点有点权<script type="math/tex">a_{1}\sim a_{n}</script>，若 $ a_{i} \&amp; a_{j}=0$（指二进制按位与），则在i,j间连一条边权为1的边。<br>求 S 到$1\sim n$的最短路。</p>
<p>输入描述：<br>第一行两个正整数 n,S 。<br>接下来一行 n 个非负整数，第 i 个为 $a_i$ 。<br/><br>对于所有数据，$1\le S\le n\le 10^5$，$0\le a_i\le 131071$。</p>
<p>输出描述:<br>一行 n 个整数，第 i 个为 S 到 i 的最短路长度。不能到达输出 -1。</p>
<p>题解：<br>1.<span class="exturl" data-url="aHR0cHM6Ly93d3cubm93Y29kZXIuY29tL2Rpc2N1c3MvNTg3MjgzP3R5cGU9MTAx">常规题解<i class="fa fa-external-link-alt"></i></span><br>2.优化建图题解。<br>常规做法复杂度很高，不过因为此题可能不想考优化建图，因此并没有卡复杂度，常规做法复杂度为$O(n^{1.587})$。<br/><br>此题可以优化建图，对于值x只向其二进制表示中少某一位1的值y建边权为0的单向边即可，例如101(2)-&gt;001(2),101(2)-&gt;100(2)，但是不向000(2)建边。<br>然后将所有存在的值x（即a中有的）向x^W($W=2^k-1$，且W大于等于a的最大值)建边权为1的单向边。<br/><br>建边后跑dijkstra，起点需要从a[S]^W开始，且此点初始距离设置为1，具体细节可以自行思考。<br>该方法复杂度为$O(nlogn)$</p>
<details>
    <summary>参考代码</summary>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> W=<span class="number">131071</span>,N=W+<span class="number">100</span>,M=<span class="number">2e6</span>,inf=<span class="number">1e6</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> d[N],nxt[M],to[M],val[M],tot;</span><br><span class="line"><span class="keyword">int</span> dis[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id,dis;</span><br><span class="line">    node (<span class="keyword">int</span> a=<span class="number">0</span>,<span class="keyword">int</span> b=<span class="number">0</span>)&#123;</span><br><span class="line">        id=a;</span><br><span class="line">        dis=b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> node&amp;other)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dis&gt;other.dis;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">priority_queue</span>&lt;node&gt;q;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    to[++tot]=b;</span><br><span class="line">    nxt[tot]=d[a];</span><br><span class="line">    d[a]=tot;</span><br><span class="line">    val[tot]=v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,S;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dis));</span><br><span class="line">    <span class="keyword">int</span> start=a[S]^W;</span><br><span class="line">    dis[start]=<span class="number">1</span>;</span><br><span class="line">    q.push(node(start,<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        node tmp=q.top();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">if</span>(vis[tmp.id])<span class="keyword">continue</span>;</span><br><span class="line">        vis[tmp.id]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=d[tmp.id];i;i=nxt[i])&#123;</span><br><span class="line">            <span class="keyword">int</span> u=to[i];</span><br><span class="line">            <span class="keyword">if</span>(dis[u]&gt;tmp.dis+val[i])&#123;</span><br><span class="line">                dis[u]=tmp.dis+val[i];</span><br><span class="line">                q.push(node(u,dis[u]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lb(x) x&amp;-x</span></span><br><span class="line"><span class="keyword">bool</span> f[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=W;++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> p,q;</span><br><span class="line">        p=i;</span><br><span class="line">        <span class="keyword">while</span>(p)&#123;</span><br><span class="line">            q=lb(p);</span><br><span class="line">            ins(i,i^q,<span class="number">0</span>);</span><br><span class="line">            p-=q;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=W;++i)</span><br><span class="line">        <span class="keyword">if</span>(f[i])ins(i,i^W,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;S);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]),f[a[i]]=<span class="number">1</span>;</span><br><span class="line">    build();</span><br><span class="line">    dijkstra();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==S)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;0 &quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dis[a[i]]&lt;=inf)<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,dis[a[i]]);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;-1 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<h2 id="E-路径"><a href="#E-路径" class="headerlink" title="E. 路径"></a>E. 路径</h2><p><span class="exturl" data-url="aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL2NvbnRlc3QvMTA3NDMvRQ==">题目链接<i class="fa fa-external-link-alt"></i></span><br>这题比较有趣（<del>指码量</del>），我单独写了一篇题解<br><a href="">题解</a></p>
]]></content>
      <tags>
        <tag>牛客比赛</tag>
        <tag>bitset</tag>
        <tag>图论</tag>
        <tag>优化建图</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客挑战赛46C-排列</title>
    <url>/%E7%89%9B%E5%AE%A2%E6%8C%91%E6%88%98%E8%B5%9B46C-%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><span class="exturl" data-url="aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL2NvbnRlc3QvOTUxMC9D">题目链接<i class="fa fa-external-link-alt"></i></span></p>
<span id="more"></span>
<p>题目描述：<br>有个1$\sim$n的随机排列的数组，且其含k个超级逆序对，问你能猜对该数组的概率是多少。</p>
<p>数据范围：<br>$n,k\leq 500$</p>
<p>题解：<br>一道DP题，不算难。<br>考虑设$dp[i][j][p]$为$1\sim i$，且i在第p位，有j个超级逆序对的方案数。<br>则若加入i，除了i-1，其余的只要在i后均能形成超级逆序对，且不存在在i前与i形成超级逆序对的。<br>考虑将i插入到$1\sim i-1$的不同位置，并且讨论和i-1的先后顺序即可。</p>
<ul>
<li>如果i-1在p后，则方案数为$\sum_{l=p}^{l=i-1}{dp[i-1][j-i+p+1][l]}$</li>
<li>如果i-1在p前，则方案数为$\sum_{l=1}^{l=p-1}{dp[i-1][j-i+p][l]}$</li>
</ul>
<p>即$dp[i][j][p]=\sum_{l=p}^{l=i-1}{dp[i-1][j-i+p+1][l]}+\sum_{l=1}^{l=p-1}{dp[i-1][j-i+p][l]}$<br/><br>下面上代码</p>
<details>
    <summary>参考代码</summary>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">505</span>,mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">2</span>][N][N],s[<span class="number">2</span>][N][N];</span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> a+b&gt;=mod?a+b-mod:a+b;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> a&lt;b?a-b+mod:a-b;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> a*<span class="number">1ll</span>*b%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)s=mul(s,a);</span><br><span class="line">        a=mul(a,a);</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    s[<span class="number">0</span>][<span class="number">0</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> now=<span class="number">0</span>,las=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        swap(now,las);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=k;++j)&#123;</span><br><span class="line">             <span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">1</span>;p&lt;=i;++p)&#123;</span><br><span class="line">                 dp[now][j][p]=<span class="number">0</span>;</span><br><span class="line">                 <span class="keyword">if</span>(j-i+p+<span class="number">1</span>&gt;=<span class="number">0</span>)dp[now][j][p]=del(s[las][j-i+p+<span class="number">1</span>][i<span class="number">-1</span>],s[las][j-i+p+<span class="number">1</span>][p<span class="number">-1</span>]);</span><br><span class="line">                 <span class="keyword">if</span>(j-i+p&gt;=<span class="number">0</span>)dp[now][j][p]=add(dp[now][j][p],s[las][j-i+p][p<span class="number">-1</span>]);</span><br><span class="line">                 s[now][j][p]=add(s[now][j][p<span class="number">-1</span>],dp[now][j][p]);</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)ans=add(ans,dp[now][k][i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,qpow(ans,mod<span class="number">-2</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

]]></content>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客挑战赛47E.路径</title>
    <url>/%E7%89%9B%E5%AE%A2%E6%8C%91%E6%88%98%E8%B5%9B47E-%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一棵树，求所有经过点数大于等于2的无向路径中长度第k小的。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL2NvbnRlc3QvMTA3NDMvRQ==">题目链接<i class="fa fa-external-link-alt"></i></span></p>
<span id="more"></span>
<p>用点分治先预处理出长度为 i 的路径数 ans[i] 。<br>假设当前层重心是 x ，设 a[i] 表示当前已经处理的所有子树到 x 路径长度为 i 的路径数，b[i] 表示正在处理的子树到 x 路径长度为 i 的路径数，则有</p>
<script type="math/tex; mode=display">
ans[i]=\sum_{j=0}^{i}a[j]*b[i-j]</script><p>然后将当前处理子树合并到已处理子树上，两数组相加即可。<br>关于求这个卷积，如果暴力求，很可能会TLE，如果没有TLE说明数据比较水，反正复杂度肯定是不行的。<br>可以用FFT或者NTT来求这个卷积。<br>不过就算这样了其实还是很可能会TLE。<br>假设当前根有 n-1 棵子树，每颗子树仅一个点，且第一个子树和当前根节点连的边为 100000 ，这样的话会被卡到 $O(n* z)$。<br/><br>因此需要将当前根节点的所有子树按照其最长路径从小到大排序后再依次合并，类似于启发式合并，复杂度会降低到$O(z\,logz\,logn)$<br/><br>算上点分治复杂度，总复杂度为 $O(z\,logz\,logn+n\,logn)$<br/><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Complex</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">    Complex(<span class="keyword">double</span> a = <span class="number">0</span>, <span class="keyword">double</span> b = <span class="number">0</span>) &#123;</span><br><span class="line">        x = a;</span><br><span class="line">        y = b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">inline</span> Complex <span class="keyword">operator</span>+(Complex a, Complex b) &#123; <span class="keyword">return</span> Complex(a.x + b.x, a.y + b.y); &#125;</span><br><span class="line"><span class="keyword">inline</span> Complex <span class="keyword">operator</span>-(Complex a, Complex b) &#123; <span class="keyword">return</span> Complex(a.x - b.x, a.y - b.y); &#125;</span><br><span class="line"><span class="keyword">inline</span> Complex <span class="keyword">operator</span>*(Complex a, Complex b) &#123; <span class="keyword">return</span> Complex(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x); &#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1</span> &lt;&lt; <span class="number">18</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">int</span> rev[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">get_rev</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">1</span> &lt;&lt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        rev[i] = (rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (s - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">FFT</span><span class="params">(Complex* a, <span class="keyword">int</span> n, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (i &lt; rev[i])</span><br><span class="line">            swap(a[i], a[rev[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, mid = <span class="number">1</span>; i &lt;= n; i &lt;&lt;= <span class="number">1</span>, mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="function">Complex <span class="title">wn</span><span class="params">(<span class="built_in">cos</span>(<span class="number">2</span> * PI / i), p * <span class="built_in">sin</span>(<span class="number">2</span> * PI / i))</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j += i) &#123;</span><br><span class="line">            <span class="function">Complex <span class="title">w</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = j; k &lt; j + mid; ++k) &#123;</span><br><span class="line">                Complex x = a[k], y = w * a[k + mid];</span><br><span class="line">                a[k] = x + y, a[k + mid] = x - y;</span><br><span class="line">                w = w * wn;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            a[i].x /= n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">5e4</span> + <span class="number">10</span>, H = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans[H];</span><br><span class="line">Complex F[N], G[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span>* b, <span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = n + m, bit = <span class="number">0</span>, s = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (s &lt;= len)++bit, s &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s; ++i)</span><br><span class="line">        F[i].x = a[i], G[i].x = b[i], F[i].y = G[i].y = <span class="number">0</span>;</span><br><span class="line">    get_rev(bit);</span><br><span class="line">    FFT(F, s, <span class="number">1</span>), FFT(G, s, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s; ++i)</span><br><span class="line">        F[i] = F[i] * G[i];</span><br><span class="line">    FFT(F, s, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= len; ++i)</span><br><span class="line">        ans[i] += (<span class="keyword">int</span>)(F[i].x + <span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[M], siz[M], d[M], nxt[M &lt;&lt; <span class="number">1</span>], to[M &lt;&lt; <span class="number">1</span>], cost[M &lt;&lt; <span class="number">1</span>], tot;</span><br><span class="line"><span class="keyword">bool</span> vis[M];</span><br><span class="line"><span class="keyword">int</span> Siz, rot;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    to[++tot] = b;</span><br><span class="line">    nxt[tot] = d[a];</span><br><span class="line">    d[a] = tot;</span><br><span class="line">    cost[tot] = c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">get_rt</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    siz[x] = <span class="number">1</span>; dp[x] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = d[x]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = to[i];</span><br><span class="line">        <span class="keyword">if</span> (u == f || vis[u])<span class="keyword">continue</span>;</span><br><span class="line">        get_rt(u, x);</span><br><span class="line">        siz[x] += siz[u];</span><br><span class="line">        dp[x] = max(dp[x], siz[u]);</span><br><span class="line">    &#125;</span><br><span class="line">    dp[x] = max(dp[x], Siz - siz[x]);</span><br><span class="line">    <span class="keyword">if</span> (dp[x] &lt; dp[rot])rot = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a[N], b[N];</span><br><span class="line"><span class="keyword">int</span> al, bl;</span><br><span class="line"><span class="keyword">int</span> stk[M], top;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    ++b[v];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = d[x]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = to[i];</span><br><span class="line">        <span class="keyword">if</span> (u == f || vis[u])<span class="keyword">continue</span>;</span><br><span class="line">        dfs(u, x, v + cost[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> Max;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, max_dep, cost;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> node&amp; other)<span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> max_dep &lt; other.max_dep;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;st[M];</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get_dep</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f, <span class="keyword">int</span> dep)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = dep;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = d[x]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = to[i];</span><br><span class="line">        <span class="keyword">if</span> (u == f || vis[u])<span class="keyword">continue</span>;</span><br><span class="line">        c = max(c, get_dep(u, x, dep + cost[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    a[<span class="number">0</span>] = <span class="number">1</span>; al = <span class="number">0</span>;</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = d[x]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = to[i];</span><br><span class="line">        <span class="keyword">if</span> (vis[u])<span class="keyword">continue</span>;</span><br><span class="line">        ++cnt;</span><br><span class="line">        st[cnt].x = u, st[cnt].max_dep = get_dep(u, x, cost[i]);</span><br><span class="line">        st[cnt].cost = cost[i];</span><br><span class="line">    &#125;</span><br><span class="line">    sort(st + <span class="number">1</span>, st + <span class="number">1</span> + cnt);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = st[i].x;</span><br><span class="line">        bl = st[i].max_dep;</span><br><span class="line">        dfs(u, x, st[i].cost);</span><br><span class="line">        Merge(a, b, al, bl);</span><br><span class="line">        Max = max(Max, al + bl);</span><br><span class="line">        al = max(al, bl);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= al; ++j)</span><br><span class="line">            a[j] += b[j], b[j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= al; ++i)</span><br><span class="line">        a[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    rot = <span class="number">0</span>; Siz = s;</span><br><span class="line">    get_rt(x, <span class="number">0</span>);</span><br><span class="line">    x = rot;</span><br><span class="line">    vis[x] = <span class="number">1</span>; calc(x);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = d[x]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = to[i];</span><br><span class="line">        <span class="keyword">if</span> (vis[u])<span class="keyword">continue</span>;</span><br><span class="line">        solve(u, siz[u] &lt; siz[x] ? siz[u] : s - siz[x]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, q;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;q);</span><br><span class="line">    dp[<span class="number">0</span>] = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> u, v, w;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">        ins(u, v, w);</span><br><span class="line">        ins(v, u, w);</span><br><span class="line">    &#125;</span><br><span class="line">    solve(<span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Max; ++i)</span><br><span class="line">        ans[i] += ans[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> k;</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;k);</span><br><span class="line">        <span class="keyword">int</span> L = <span class="number">0</span>, R = Max, Ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (L &lt;= R) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = L + R &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (ans[mid] &lt; k)L = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> R = mid - <span class="number">1</span>, Ans = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, Ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>FFT</tag>
        <tag>点分治</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P2178品酒大会</title>
    <url>/%E6%B4%9B%E8%B0%B7P2178%E5%93%81%E9%85%92%E5%A4%A7%E4%BC%9A/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDIxNzg=">题目链接<i class="fa fa-external-link-alt"></i></span></p>
<span id="more"></span>
<p>字符串好题啊！</p>
<p>题目描述见原题。</p>
<p>这题可以用后缀数组SA做。</p>
<p>我们先常规的后缀数组求出sa、height、rk数组，然后按照rank的顺序从1到n跑。</p>
<p>我们不妨求出对于每个点i，相似度为height[i]的所有点对，这样其实就是找到一个rank比rank[i]小的height比height[i]小的最大的位置，和找到一个rank比rank[i]大的height比height[i]小的位置。</p>
<p>这样对于其中所有$(j,k),rank[j]\leq i,i&lt;rank[k]$的点对都是相似度为0~height[i]的，然后用差分即可，这样很容易就能求出任意相似度的点对数，并且可以通过预处理然后RMQ求出最大美味度。<br>不过这个方法呢，需要找到每个点比他height小的两个点，多了一个log n，这题时间卡的还比较紧…(貌似可以用队列优化吧)</p>
<p>第二种方法就是按照rank从小到大跑，考虑用一个队列存相似度相同(为与当前点的相似度)的每一段，每一段记录这一段长度和这一段a的最大和最小值</p>
<p>现在考虑答案贡献问题：</p>
<p>我们从rank从小到大跑，当前到了i，我们将所有相似度不小于height[i]的进行答案计算，设这一段为[L,R]，和i-1相似度为k，则[L,R]中所有点到[R+1,i-1]所有点相似度最大为k，通过差分更新第一个答案，通过记下[R+1,i-1]中a的最大和最小值更新第二个答案。</p>
<p>对于加入第i个点，首先就是为了符合相似度递增，更新下，然后加入第i个点到队列即可。</p>
<p>注意些细节！</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> sa[N],tax[N],rk[N],tp[N];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">int</span> he[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">suffix_sort</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(tax+<span class="number">1</span>,<span class="number">0</span>,m&lt;&lt;<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)++tax[rk[i]];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)tax[i]+=tax[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;--i)sa[tax[rk[tp[i]]]--]=tp[i];</span><br><span class="line">&#125;<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">qsort</span><span class="params">()</span></span>&#123;</span><br><span class="line">    m=<span class="number">26</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)rk[i]=s[i]-<span class="string">&#x27;a&#x27;</span>+<span class="number">1</span>,tp[i]=i;</span><br><span class="line">    suffix_sort();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,p=<span class="number">0</span>;p&lt;n;m=p,i&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        p=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;++j)tp[++p]=n-i+j;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">            <span class="keyword">if</span>(sa[j]&gt;i)</span><br><span class="line">                tp[++p]=sa[j]-i;</span><br><span class="line">        suffix_sort(),swap(tp,rk);</span><br><span class="line">        rk[sa[<span class="number">1</span>]]=p=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>;j&lt;=n;++j)rk[sa[j]]=(tp[sa[j]]==tp[sa[j<span class="number">-1</span>]]&amp;&amp;tp[sa[j]+i]==tp[sa[j<span class="number">-1</span>]+i])?p:++p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">get_height</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j,k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k)--k;</span><br><span class="line">        j=sa[rk[i]<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">while</span>(s[i+k]==s[j+k])++k;</span><br><span class="line">        he[rk[i]]=k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;qsort();get_height();&#125;</span><br><span class="line"><span class="keyword">int</span> maxn[N],minn[N],stk[N],len[N],a[N],top;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum[N],Max[N];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> INF=<span class="number">1e18</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h=he[pos],cnt=<span class="number">0</span>,H,p=-inf,q=inf;</span><br><span class="line">    <span class="keyword">int</span> now,v=a[sa[pos]];</span><br><span class="line">    <span class="keyword">while</span>(top&amp;&amp;(now=stk[top])&gt;=h)&#123; </span><br><span class="line">        cnt+=len[top];</span><br><span class="line">        <span class="keyword">if</span>(now^inf)sum[now+<span class="number">1</span>]+=len[top]*<span class="number">1ll</span>*(n-pos+<span class="number">1</span>),Max[now]=max(Max[now],max(maxn[top]*<span class="number">1ll</span>*p,minn[top]*<span class="number">1ll</span>*q));</span><br><span class="line">        <span class="keyword">else</span> sum[<span class="number">0</span>]+=len[top]*<span class="number">1ll</span>*(n-pos+<span class="number">1</span>);</span><br><span class="line">        p=max(p,maxn[top]),q=min(q,minn[top]);</span><br><span class="line">        --top;</span><br><span class="line">    &#125;<span class="keyword">if</span>(cnt)&#123;</span><br><span class="line">        stk[++top]=he[pos];len[top]=cnt;maxn[top]=p,minn[top]=q;</span><br><span class="line">        sum[h+<span class="number">1</span>]-=len[top]*<span class="number">1ll</span>*(n-pos+<span class="number">1</span>);Max[h]=max(Max[h],max(v*<span class="number">1ll</span>*maxn[top],v*<span class="number">1ll</span>*minn[top]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%s&quot;</span>,&amp;n,s+<span class="number">1</span>);</span><br><span class="line">    init();</span><br><span class="line">    Max[<span class="number">0</span>]=-INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]),Max[i]=-INF;</span><br><span class="line">    he[n+<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;++i)&#123;</span><br><span class="line">        insert(i);</span><br><span class="line">        stk[++top]=inf;</span><br><span class="line">        len[top]=<span class="number">1</span>;</span><br><span class="line">        maxn[top]=minn[top]=a[sa[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)sum[i]+=sum[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-2</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">        Max[i]=max(Max[i],Max[i+<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>,sum[i]);</span><br><span class="line">        <span class="keyword">if</span>(Max[i]!=-INF)<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,Max[i]);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>字符串</tag>
        <tag>SA</tag>
      </tags>
  </entry>
  <entry>
    <title>NC18386字符串</title>
    <url>/%E7%89%9B%E5%AE%A2-%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>基础中的基础题。</p>
<h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p><span class="exturl" data-url="aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL3Byb2JsZW0vMTgzODY=">题目链接<i class="fa fa-external-link-alt"></i></span><br>给出一个长度为 n 的仅由小写字母构成的字符串，求出包含了所有的小写字母子串的最小长度。</p>
<span id="more"></span>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>很显然是用尺取法<br>对于每一个右端点，求出最大的左端点并且能满足条件即可，这样的话，当右端点往右移动时，显然这样的左端点也是往右移动的<br>对于快速求出是否符合条件只需要用桶存每个字母出现次数即可，每次移动右端点后，将左端点移动到最后一个使得所有字母都出现过的位置，这个位置也是第一个至少一个字母未出现的位置的左边一个。</p>
<p>参考代码如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> num[<span class="number">30</span>],res;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(++num[s[x]-<span class="string">&#x27;a&#x27;</span>]==<span class="number">1</span>)--res;</span><br><span class="line">&#125;<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(--num[s[x]-<span class="string">&#x27;a&#x27;</span>]==<span class="number">0</span>)++res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    res=<span class="number">26</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> n=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> L=<span class="number">1</span>,R=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans=n+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (R &lt;= n) &#123;</span><br><span class="line">        <span class="keyword">while</span>(R&lt;=n&amp;&amp;res)add(++R);</span><br><span class="line">        <span class="keyword">if</span>(R&gt;n)<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">while</span>(!res)del(L++);</span><br><span class="line">        ans=min(ans,R-L+<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>尺取法</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客每日一题</title>
    <url>/%E7%89%9B%E5%AE%A2%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><span class="exturl" data-url="aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vZGlzY3Vzcy80MzYyNTM/dHlwZT0xMDEmYW1wO29yZGVyPTAmYW1wO3Bvcz0xJmFtcDtwYWdlPTImYW1wO2NoYW5uZWw9LTEmYW1wO3NvdXJjZV9pZD0x">原文链接<i class="fa fa-external-link-alt"></i></span></p>
<p>题解的话牛客上也有很多，我的博客也写了一些。</p>
<p>要找到对应的题解，可以在标签找”牛客每日一题”，或者直接搜索对应的题目名字。</p>
<span id="more"></span>]]></content>
      <tags>
        <tag>牛客每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客挑战赛76D.魔物消灭计划</title>
    <url>/%E7%89%9B%E5%AE%A2%E6%8C%91%E6%88%98%E8%B5%9B76D-%E9%AD%94%E7%89%A9%E6%B6%88%E7%81%AD%E8%AE%A1%E5%88%92/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><span class="exturl" data-url="aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL2NvbnRlc3QvMTA4NDUvRA==">题目链接<i class="fa fa-external-link-alt"></i></span></p>
<span id="more"></span>
<p>这题其实就是最小斯坦纳树的模板题…<br>真的，只要会最小斯坦纳树，这题基本秒解。<br>将所有相同宝石当做一个点，然后将x,y也算作必选即可。<br>之后就是套最小斯坦纳树模板了。<br>不过其实也可以不用这样啦，直接将所有相同宝石的点连一个对应宝石的新增点，边权为0，然后初始化的时候，第i个点如果宝石种类是p，令f[i][1&lt;&lt;(p-1)]=0即可。</p>
<details>
    <summary>参考代码</summary>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">120</span>,M=<span class="number">1</span>&lt;&lt;<span class="number">10</span>,inf=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> d[N],nxt[M+<span class="number">2</span>*N],to[M+<span class="number">2</span>*N],cost[M+<span class="number">2</span>*N],tot;</span><br><span class="line"><span class="keyword">int</span> n,m,k;</span><br><span class="line"><span class="keyword">int</span> x,y,cnt;</span><br><span class="line"><span class="keyword">int</span> f[N][M],dis[N];</span><br><span class="line"><span class="keyword">bool</span> in[N];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    to[++tot]=b;</span><br><span class="line">    nxt[tot]=d[a];</span><br><span class="line">    d[a]=tot;</span><br><span class="line">    cost[tot]=c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        dis[i]=f[i][S];</span><br><span class="line">        <span class="keyword">if</span>(dis[i]&lt;inf)q.push(i),in[i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> x=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        in[x]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=d[x];i;i=nxt[i])&#123;</span><br><span class="line">            <span class="keyword">int</span> u=to[i];</span><br><span class="line">            <span class="keyword">if</span>(dis[u]&gt;dis[x]+cost[i])&#123;</span><br><span class="line">                dis[u]=dis[x]+cost[i];</span><br><span class="line">                <span class="keyword">if</span>(!in[u])in[u]=<span class="number">1</span>,q.push(u);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)f[i][S]=dis[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Stenier</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cnt=<span class="number">1</span>&lt;&lt;(k+<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)f[i][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> S=<span class="number">0</span>;S&lt;cnt;++S)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> T=S&amp;(S<span class="number">-1</span>);T;T=(T<span class="number">-1</span>)&amp;S)</span><br><span class="line">                f[i][S]=min(f[i][S],f[i][T]+f[i][S^T]);</span><br><span class="line">        spfa(S);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;k,&amp;x,&amp;y);</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">    <span class="keyword">int</span> p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;p);</span><br><span class="line">        <span class="keyword">if</span>(i==x)f[i][<span class="number">1</span>&lt;&lt;k]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i==y)f[i][<span class="number">1</span>&lt;&lt;(k+<span class="number">1</span>)]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!p)<span class="keyword">continue</span>;</span><br><span class="line">            f[i][<span class="number">1</span>&lt;&lt;(p<span class="number">-1</span>)]=<span class="number">0</span>;</span><br><span class="line">            ins(i,n+p,<span class="number">0</span>);</span><br><span class="line">            ins(n+p,i,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;n+=k;</span><br><span class="line">    <span class="keyword">int</span> u,v,w;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">        <span class="keyword">if</span>(u==v)<span class="keyword">continue</span>;</span><br><span class="line">        ins(u,v,w),ins(v,u,w);</span><br><span class="line">    &#125;</span><br><span class="line">    Stenier();</span><br><span class="line">    <span class="keyword">int</span> ans=inf;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)ans=min(ans,f[i][cnt<span class="number">-1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<p>感觉这样子的话如果去掉相同宝石可以传送，然后去掉建额外边，好像也是可以的？<br>因为其实求最小斯坦纳树除了初始化之外，之后与那k个点无关了。</p>
]]></content>
      <tags>
        <tag>最小斯坦纳树</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客挑战赛76E.牛牛数数</title>
    <url>/%E7%89%9B%E5%AE%A2%E6%8C%91%E6%88%98%E8%B5%9B76E-%E7%89%9B%E7%89%9B%E6%95%B0%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这题如果你会线性基的话，非常简单！</p>
<p>如果你还没学过线性基可以来看下我的这篇博客：</p>
<p><a href="/线形基/">线性基详解</a></p>
<span id="more"></span>
<p>这题啊，直接异或第k小+二分即可。</p>
<p>因为能异或出的数的个数知道，找到大于K的最小的数是第几小即可知道大于K的数有多少了。</p>
<p>不过呢，这题数据较弱，有些细节不考虑都能过，例如可以异或出0时有部分代码会出bug。</p>
<blockquote>
<p>hack数据：<br>2 12<br>13 2</p>
</blockquote>
<details>
    <summary>参考代码</summary>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">62</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> d[N],p[N];</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> K;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">60</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&amp;(<span class="number">1ll</span>&lt;&lt;i))&#123;</span><br><span class="line">            <span class="keyword">if</span>(d[i])x^=d[i];</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                d[i]=x;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">60</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i<span class="number">-1</span>;j&gt;=<span class="number">0</span>;--j)</span><br><span class="line">            <span class="keyword">if</span>(d[i]&amp;(<span class="number">1ll</span>&lt;&lt;j))d[i]^=d[j];</span><br><span class="line">    cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">60</span>;++i)</span><br><span class="line">        <span class="keyword">if</span>(d[i])p[cnt++]=d[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> S;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">kth</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">1</span>&amp;&amp;cnt&lt;n)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(cnt&lt;n)--k;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=cnt<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">        <span class="keyword">if</span>(k&amp;(<span class="number">1ll</span>&lt;&lt;i))ans^=p[i];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%lld&quot;</span>,&amp;n,&amp;K);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;x);</span><br><span class="line">        add(x);</span><br><span class="line">    &#125;</span><br><span class="line">    work();</span><br><span class="line">    <span class="keyword">if</span>(cnt&lt;n)S=<span class="number">1ll</span>&lt;&lt;cnt;</span><br><span class="line">    <span class="keyword">else</span> S=(<span class="number">1ll</span>&lt;&lt;cnt)<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> L=<span class="number">1</span>,R=S,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(L&lt;=R)&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span>  mid=L+R&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(kth(mid)&lt;=K)L=mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> R=mid<span class="number">-1</span>,ans=mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,S-ans+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>]]></content>
      <tags>
        <tag>线性基</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客练习赛76</title>
    <url>/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B76/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><span class="exturl" data-url="aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vZGlzY3Vzcy81ODkwMDc/dHlwZT0xMDEmYW1wO2NoYW5uZWw9LTEmYW1wO3NvdXJjZV9pZD0w">官方题解<i class="fa fa-external-link-alt"></i></span></p>
<span id="more"></span>
<p>这次比赛还比较难，就挺不戳的，刚好补知识点。</p>
<p>涉及考点：</p>
<ol>
<li><p>博弈论</p>
</li>
<li><p>线性基 异或第k小</p>
</li>
<li><p>最小斯坦纳树</p>
</li>
<li><p>莫比乌斯反演</p>
</li>
</ol>
<p>知识点讲解：</p>
<ol>
<li><p><a href="/%E7%BA%BF%E5%BD%A2%E5%9F%BA/">线性基</a></p>
</li>
<li><p><a href="/最小斯坦纳树详解/">最小斯坦纳树</a></p>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>第十八届浙江省大学生程序设计大赛F. Fair Distribution</title>
    <url>/%E7%AC%AC%E5%8D%81%E5%85%AB%E5%B1%8A%E6%B5%99%E6%B1%9F%E7%9C%81%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%A7%E8%B5%9BF-Fair-Distribution/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定T组询问，每次给出一个n，m </p>
<p>每次你可以让n减一或者m加一</p>
<p>问使得m是n的倍数最小步数</p>
<span id="more"></span>
<h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>有趣的脑子题</p>
<p>我们枚举A，使得n变为A</p>
<p>让m变成kA</p>
<p>则有$k=\lceil\frac{m}{A}\rceil$</p>
<p>这是使得m变成kA最小的k</p>
<p>所以步数即为$n-A+\lceil\frac{m}{A}\rceil*A-m$</p>
<p>即$n-m+A*(\lceil\frac{m}{A}\rceil-1)$</p>
<p>我的写法是把A替换为k了（不替换的可以自己想怎么写，其实差不多）</p>
<p>因为$k=\lceil\frac{m}{A}\rceil$</p>
<p>所以$A=\lceil\frac{m}{k}\rceil$</p>
<p>然后变为$n-m+\lceil\frac{m}{k}\rceil*(k-1)$</p>
<p>这样的话对于相同的$\lceil\frac{m}{k}\rceil$只用求一个最小的k</p>
<p>然后这个的取值是$O(\sqrt{m})$的</p>
<p>就做完了</p>
<p>枚举不同的$\lceil\frac{m}{k}\rceil$可以用整除分块，不过其实二分也行的，跑的也还挺快</p>
<p>下面附上代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Floor</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n/m+(n%m!=<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMaxK</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L=k,R=m,mid,ans=L;</span><br><span class="line">    <span class="keyword">while</span> (L &lt;= R) &#123;</span><br><span class="line">        mid=L+R&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(Floor(m,mid)==Floor(m,k))ans=mid,L=mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> R=mid<span class="number">-1</span>;</span><br><span class="line">    &#125;<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">        <span class="keyword">int</span> K=Floor(m,n);</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">1e9</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = K; k &lt;= m; ++k) &#123;</span><br><span class="line">            ans=min(ans,Floor(m,k)*(k<span class="number">-1</span>));</span><br><span class="line">            k=getMaxK(k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans+n-m);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是不是超简单！</p>
]]></content>
      <tags>
        <tag>思维题</tag>
      </tags>
  </entry>
  <entry>
    <title>第 45 届国际大学生程序设计竞赛（ICPC）亚洲区域赛（昆明）</title>
    <url>/%E7%AC%AC-45-%E5%B1%8A%E5%9B%BD%E9%99%85%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%EF%BC%88ICPC%EF%BC%89%E4%BA%9A%E6%B4%B2%E5%8C%BA%E5%9F%9F%E8%B5%9B%EF%BC%88%E6%98%86%E6%98%8E%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>战绩：</p>
<p>H、I、J、M、L</p>
<p>排名86，银牌</p>
<span id="more"></span>
<p>这一场 A 题就是在钓鱼…</p>
<p>题目名字叫AC ，通过率 2/515，幸亏没做</p>
<p>刚开始我也觉得是一道签到题，但是当我看到0/60的时候我就果断放弃了</p>
<h3 id="H-Hard-Calculation"><a href="#H-Hard-Calculation" class="headerlink" title="H.Hard Calculation"></a>H.Hard Calculation</h3><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>昆明赛区2021年第一次举办ICPC，假设每年举办一次，问第x届是多少年？</p>
<h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>直接输出2020+x即可</p>
<h3 id="L-Simone-and-graph-coloring"><a href="#L-Simone-and-graph-coloring" class="headerlink" title="L.Simone and graph coloring"></a>L.Simone and graph coloring</h3><h4 id="题目大意：-1"><a href="#题目大意：-1" class="headerlink" title="题目大意："></a>题目大意：</h4><p>T组，每一组给出n个数的排列$a_1,a_2…a_n$，对于每个$i<j\,and\,a_i>a_j$有一条边，你现在要给每条点染上一种颜色$c_i$，使得任意一条边的两个点颜色不同，并最小化不同颜色数，任意输出一种方案即可。</p>
<h4 id="题解：-1"><a href="#题解：-1" class="headerlink" title="题解："></a>题解：</h4><p>$a_i&gt;a_j$看着不太舒服</p>
<p>我们不妨将序列旋转过来（从尾到头）</p>
<p>对于一个点x，会与所有在他前面且小于他的连边，其中有一个是最长的链，不难发现我们让x的颜色为最长的链的长度即可</p>
<p>这样一定是最小的，且一定能满足题目要求</p>
<h3 id="I-Mr-Main-and-Windmills"><a href="#I-Mr-Main-and-Windmills" class="headerlink" title="I.Mr. Main and Windmills"></a>I.Mr. Main and Windmills</h3><h4 id="题目大意：-2"><a href="#题目大意：-2" class="headerlink" title="题目大意："></a>题目大意：</h4><p>说不清楚，具体看原题吧</p>
<h4 id="题解：-2"><a href="#题解：-2" class="headerlink" title="题解："></a>题解：</h4><p>枚举所有点对$(i,j)$，先判断是否和ST线段平行，平行则跳过</p>
<p>否则求出和ST的交点P，然后要判断P是否在线段上，如果不在则跳过</p>
<p>否则说明 P前和P后这两个点相对的 左/右 发生了改变</p>
<p>记$vector\,v[N]$ ，其中$v[x]$代表 x 点所有得到的这样的点P，$v[i]$和$v[j]$都push_back(P)即可</p>
<p>之后根据P到S的距离将对于每个$v[x]$排序即可</p>
<p>然后对于询问$h,k$</p>
<p>我们先看$v[h].size()$是否大于等于k</p>
<p>不是的话输出-1</p>
<p>否则输出$v[h][k-1]$即可</p>
<h3 id="J-Parallel-Sort"><a href="#J-Parallel-Sort" class="headerlink" title="J.Parallel Sort"></a>J.Parallel Sort</h3><h4 id="题目大意：-3"><a href="#题目大意：-3" class="headerlink" title="题目大意："></a>题目大意：</h4><p>n个数的一个排列$a_1,a_2…a_n$</p>
<p>每轮可以交换任意多次$i,j$位置上的数</p>
<p>但是每个位置$i$每轮最多被交换一次</p>
<p>问需要多少轮交换使得对于$\forall i,a_i=i$</p>
<p>现在要最小化交换轮数，但对于交换次数没有要求</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">1</span> <span class="number">2</span> <span class="number">4</span> </span><br></pre></td></tr></table></figure>
<p>我不能直接第一轮交换$(1,2)$变成$1,3,2,4$再交换$(2,3)$变成$(1,2,3,4)$ </p>
<p>因为这样2交换了两次</p>
<p>最少需要两轮</p>
<p>第一轮：交换$(1,2)$变成$1,3,2,4$</p>
<p>第二轮：交换$(2,3)$变成$1,2,3,4$</p>
<h4 id="题解：-3"><a href="#题解：-3" class="headerlink" title="题解："></a>题解：</h4><p>我们将所有$i$点与$a_i$点连边，不难发现肯定能构成一个环</p>
<p>如果$a_i=i$则说明不用交换</p>
<p>其余都是需要交换的情况</p>
<p>对于所有环最多只有两个点的情况，那么只需要最多一轮</p>
<p>对于有的环有大于两个点时，我们可以任意取环中任意一个点作为中心点，然后交换这个点左右两边第一个，左右两边第二个…直到让这个环变成若干个最多只有两个点的环</p>
<p>例：</p>
<p><img data-src="https://tu.sunpma.com/imgs/2021/04/53f9ccec2d563a4f.png" alt=""></p>
<p><img data-src="https://tu.sunpma.com/imgs/2021/04/241e79c702169f5e.png" alt=""></p>
<p><img data-src="https://tu.sunpma.com/imgs/2021/04/9300dc400425163a.png" alt=""></p>
<p>对于任意多个点都可以这样子通过某个点将左右两边交换变成一个更小的环和一个点数为2的环</p>
<p>而且可以发现第$i$次交换的就是第一次选的中心点的左右两边$i$个（也可能有其他方法，但是本质一样的）</p>
<p>这样这题就做出来了</p>
<p>特判 m = 0 和 m = 1</p>
<p>然后对于 m = 2 </p>
<p>我们对于每个点 dfs 找环，每个点最多被找到 1 次</p>
<p>找环时按照先后顺序将这些点记到数组</p>
<p>如果点数小于等于2 continue即可</p>
<p>否则我们以最后一个点（或者第一个点或者其他）为中心点，然后中心点左右两边第$1,2,…k$个交换即可</p>
<p>比如最后一个点为中心点时，假设总共k个数</p>
<p>那么是交换$(1,k-1),(2,k-2)…(i,k-i)(i&lt;k-i)$</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">&#125;b[N];</span><br><span class="line"><span class="keyword">bool</span> used[N];</span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="keyword">int</span> cnt,c[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(used[x])<span class="keyword">return</span>;</span><br><span class="line">    used[x]=<span class="literal">true</span>;</span><br><span class="line">    c[++cnt]=x;</span><br><span class="line">    dfs(a[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">bool</span> f=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] != i) &#123;</span><br><span class="line">            f=<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (f) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    f=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] != i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[a[i]] != i) &#123;</span><br><span class="line">                f=<span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (f) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;1\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]&gt;i)</span><br><span class="line">                ++m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,m);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] &gt; i) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d %d &quot;</span>,i,a[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;2\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        cnt=<span class="number">0</span>;</span><br><span class="line">        dfs(i);</span><br><span class="line">        <span class="keyword">if</span> (cnt &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; cnt-j; ++j) &#123;</span><br><span class="line">                b[++m].l=c[j];</span><br><span class="line">                b[m].r=c[cnt-j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d &quot;</span>,b[i].l,b[i].r),swap(a[b[i].l],a[b[i].r]);</span><br><span class="line">    m=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &gt; i)</span><br><span class="line">            ++m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &gt; i) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d %d &quot;</span>, i, a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="M-Stone-Games"><a href="#M-Stone-Games" class="headerlink" title="M.Stone Games"></a>M.Stone Games</h3><h4 id="题目大意：-4"><a href="#题目大意：-4" class="headerlink" title="题目大意："></a>题目大意：</h4><p>给出一个n，给出一个长度为n的序列$a_1,a_2…a_n$</p>
<p>每次询问给出一个$L,R$（强制在线了，需要自己转换下）</p>
<p>求出下标在$[L,R]$中最小的不能得到的非负整数（每个数可以选或者不选，这样能得出一个能得到的数的序列）</p>
<p>假设现在有 1 ，2 ，4 ，9</p>
<p>则可以得到的数是 0，1 , 2 , 3 , 4 , 5 , 6 , 7 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16</p>
<p>那么最小的不能得到的数是8</p>
<h4 id="题解：-4"><a href="#题解：-4" class="headerlink" title="题解："></a>题解：</h4><p>一开始想了一堆乱七八糟的</p>
<p>后来想到初步正解</p>
<p>假设序列是从小到大排序好了的</p>
<p>那么我们顺着做</p>
<p>假设前i个数最大能得到的数是$A$，如果第i+1个数$P$小于等于$A+1$则前$i+1$个数最大能得到的数是$P+A$</p>
<p>否则的话后面的数都大于$A+1$了，则$A+1$永远不能得到</p>
<p>这样的话就变成了找到第一个$i$使得前$i$个数的和+1小于第$i+1$个数即可</p>
<p>因为不一定有序，所以我们选择用主席树将他变成有序</p>
<p>这样变成了求出一个区间内第一个i，使得前$i$个最小的数的和+1小于第$i+1$小的数即可</p>
<p>我一开始以为这个满足二分性质，但后来发现错了</p>
<p>之后我队友（tql)提到了一个方法</p>
<p>我之前是想着枚举第几个，这样复杂度肯定超了</p>
<p>但是如果是枚举$A$这样就不会超了</p>
<p>我们假设当前能得到的数最大是$A$（初始为0）</p>
<p>我们在区间求$\leq A+1$的和，将这个和作为新的$A$</p>
<p>如果这个和就是$A$那么break出来（因为找不到数能让他更大了）</p>
<p>然后是复杂度证明</p>
<p>我们假设当前是$A$，我们现在将$A$更新为所有$\leq A+1$的和</p>
<p>假设变为了$S$</p>
<p>则下一次的和为$S$+所有权值在$[A+2,S+1]$中的和 或者是break</p>
<p>因为下一次我们会更新为$\leq S+1$的和，而上次更新到了$\leq A+1$的和</p>
<p>没有算权值在$[A+2,S+1]$中的和，所以这次要加上这一部分的和</p>
<p>因为至少存在一个</p>
<p>则经过两次后$A$至少变为了$2*A$</p>
<p>那么这个复杂度是最多$log_2 n$的</p>
<p>实际上呢完全跑不满！因为这是最极端情况</p>
<p>所以正解就是个while + 主席树</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> maxn=<span class="number">1e15</span>;</span><br><span class="line"><span class="keyword">int</span> ch[N*<span class="number">70</span>][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="keyword">int</span> rt[N];</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> s[N],sum[N*<span class="number">70</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span>&amp; las, <span class="keyword">int</span>&amp; now, <span class="keyword">long</span> <span class="keyword">long</span> L, <span class="keyword">long</span> <span class="keyword">long</span> R, <span class="keyword">long</span> <span class="keyword">long</span> pos)</span> </span>&#123;</span><br><span class="line">    now=++cnt;</span><br><span class="line">    sum[now]=sum[las]+pos;</span><br><span class="line">    <span class="keyword">if</span>(L==R)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> mid=L+R&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (pos &lt;= mid) &#123;</span><br><span class="line">        ch[now][<span class="number">1</span>]=ch[las][<span class="number">1</span>];</span><br><span class="line">        ins(ch[las][<span class="number">0</span>],ch[now][<span class="number">0</span>],L,mid,pos);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        ch[now][<span class="number">0</span>]=ch[las][<span class="number">0</span>];</span><br><span class="line">        ins(ch[las][<span class="number">1</span>],ch[now][<span class="number">1</span>],mid+<span class="number">1</span>,R,pos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span>&amp; las, <span class="keyword">int</span>&amp; now, <span class="keyword">long</span> <span class="keyword">long</span> L, <span class="keyword">long</span> <span class="keyword">long</span> R, <span class="keyword">long</span> <span class="keyword">long</span> pos)</span> </span>&#123;<span class="comment">//区间第k小</span></span><br><span class="line">    <span class="keyword">if</span> (L == R)<span class="keyword">return</span> sum[now] - sum[las];</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> mid = L + R &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos&lt;=mid)<span class="keyword">return</span> query(ch[las][<span class="number">0</span>],ch[now][<span class="number">0</span>],L,mid,pos);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> sum[ch[now][<span class="number">0</span>]]-sum[ch[las][<span class="number">0</span>]]+query(ch[las][<span class="number">1</span>],ch[now][<span class="number">1</span>],mid+<span class="number">1</span>,R,pos);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> lastans;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span>(x+lastans)%n+<span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        ins(rt[i<span class="number">-1</span>],rt[i],<span class="number">1</span>,maxn,a[i]),s[i]=s[i<span class="number">-1</span>]+a[i];</span><br><span class="line">    <span class="keyword">while</span> (k--) &#123;</span><br><span class="line">        <span class="keyword">int</span> L,R;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;L,&amp;R);</span><br><span class="line">        L=get(L),R=get(R);</span><br><span class="line">        <span class="keyword">if</span>(L&gt;R)swap(L,R);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> r=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> k = query(rt[L - <span class="number">1</span>], rt[R], <span class="number">1</span>, maxn, r+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(k&lt;=r)<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> r=k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,lastans=(r+<span class="number">1</span>));</span><br><span class="line">        lastans%=n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只用了 1400ms ，没有管常数啥的</p>
<h3 id="C-Cities"><a href="#C-Cities" class="headerlink" title="C. Cities"></a>C. Cities</h3><h4 id="题目大意：-5"><a href="#题目大意：-5" class="headerlink" title="题目大意："></a>题目大意：</h4><p>有T组数据</p>
<p>每组给出n个数$a_1,a_2…a_n(a_i\leq n)$</p>
<p>每次可以将连续的相同的数并将他们变成任意数</p>
<p>问最小需要多少次可以将所有数变成相同的</p>
<h4 id="题解：-5"><a href="#题解：-5" class="headerlink" title="题解："></a>题解：</h4><p>这题有一个非常重要的性质！</p>
<p>知道了这个性质，这题就是大水题了 </p>
<p>对于任意一个区间$[L,R]$最优解一定包含了整个区间变成$a_L$或者是$a_R$的解</p>
<p>所以对于任意区间$[L,R]$，都可以看做是将其变为$a_L$ </p>
<p>下面证明此性质（给出了全部变成$a_L$的证明，$a_R$同理）：</p>
<p>对于<strong>任意一个长度为1的区间</strong>，很显然该性质成立</p>
<p>对于<strong>任意一个长度为2的区间</strong>，很显然也成立</p>
<p>对于<strong>任意一个长度为$i$的区间$<a href="L+i-1=R">L,R</a>$</strong>：</p>
<p>我们假设$[L,R]$最优解是$[L,k]$和$[k+1,R]$的最优解合并</p>
<p>如果我们能证明任意长度为$k-L+1$和$R-k$的区间最优解包括全变成左端点的解</p>
<p>则可将问题简化为$a_L$和$a_{k+1}$合并，这样的话，很显然最优解也包括左端点的解</p>
<p>这样我们就能用归纳法证明对于<strong>任意一个区间</strong>，其最优解必定包括整个区间变为左端点的解（右端点同理）</p>
<p>定义$dp[L][R]$为$[L,R]$变为$a_L$的最优解</p>
<p>答案统计就变为$dp[L][R]=min(dp[L][k-1]+dp[k][R]+(a_k\neq a_L))$</p>
<p>不过这个方法会超时，因此考虑进一步优化</p>
<p>发现题目有一个关键的条件，相同的数最多不超过15个</p>
<p>我们不妨对于$a_k=a_L$和$a_k\neq a_L$分别考虑：</p>
<ul>
<li><p>$a_k=a_L$</p>
<p>$dp[L][R]=min(dp[L][k-1]+dp[k][R])$即可</p>
</li>
<li><p>$a_k\neq a_L$</p>
<p>$dp[L+1][R]+1\leq min(dp[L][k-1]+dp[k][R]+1)$</p>
<p>证明：</p>
<p>欲证明$dp[L+1][R]+1\leq min(dp[L][k-1]+dp[k][R]+1)$</p>
<p>即证明$dp[L+1][R]\leq min(dp[L][k-1]+dp[k][R])$</p>
<p>即证明$min(dp[L+1][k’-1]+dp[k’][R]+(a_{k’}\neq a_{L+1}))\leq min(dp[L][k-1]+dp[k][R])$</p>
<p>即证明$min(dp[L][k’])$</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P4151最大XOR路径</title>
    <url>/%E6%B4%9B%E8%B0%B7P4151%E6%9C%80%E5%A4%A7XOR%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个无向图，让你求从 1 到 n 的路径最大异或和。<br><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDQxNTE=">题目链接<i class="fa fa-external-link-alt"></i></span><br><span id="more"></span></p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>一条边如果经过偶数次则这条边对答案无影响，如果经过奇数次则有影响。<br>不难发现任意两条路径异或后其实都是若干个环，证明省略。<br>接下来考虑如何找到所有的环。<br>因为异或的性质，因此我们并非需要真的找到所有的环，实际上要找的环十分有限。<br>我们用dfs，每搜到一个点打上 vis 标记，如果下一个点已经 vis 过了，则这个环的异或和丢进线性基，否则继续深搜。<br>这样为什么是对的呢？<br>事实上这样很多的环套环是搜不到的。<br>当我们找到一个环后，这个环因为其所有点均 vis 过，因此包含此环一部分的其他环无法被找到。<br>不过所有的环其实均为若干个简单环异或而成，此处简单环指不可能与其他若干环异或的到新环，而简单环我们可以证明一定都能被找到，加入存在某简单环未在dfs中找到，则说明必定存在环上P，在找到该环前访问过该环上的某点Q，则P，Q之间必定至少存在一个环，说明该环不是简单环，因此可以证明所有简单环一定是能被找到的。<br>然后所有的环都能由若干个简单环异或而成，用线性基便可以得到所有可能异或出的值。<br>再回到最初说的两条路径异或和都是若干个环，这样的话最优路径和我们随便找的一条路径只相差若干个环，将所有的简单环的异或值丢进线性基，然后随便用一个1 到 n 的路径异或和找到异或最大值即可。</p>
<details>
    <summary>参考代码</summary>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">50010</span>,M=<span class="number">100010</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> f[<span class="number">70</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">60</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">        <span class="keyword">if</span>(x&amp;(<span class="number">1ll</span>&lt;&lt;i))&#123;</span><br><span class="line">            <span class="keyword">if</span>(f[i])x^=f[i];</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                f[i]=x;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> d[N],nxt[M&lt;&lt;<span class="number">1</span>],to[M&lt;&lt;<span class="number">1</span>],tot;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> cost[M&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">long</span> <span class="keyword">long</span> c)</span></span>&#123;</span><br><span class="line">    to[++tot]=b;</span><br><span class="line">    nxt[tot]=d[a];</span><br><span class="line">    d[a]=tot;</span><br><span class="line">    cost[tot]=c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dis[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">long</span> <span class="keyword">long</span> v)</span></span>&#123;</span><br><span class="line">    dis[x]=v;vis[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=d[x];i;i=nxt[i])&#123;</span><br><span class="line">        <span class="keyword">int</span> u=to[i];</span><br><span class="line">        <span class="keyword">if</span>(!vis[u])dfs(u,v^cost[i]);</span><br><span class="line">        <span class="keyword">else</span> insert(v^dis[u]^cost[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Max</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">60</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">        <span class="keyword">if</span>((ans^f[i])&gt;ans)ans^=f[i];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u,v;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> w;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%lld&quot;</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">        ins(u,v,w);</span><br><span class="line">        ins(v,u,w);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,Max(dis[n]));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
]]></content>
      <tags>
        <tag>线性基</tag>
      </tags>
  </entry>
  <entry>
    <title>莫比乌斯反演学习</title>
    <url>/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本来没打算现在就学这个神(yin)仙(jian)东西的，结果这几天来了好几题莫比乌斯反演题…<br><span id="more"></span></p>
<p>我是在这篇<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vcGVuZy15bS9wLzg2NDc4NTYuaHRtbA==">博客<i class="fa fa-external-link-alt"></i></span>学的，讲的不错，博客也是真的相当好看，相比之下我的博客就…<br>（也许以后会把我博客搞的也很漂亮吧，立个flag</p>
<h2 id="莫比乌斯函数"><a href="#莫比乌斯函数" class="headerlink" title="莫比乌斯函数"></a>莫比乌斯函数</h2><ul>
<li>首先，我们可以先明确一点，莫比乌斯函数并不是什么很高大上的东西，它其实只是一个由容斥系数所构成的函数。$\mu(d)$的定义是：</li>
</ul>
<ol>
<li>当 $d=1$ 时，$\mu(d)=1$.</li>
<li>当 $d=\Pi_{i=1}^{k}p_i$ 且 $p_i$为互异素数时，$\mu(d)=(-1)^k$.（即 d 的所有质因数幂次均不大于1时）</li>
<li>当 $d$ 的任意质因数幂次大于等于 2 ，$\mu(d)=0$.</li>
</ol>
<ul>
<li>当然，莫比乌斯函数也有很多有趣的性质：</li>
</ul>
<ol>
<li>对于任意正整数 n ，$\sum_{d|n}\mu(d)=[n=1]$（这个性质非常重要，后面给出证明）</li>
<li>对于任意正整数 n , $\sum_{d|n}{\frac{\mu(d)}{d}}=\frac{\phi(n)}{n}$（这个性质也很重要）</li>
</ol>
<h3 id="关于性质-1-的证明："><a href="#关于性质-1-的证明：" class="headerlink" title="关于性质 1 的证明："></a>关于性质 1 的证明：</h3><p>假设 $n=\Pi_{i=1}^{k}p_{i}^{k_i}$，因为质因数幂次大于等于 2 的莫比乌斯函数值为 0 ，因此只用考虑幂次为 0/1<br>当 n 不为 1 时，假设 d 中有 i 个互异素数，则有<br>$\sum_{d|n}\mu(d)=\sum_{i=0}^{k}(-1)^{k}*C(k,i)$，这个式子显然为 0 。<br>当 n = 1 时，没有质因数，且根据定义该性质依然成立。<br>证毕。</p>
<h3 id="求解莫比乌斯函数"><a href="#求解莫比乌斯函数" class="headerlink" title="求解莫比乌斯函数"></a>求解莫比乌斯函数</h3><p>可以在线性筛的基础上进行改造，如果没学过线性筛，可以来<a href="/线性筛详解/">这里</a>看看。</p>
<ul>
<li>当 d 为 1 时，$\mu(d)=1$</li>
<li>当 d 为素数时，很显然 $\mu(d)=-1$</li>
<li>当 d 为非素数时，因为线性筛的特殊性质，prime[j] 必定是 i*prime[j] 的最小质因数，如果 i % prime[ j ] ! = 0 ，则根据莫比乌斯的第二个定义， $\mu(i*prime[j])=-\mu(i)$即可，如果 i % prime[ j ] == 0 ，则根据第三个定义，$\mu(i*primep[j])=0$</li>
</ul>
<p>代码如下<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> mu[maxn],pri[maxn];<span class="comment">//prime简写</span></span><br><span class="line"><span class="keyword">bool</span> f[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>]=<span class="number">1</span>;f[<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!f[i])&#123;</span><br><span class="line">            pri[++pri[<span class="number">0</span>]]=i;</span><br><span class="line">            mu[i]=<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=pri[<span class="number">0</span>]&amp;&amp;i*pri[j]&lt;=n;++j)&#123;</span><br><span class="line">            f[i*pri[j]]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%pri[j]==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">            mu[i*pri[j]]=-mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>那么，莫比乌斯函数就这么告一段落了。</li>
</ul>
<h2 id="莫比乌斯反演"><a href="#莫比乌斯反演" class="headerlink" title="莫比乌斯反演"></a>莫比乌斯反演</h2><ul>
<li>解决完莫比乌斯函数的问题后，我们便迎来了重头戏<strong>莫比乌斯反演</strong></li>
<li>定理：F(n)和f(n)是定义在非负整数集合上的两个函数，并且满足条件：<script type="math/tex; mode=display">
F(n)=\sum_{d|n} f(d)</script>那么存在一个结论：<script type="math/tex; mode=display">
f(n)=\sum_{d|n}\mu(d)F(\frac{n}{d})</script>这个定理就称作莫比<strong>乌斯反演定理</strong>。</li>
</ul>
<p><li>莫比乌斯反演的证明主要有两种方式，其中一种就是通过定义来证明；另外一种，我则是会在<strong><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vcGVuZy15bS9wLzk0NDY1NTUuaHRtbA==">杜教筛<i class="fa fa-external-link-alt"></i></span></strong>中提到( 利用<em><strong>狄利克雷卷积</strong></em> )。那么我先来说一说第一种证明方法：</li></p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum{\mu(d)F(\frac{n}{d})} &= \sum{\mu(d)\sum_{i|\frac{n}{d}}f(i)} \\
&=\sum_{i|n}f(i)\sum_{d|\frac{n}{i}}{\mu(d)} \\
&=f(n)
\end{aligned}</script><p>其中第二步即将外层枚举 d 改为枚举 i 即可得到，最后一步即性质1。</p>
<ul>
<li>当然，莫比乌斯反演有另外的一种形式，当F(n)和f(n)满足：<script type="math/tex; mode=display">
F(n)=\sum_{n|d}f(d)</script>可以推出<script type="math/tex; mode=display">
f(n)=\sum_{n|d}\mu(\frac{d}{n})F(d)</script></li>
<li>感觉这个式子，可能在莫比乌斯反演中更加好用。</li>
</ul>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>1.<span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDI1MjI=">HNOI2011 Problem b<i class="fa fa-external-link-alt"></i></span><br><a href="/HNOI2011-Problem-b/">我的题解</a><br>2.<span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDIyNTc=">YY的GCD<i class="fa fa-external-link-alt"></i></span><br><a href="/YY的GCD/">我的题解</a></p>
]]></content>
      <tags>
        <tag>莫比乌斯反演</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>背包</title>
    <url>/%E8%83%8C%E5%8C%85/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p><span class="exturl" data-url="aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL3Byb2JsZW0vMTczMTU=">题目链接<i class="fa fa-external-link-alt"></i></span><br>容量为 V 的背包，有 n 个物品 ，每一个物品有一个价值 a 和重量 b ，现在要你选择 m 个物品装进背包，求出这 m 个物品价值中位数的最大值。</p>
<span id="more"></span>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>题解说的是 m 为偶数时取中位数较大的一个枚举也行，但是貌似这个没单调性？（我枚举最大数没做出来…</p>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>这题需要求中位数的最大值，因此需要先将所有物品按照从小到大排序<br>然后将问题从求解中位数最大值变成判断中位数是 x 的可能性<br>即我们枚举中位数，然后判断是否能成立</p>
<ol>
<li>m 是奇数时（ m = 2k + 1 )<br>此时我们枚举  $a_i(k+1\leq i \leq n-k)$ ，如果 i 重量最小的 k 个与 i 后重量最小 k 个与 i 的重量之和小于等于 V ，则说明中位数可以为$a_i$。</li>
<li>m 是偶数时（ m = 2k ）<br>此时枚举中位数中较小的一个，要使中位数最大，则中位数中较大的一个要尽量大。<br>我们设$pre_i$表示前 i 个中重量最小的 k 个，设$suf_i$表示 i 后重量最小的 k 个，则不难发现 $pre_i$单减，$suf_i$单增<br>这样的话其实如果枚举中位数较小的一个，中位数较大的一个是可以二分出来的，因为中位数较大的一个越大，$suf_i$越大，反之越小，因此能找大最大的一个。</li>
</ol>
<p>因此就这样边枚举边更新答案即可。</p>
<p>参考代码如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> pre[N],suf[N];</span><br><span class="line"><span class="keyword">int</span> n,m,V;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> node&amp;other)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a&lt;other.a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;V,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a[i].a,&amp;a[i].b);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a+<span class="number">1</span>,a+<span class="number">1</span>+n);</span><br><span class="line">    <span class="keyword">int</span> x=m&amp;<span class="number">1</span>;m&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        pre[i]=pre[i<span class="number">-1</span>]+a[i].b;</span><br><span class="line">        q.push(a[i].b);</span><br><span class="line">        <span class="keyword">if</span> (q.size() &gt; m<span class="number">-1</span>+x) &#123;</span><br><span class="line">            pre[i]-=q.top();</span><br><span class="line">            q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())q.pop();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">        suf[i]=suf[i+<span class="number">1</span>]+a[i].b;</span><br><span class="line">        q.push(a[i].b);</span><br><span class="line">        <span class="keyword">if</span> (q.size() &gt; m) &#123;</span><br><span class="line">            suf[i]-=q.top();</span><br><span class="line">            q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (x) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = m+<span class="number">1</span>; i &lt;= n-m; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(pre[i<span class="number">-1</span>]+suf[i+<span class="number">1</span>]+a[i].b&lt;=V)ans=a[i].a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> L,R,mid,Ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &lt;= n-m; ++i) &#123;</span><br><span class="line">            L=i+<span class="number">1</span>,R=n-m+<span class="number">1</span>,Ans=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (L &lt;= R) &#123;</span><br><span class="line">                mid=L+R&gt;&gt;<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(pre[i<span class="number">-1</span>]+a[i].b+suf[mid]&lt;=V)L=mid+<span class="number">1</span>,Ans=mid;</span><br><span class="line">                <span class="keyword">else</span> R=mid<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(Ans)ans=max(ans,(<span class="keyword">long</span> <span class="keyword">long</span>)(a[Ans].a+a[i].a));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans&gt;&gt;<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>牛客每日一题</tag>
        <tag>优先队列</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>SAM学习</title>
    <url>/SAM/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><link rel="dns-prefetch" href="//cdn.mathjax.org" /></p>
<meta name="referrer" content="no-referrer"/>

<h2 id="后缀自动机要干什么"><a href="#后缀自动机要干什么" class="headerlink" title="后缀自动机要干什么"></a>后缀自动机要干什么</h2><p>如果要在一个DAG（有向无环图）上表示出一个字符串的所有子串，应该怎么办？</p>
<span id="more"></span>
<p>很显然，一个最简单的方法是建立一个trie（字典树），如图。（对于 aabab建trie，红色为根，黄色为终止节点，边的方向未画出）<br><img data-src="https://cdn.luogu.com.cn/upload/pic/48640.png" alt=""><br>方法是将原串（ n为其长度，下文默认）的每一个后缀都加入字典树。</p>
<p>大家请观察一下这个字典树，看看它有什么性质。</p>
<p>我们能够直观地总结出来的性质有：</p>
<p>1.有一个源点，若干个终止点。边代表在目前的字符串后加上的字母。<strong>从源点到任意一个节点的任意路径可以形成一个字符串</strong>。<br>2.<strong>从源点到任意节点的任意路径形成的字符串均为原串子串</strong>。从源点到任意节点的任意路径不能形成的字符串均不为原串子串。（简单来说，这个图可以表示，且仅可以表示出原串的所有子串）<br>3.<strong>从源点到任意终止节点的任意路径形成的字符串均为原串后缀</strong>。<br>4.<strong>从源点出发的任意两条不同路径形成的字符串不相同</strong>。</p>
<p>如果满足以上四个性质，那我们便可以用此DAG处理许多事情。比如，判断某一个串是否为原串的子串（做法：从源点跑这个串，跑到 NULL就说明不是子串）、不同子串个数（做法：DAG上DP）等（后缀自动机可以处理的问题则多得多，因为它有更特殊的性质，这个之后再说）。</p>
<p>但是，我们发现了一个问题。<em>这样建立的DAG节点数是 $O(n^2)$<br>的</em>。当 n 很大时，这样的复杂度无法接受。事实上，我们发现图中许多的节点都可以合并，比如： b 之后的部分与 ab 之后的部分完全一致，可以合并。<br><img data-src="https://cdn.luogu.com.cn/upload/pic/48643.png" alt=""></p>
<p>我们现在的任务就是构建出一棵树，使得其具有字典树的性质，且使得点数和边数尽可能小。</p>
<h2 id="后缀自动机特别在哪"><a href="#后缀自动机特别在哪" class="headerlink" title="后缀自动机特别在哪"></a>后缀自动机特别在哪</h2><p>先来看一些定义吧。（<strong>这部分是后缀自动机的精髓，也是后缀自动机真正厉害的地方</strong>）</p>
<p>对于一个子串，它在原串中可能出现在若干的位置。而一个子串 p 出现的这些位置的右端点标号组成的集合，我们称之为 endpos(p)（例如原串为 abcab时，endpos(ab)={2,5}）<br><img data-src="https://cdn.luogu.com.cn/upload/pic/48645.png" alt=""><br>现在我们需要证明三个结论，它们将在算法中发挥重要的作用。</p>
<h3 id="如果两个子串的-endpos-相同，则其中子串一个必然为另一个的后缀"><a href="#如果两个子串的-endpos-相同，则其中子串一个必然为另一个的后缀" class="headerlink" title="如果两个子串的 endpos 相同，则其中子串一个必然为另一个的后缀"></a>如果两个子串的 endpos 相同，则其中子串一个必然为另一个的后缀</h3><p>设较短的字符串为 t ，较长的字符串为 p ，则每个t出现的位置的右端点前$len_t$个与 t 相同，因为endpos( t )=endpos(p)，因此 p 串后至少$len_s$个与 t 相同。（可以自己意会一下）</p>
<h3 id="对于任意两个子串-t-和-p-len-t-leq-len-p-，要么-endpos-p-in-endpos-t-，要么-endpos-p-cap-endpos-t-varnothing"><a href="#对于任意两个子串-t-和-p-len-t-leq-len-p-，要么-endpos-p-in-endpos-t-，要么-endpos-p-cap-endpos-t-varnothing" class="headerlink" title="对于任意两个子串 t 和 p ($len_t\leq len_p$)，要么$endpos(p)\in endpos( t )$，要么$endpos(p) \cap endpos( t )=\varnothing$"></a>对于任意两个子串 t 和 p ($len_t\leq len_p$)，要么$endpos(p)\in endpos( t )$，要么$endpos(p) \cap endpos( t )=\varnothing$</h3><p>证明基本同上：<br>如果 t 是 p 的后缀,则$endpos(p)\in endpos( t )$。<br><br>如果 t 不是 p 的后缀，则 t 和 p 出现的右端点不会相同，若相同，则必定有 t 是 p 的后缀，因此可得$endpos(p)\cap endpos( t )=\varnothing$。</p>
<h3 id="对于-endpos-相同的子串，我们将它们归为一个-endpos-等价类。对于任意一个-endpos-等价类，将包含在其中的所有子串依长度从大到小排序，则每一个子串的长度均为上一个子串的长度减-1-，且为上一个子串的后缀（简单来说，一个-endpos-等价类内的串的长度连续）"><a href="#对于-endpos-相同的子串，我们将它们归为一个-endpos-等价类。对于任意一个-endpos-等价类，将包含在其中的所有子串依长度从大到小排序，则每一个子串的长度均为上一个子串的长度减-1-，且为上一个子串的后缀（简单来说，一个-endpos-等价类内的串的长度连续）" class="headerlink" title="对于 endpos 相同的子串，我们将它们归为一个 endpos 等价类。对于任意一个 endpos 等价类，将包含在其中的所有子串依长度从大到小排序，则每一个子串的长度均为上一个子串的长度减 1 ，且为上一个子串的后缀（简单来说，一个 endpos 等价类内的串的长度连续）"></a>对于 endpos 相同的子串，我们将它们归为一个 endpos 等价类。对于任意一个 endpos 等价类，将包含在其中的所有子串依长度从大到小排序，则每一个子串的长度均为上一个子串的长度减 1 ，且为上一个子串的后缀（简单来说，一个 endpos 等价类内的串的长度连续）</h3><p>显然长度覆盖的区间是连续的，不可能存在空隙。后缀的命题可由结论 2 得到。<br>对于任意两个 endpos 等价类，它们不会同时包含同一个子串。<br>下文有一些地方直接用 endpos(i) 表示 endpos 等价类 i 中子串的 endpos ，请读者注意。<br>由以上三个定理，我们就可以得到一些延伸结论：</p>
<h3 id="endpos等价类个数的级别为-O-n"><a href="#endpos等价类个数的级别为-O-n" class="headerlink" title="endpos等价类个数的级别为$O(n)$"></a>endpos等价类个数的级别为$O(n)$</h3><p>这个命题比较重要。</p>
<p>对于一个<strong>类</strong>（<strong>endpos等价类简称</strong>），根据结论 3，其中有最长的一个子串（ p ）。在 p 第一个字符前添加任意一个字符（满足新形成的字符串为原串子串），得到的字符串必然不属于此类，因此会得到若干个新的类。我们由结论 2 得到新形成的字符串的 endpos 必然为 endpos(p) 的子集。并且在 p 前分别添加两个不同的字符，所得到的两个字符串的 endpos 必然完全不相交。<strong>所以对于此操作（在 p 前添加一个字符），我们可以认为是对一个原集合进行分割，分割得到几个新的集合，且保留原集合</strong>。当然，新的集合还可以继续分割，但是总的分割的次数（指断痕的个数， {1,2,3,4,5}分割成 {1,3},{2,4},{5}的分割次数为 2 ）不会超过原集合的大小，所以最终形成的集合个数也不会超过 2n（<strong>线段树的分割方法为子集个数最多的分法</strong>）。</p>
<p>由此，因为一切 endpos 都是从 {1,2,…,n}（ n 为原串长度）分割出来的，所以 endpos 等价类个数级别为 $O(n)$ 。（这一部分看不懂可以参考clj的ppt）</p>
<p>考虑<strong>分割关系</strong>。一个原集合分割成若干个子集的操作，是不是很像树的一个节点延伸出若干个子节点？我们发现，所有 endpos 等价类依靠这种分割关系，恰好可以构造出一个树形结构。（有时一个类的某些信息会在其儿子处丢失，例如图中 {1,2,4,6}的儿子是 {2}和 {4,6}，它们丢失了位置 1 的信息。至于原因，第四节会讲。）（下图例子的原串为 aababa）<br><img data-src="https://cdn.luogu.com.cn/upload/pic/48734.png" alt=""><br>于是，类之间就有了父子关系。<br><strong>我们称这棵树为parent tree</strong><br>下一个结论</p>
<h3 id="一个类-a-中，有最长的子串，也有最短的子串，我们称最长子串的长度为-len-a-，最短子串长度为-minlen-a-。对于存在父子关系的两个类，设-fa-a-表示类-a-的父亲（也是一个类）。则：-len-fa-a-1-minlen-a"><a href="#一个类-a-中，有最长的子串，也有最短的子串，我们称最长子串的长度为-len-a-，最短子串长度为-minlen-a-。对于存在父子关系的两个类，设-fa-a-表示类-a-的父亲（也是一个类）。则：-len-fa-a-1-minlen-a" class="headerlink" title="一个类 a 中，有最长的子串，也有最短的子串，我们称最长子串的长度为 len(a) ，最短子串长度为 minlen(a) 。对于存在父子关系的两个类，设 fa(a) 表示类 a 的父亲（也是一个类）。则： len(fa(a))+1=minlen(a)"></a>一个类 a 中，有最长的子串，也有最短的子串，我们称最长子串的长度为 len(a) ，最短子串长度为 minlen(a) 。对于存在父子关系的两个类，设 fa(a) 表示类 a 的父亲（也是一个类）。则： len(fa(a))+1=minlen(a)</h3><p>这个结论很显然，从我们推理结论 4 的步骤中就可以看出。在一个类中的最长子串前再添加一个字符，形成的字符串就必然属于其儿子中的一类，且这个新形成的字符串肯定是它所属的类中最短的一个。</p>
<p>因此，我们只用在parent tree中保存len即可， minlen 可由其父亲推出来。我们定义 longest(s) 表示 s 类中的最长子串， shortest(s) 表示 s 类中的最短子串。</p>
<p>我们把每一个类的最长子串写在节点旁，以方便理解。（原串还是 aababa）<br><img data-src="https://cdn.luogu.com.cn/upload/pic/48734.png" alt=""></p>
<p>现在，我告诉大家一个令人震惊的事情：我们要的后缀自动机的节点就是parent tree中的节点！妙啊（可以认为是parent tree和后缀自动机两个图共用同样的节点）只不过边与parent tree中的不同。其中空串所属的节点（parent tree的根）就是后缀自动机的源点。而终止节点便是最大子串（整个原串）所属于的节点（属于：这个节点的类包含此子串），以及其在parent tree上的祖先（标橙）!为什么要这么做呢？因为其节点数很少，且边数也很少（下有证明）。最重要的是，这样形成的图依靠parent tree，有非常有趣的性质，这个本节最后会说。</p>
<p>我们需要考虑如何建立parent tree，以及如何在这些点上连后缀自动机的边，使得从源点出发到达点 i 的任意一条路径形成的字符串均属于节点 i 所代表的类。</p>
<p>完成的后缀自动机如下（蓝色为后缀自动机的边）：<br><img data-src="https://cdn.luogu.com.cn/upload/pic/48741.png" alt=""><br>（太丑了是吗……之后的部分会给更好的图。其实这个图形不符合之后我们讲的后缀自动机的形态，不过这里只是为了展现后缀自动机有多么复杂而已……）</p>
<p>还可以理解为，延parent tree的边往下走是在字符串前面添加字符，延自动机的边往下走是在字符串后面添加字符。在第四节我们将看到，正是因为上面的特性，parent tree主要用来求节点（即各个字符串）的性质，而后缀自动机本身则主要用来直接跑字符串。</p>
<p>我们先简单说明一下满足条件的后缀自动机是一定存在的。还记得第一节提到的后缀自动机必须满足的四个基本性质吗？对于前三个后缀自动机可以满足。对于第四个，由于上文说道，对于任意两个 endpos 等价类，它们不会同时包含同一个子串，因此到达任意两个不同节点可能形成的字符串均不会重复。现在我们只需要说明边的正确性即可。若对于一个类的所有子串，我们都在它们后面添加一个相同的字符，则得到的所有新的字符串必定都属于另一个相同的类（想想是不是这样）。因此边存在正确性。所以后缀自动机存在。（这里的解释还是不够严谨，如果需要严谨解释可以用类似数学归纳法的方法结合程序说明。因为程序是递推的，初始状态的后缀自动机满足条件，程序正确，所以加入一个新的字符后的后缀自动机也满足条件。这里如果看不懂，可以看完第三节后再尝试理解）</p>
<p>另外，得到点的数量级还不够。下面再证一个比较重要的结论：</p>
<h3 id="后缀自动机的边数为-O-n"><a href="#后缀自动机的边数为-O-n" class="headerlink" title="后缀自动机的边数为 $O(n)$"></a>后缀自动机的边数为 $O(n)$</h3><p>考虑对于一个后缀自动机：先求出其任意一个生成树，舍弃其其它边。我们知道，后缀自动机上有若干个终止节点。于是我们便从每个终止节点往回跑所有属于它（这个类）的子串（从终止节点跑其实就是跑原串的后缀）。注意这里的往回跑是指：对于一个子串，按照原本后缀自动机到达其的唯一路径经过的边往回跑，而非只考虑边的字符，因为可能有多条代表相同字符的边指向同一个节点。</p>
<p>对于每个终止节点：我们按一定顺序跑遍属于它的子串。如果能顺利跑回源点，则跑下一个子串。否则，连上本应该跑回的边，沿它跑回下一个节点。此时，从这个节点出发，一定有一条或多条路径（经过现存的边）回到源点（因为有树的基础结构），则我们往回跑其中任意一条路径。这样，实际走的路径形成的字符串不一定是原本希望跑的子串，但是因为加了一条新边，且路径是从同样的终止节点开始的，所以得到的字符串必然属于此类，且未被跑过。我们只需要将这个字符串在将来要跑的子串中划掉即可。之后重跑我们原本希望跑的子串，直到真正顺利跑完这个子串，再按顺序跑下一个子串。可以发现，我们在此过程中增加的边数不会超过此节点 endpos 的大小。</p>
<p>这样，当跑完所有终止节点时，在原本的生成树上增加的边不会超过后缀的个数，即 n 个。而此时，增加了边的后缀自动机已经完整了。于是，生成树的边数加 n ，数量级为 $O(n)$。（这里与clj的ppt上的证明方法是刚好相反的，clj的证明是从源点开始向各个终止节点跑后缀，而非从终止节点往回跑到源点。）</p>
<p>为了方便理解以上内容，我们再画图讲解一下。下文的图解内容完全模拟上述证明方法。<br><img data-src="https://cdn.luogu.com.cn/upload/pic/48878.png" alt=""><br>以上是原串 abcd 的后缀自动机，我们随机取它的一个生成树：<br><img data-src="https://cdn.luogu.com.cn/upload/pic/48879.png" alt=""><br>终止节点只有 5一个。属于 5 的后缀有（abcd,bcd,cd,dabcd,bcd,cd,d）。我们按照（cd,d,abcd,bcdcd,d,abcd,bcd）的顺序跑后缀。跑 cd 时，我们发现可以直接沿 5-4-1 跑回源点，所以跑下一个子串。</p>
<p>跑 d 时，我们发现确实有一条 d 边连向 5,但是跑这条边回到的点的 endpos是 {3}，并不是应该的 {1,2,3,4}（ d 往回跑一个字符就是去掉其结尾字符得到空串， endpos 为 {1,2,3,4}）。所以此时我们需要连一条边，从代表 {1,2,3,4}的 1 连到 5 ：<br><img data-src="https://cdn.luogu.com.cn/upload/pic/48882.png" alt=""><br>跑 abcd 时，我们先跑回 4 节点，符合条件（去掉末尾剩下 abcabc， endpos 为 {3}，属于节点 4 ）。接下来，我们发现无法继续跑回，于是增加从 3 到 4 的 c 边：<br><img data-src="https://cdn.luogu.com.cn/upload/pic/48889.png" alt=""><br>此时剩下 ab，到达点 3 ，我们还是没办法跑它跑回源点。但是，我们不一定要跑它跑回源点，只要能跑回源点就行了。于是，我们往回跑 1 到 3 的边（代表 b ）。那么现在，我们就等于跑了 $b+c+d=bcd$ 的后缀了，它是一个之后我们要跑的后缀，我们把它划掉。然后接着往回跑 abcd ，连上 1 到 2 的边：<br><img data-src="https://cdn.luogu.com.cn/upload/pic/48891.png" alt=""><br>跑 bcd 时，我们发现它已经被划掉了，所以不用跑。</p>
<p>这样，我们跑完了所有后缀，增加了不多于 n 条边，完成了后缀自动机。（这个例子应该看得懂吧）</p>
<p>在进入下一节之前，我们再来说一说后缀自动机的特殊性。前面说到，后缀自动机的一般性可以让我们处理的问题有：判断子串，计算不同子串个数等。</p>
<p>而后缀自动机的特别之处在于parent tree与节点本身的特殊意义（ endpos 本质为在原串中出现的位置的集合）。这就导致可以通过在parent tree上DP得到每一个类中的子串和在原串中出现的位置相关的一些信息。例如，出现的次数，第一次出现的位置，出现在某个位置之后的次数等。这就导致后缀自动机可以处理更多类型的题目。</p>
<p>最后，我们梳理一下后缀自动机的性质，这些性质可能会对理解后缀自动机的构造方法有很大作用：</p>
<p>1.有一个源点，边代表在当前字符串后增加一个字符。<br>2.每个点代表一个 endpos等价类，到达一个点的路径形成的子串必须属于此点的类。<br><br>3.点之间有父子关系，到达点 i 的所有字符串的长度都必然大于到达 fa(i) 的所有字符串的长度，且到达 fa(i) 的任意一字符串必为到达 i 的任意一字符串的后缀。</p>
<h2 id="后缀自动机怎么构造"><a href="#后缀自动机怎么构造" class="headerlink" title="后缀自动机怎么构造"></a>后缀自动机怎么构造</h2><p>说了这么多，终于讲到构造了。</p>
<p>我们先简单描述一下后缀自动机的形态。后缀自动机大概是长这样子的<br><img data-src="https://cdn.luogu.com.cn/upload/pic/48960.png" alt=""><br>下面那整齐的一行节点表示的就是各个前缀所属的节点。显然，对于任意一个前缀，它在它所属的类中长度是最长的（不能再在其前面添加字符）。而相邻两个前缀所属点之间也肯定有连边。当然，不相邻的节点之间也会有一些边。所以我们把这些节点排成一行，方便观察。</p>
<p>而上面那些零零散散的节点则是不包含任意一个前缀的节点，有一些边连上去，有一些边连下来（注意，连上去的边与连下去的边分割没有那么明显，图只是示意，不要误解），它们之间还有一些连边。这就是后缀自动机的基本结构。</p>
<p>后缀自动机的构造是在线的，即我们通过不断添加单个字符的方式构建后缀自动机，时刻调整其状态。简单来说，我们把原串拆成一个个字符，按顺序塞进后缀自动机里。</p>
<p>先上程序吧。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NODE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> ch[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">int</span> len,fa;</span><br><span class="line">    NODE()&#123;<span class="built_in">memset</span>(ch,<span class="number">0</span>,<span class="keyword">sizeof</span>(ch));len=<span class="number">0</span>;&#125;</span><br><span class="line">&#125;dian[MAXN&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> las=<span class="number">1</span>,tot=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p=las;<span class="keyword">int</span> np=las=++tot;</span><br><span class="line">    dian[np].len=dian[p].len+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;p&amp;&amp;!dian[p].ch[c];p=dian[p].fa)dian[p].ch[c]=np;</span><br><span class="line">    <span class="keyword">if</span>(!p)dian[np].fa=<span class="number">1</span>;<span class="comment">//以上为case 1</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> q=dian[p].ch[c];</span><br><span class="line">        <span class="keyword">if</span>(dian[q].len==dian[p].len+<span class="number">1</span>)dian[np].fa=q;<span class="comment">//以上为case 2</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> nq=++tot;dian[nq]=dian[q];</span><br><span class="line">            dian[nq].len=dian[p].len+<span class="number">1</span>;</span><br><span class="line">            dian[q].fa=dian[np].fa=nq; </span><br><span class="line">            <span class="keyword">for</span>(;p&amp;&amp;dian[p].ch[c]==q;p=dian[p].fa)dian[p].ch[c]=nq;<span class="comment">//以上为case 3</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> s[MAXN];<span class="keyword">int</span> len;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);len=<span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)add(s[i]-<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（很多教材都没有很好地解释循环在条件满足时停止的原因，这也是本人当初不理解程序的重要地方之一，因此下文会花较大篇幅讲解循环的意义。）</p>
<p>相信大家肯定看不懂吧……（网上有博客说很好理解？？？）</p>
<p>但至少主函数内的东西应该是看的懂的，即读入原串，然后通过在线的方式一个个加入字符，通过 ans 函数构造后缀自动机。</p>
<p>那么 dian 就是后缀自动机里的节点。结构体里的 len 和 fa 与第二节里的定义一致。而 ch 则与 trie 里的边意义相近。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p=las;<span class="keyword">int</span> np=las=++tot;</span><br><span class="line">    dian[np].len=dian[p].len+<span class="number">1</span>;</span><br></pre></td></tr></table></figure><br>首先看第一行。 las 是什么？是未加入此字符前最长的前缀（整个串）所属的节点的编号， tot则是当前后缀自动机节点的总数。</p>
<p>新加入了一位字符 c（减了 ‘a’是为了方便塞进边里，可类比 trie 里对字符的处理）。我们设未加入 c 前的原串为旧串，加入 c 后的原串为新串。显然，此时新串的最长前缀（整个串）所属的节点显然不在原图中，因为原来的所有 endpos 都不可能包含这一位。而旧串的最长前缀就变成了新串的次大前缀。所以我们用 p 记录新串次大前缀（原串的最大前缀）所属的节点，然后新建一个节点 np ，存新的最大前缀所属的类。 len(np) 肯定就是新串的长度，即 len(p)+1 。</p>
<p>注意一下，加入 c 后，endpos 可能发生变化的字符串只有新串的后缀（或者说，旧串的后缀加 c ）（它们无论在旧串出现与否，在新串中出现的次数一定会比在旧串中多 1）。所以我们的任务就是处理好这些endpos发生变化的字符串（具体做法是遍历旧串后缀（事实上是遍历旧串的后缀自动机的终止节点），看看它们加 c 后 endpos 有没有改变）。另外，对于任意一个 endpos 变化的字符串，它的新 endpos 与原来 endpos 的差别只是多了一个 n ，即新串右端点的位置。因此我们判断一个串的 endpos 是否变化，只需要看其是否在新串最后出现即可。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(;p&amp;&amp;!dian[p].ch[c];p=dian[p].fa)dian[p].ch[c]=np;</span><br></pre></td></tr></table></figure><br>我们进行一个循环操作。这个循环操作进行下去的条件是： !dian[p].ch[c]（ !p只是防止其跳出根节点），即 p 没有一条 c 的出边。而 p 每一次循环后会跳到 dian[p].fa，即 fa(p)。</p>
<p>首先我们得知道往上跳到底是干什么。我们知道存在父子关系节点包含的子串有后缀关系。那么，这个 p 跳 fa(p) 操作的意思即：一个是 longest(p)（还记得 longest 是什么意思吗？定义在结论 5 的证明下面）的后缀，且与 longest(p) 所属类不同的最长串所属的类。（这里的 longest 改成 shortest 也无妨）</p>
<p>因为由一个节点往外连一条边就等于允许到达此节点的所有字符串往尾部添加一个新的字符。并且，由于 len(fa(i))+1=minlen(i)，因此对于 i 和 fa(i) ，它们包含的子串的长度从大到小排序时也是连续的。所以我们把每一个节点想象成所有到达它的字符串的集合。那么，这个跳 fa(i) 的操作可以理解为压缩地遍历一个串的所有后缀。在这里， p=fa(p) 即从长到短遍历旧串的所有后缀。</p>
<p>对于节点 p ，如果它没有 c 边（即 “longest(p)+c” 非旧串子串），那么引一条新边到 np 。这里用上面的思想解释，即将所有是旧串后缀且在其后面加 c 形成的新字符串不是旧串子串的字符串往新串的最长后缀所属节点连一条 c 边。这样的做法显然是正确的，因为这些后缀加了 c 产生的新字符串不是旧串的子串，但是因为是旧串的后缀，加上 c 后必然是新串后缀，即它们的 endpos={n}=endpos(np) 。因此向 np 连边是正确的。</p>
<p>注意循环的终止条件。如果长度再短，这些旧串后缀加 c 形成的新字符串就已经在旧串里出现过了，显然与新串最长前缀的 endpos 不同，所以不需要继续连边。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(!p)dian[np].fa=<span class="number">1</span>;<span class="comment">//以上为case 1</span></span><br></pre></td></tr></table></figure><br>如果已经遍历完了旧串的后缀且它们加 c 一个都不是旧串的子串，就说明 c 实际上是一个在旧串中没有出现过的字符，因此不可能存在除节点 1 以外的祖先，直接令 fa(np)=1。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> q=dian[p].ch[c];</span><br><span class="line">    <span class="keyword">if</span>(dian[q].len==dian[p].len+<span class="number">1</span>)dian[np].fa=q;</span><br></pre></td></tr></table></figure><br>p在第一个有 c 边的祖先停下了（停止原因已在上文说明）。此时，我们将 q 设为 p 的 c 出边到达的节点。此时，我们将做一个非常有趣的判断： len(q) 是否等于 len(p)+1。这个判断是什么意思呢？因为 “longest(p)+c” 是新串后缀，又因为 len(q)==len(p)+1，所以 longest(q)==”longest(p)+c” ，所以 longest(q) 是新串后缀。而 q 类中的所有串都是 longest(q) 的后缀，所以到达 q 的所有串都是新串后缀，它们的 endpos 都增加了 n ，因此到达 q 的所有串的 endpos 一致，符合后缀自动机的定义。由于 q 是我们找到的第一个与 np 不同的且有后缀关系的节点，我们把 fa(np) 设为 q 。<br>此时我们还需要说明一下为什么不用继续跳 fa，判断其他旧串后缀的情况。因为 p 继续跳 fa ，引出的 c 边到达节点 q’ 。那么， q’ 必然是 q 的祖先，那么原先到达 q’ 的串的endpos肯定都增加了一位 n ，满足_到达同一节点的字符串 endpos 都相同_的性质，不需要处理。到此，新串的后缀都已经被检查过了。</p>
<p>为了方便理解以上 case1 和 case2 ，我们举个例画图来讲解一下。</p>
<p>以 aaba 为例。初始只有一个源点：<br><img data-src="https://cdn.luogu.com.cn/upload/pic/48943.png" alt=""><br>加入a，创建节点2 ，len(2)=1 ，连边，1没有a的出边，跳到0 。所以进入case 1 ，直接设fa(2)=1。（蓝边表示parent tree，红字表示 len）<br><img data-src="https://cdn.luogu.com.cn/upload/pic/48952.png" alt=""><br>加入a，创建3。2没有a的出边，所以连边，跳1 。1有a的出边连向2，且 len(2)=1=0+1=len(1)+1，所以进入 case 2，直接 fa(3)=fa(2)。<br><img data-src="https://cdn.luogu.com.cn/upload/pic/49017.png" alt=""><br>加入b。创建4。3和2和1都没有b的出边，连边。所以进入case1，直接fa(4)=1。<br><img data-src="https://cdn.luogu.com.cn/upload/pic/49018.png" alt=""><br>加入a，创建5。4没有a边，跳1。1有a边连向2，且len(2)=len(1)+1。所以进入case2，fa(5)=2。<br><img data-src="https://cdn.luogu.com.cn/upload/pic/49020.png" alt=""><br>如图便是aaba的后缀自动机，大家检查一下，看看符不符合后缀自动机的性质。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> nq=++tot;dian[nq]=dian[q];</span><br><span class="line">    dian[nq].len=dian[p].len+<span class="number">1</span>;</span><br><span class="line">    dian[q].fa=dian[np].fa=nq; </span><br><span class="line">    <span class="keyword">for</span>(;p&amp;&amp;dian[p].ch[c]==q;p=dian[p].fa)dian[p].ch[c]=nq;<span class="comment">//以上为case 3</span></span><br></pre></td></tr></table></figure><br>终于来到后缀自动机构造最难理解的部分了。<br>当 $len(q)\not=len(p)+1$时怎么办？其实这个式子等价于len(q)&gt;len(p)+1，因为p可以到q，所以 $len(q)\ge len(p)+1$。</p>
<p>那么，len(q)&gt;len(p)+1代表了什么呢？它代表了还有至少一个比 “longest(p)+c”更长的串属于q。而这个更长的串必定不是新串的后缀，因为如果是，那么去掉其最后一个字符得到的字符串必然是旧串的后缀，且其长度大于longest(p)，因此应该先被跳到。然而事实并不是这样。所以，现在出现了一个问题：属于q的长度不大len(p)+1的串是新串的后缀（case2说明过），但大于len(p)+1的串却不是。此时，到达q这个节点的字符串并不全属于一个类（准确来说，属于两个类，一类的endpos比另一类的endpos多出了一个n），出现了问题（q的endpos无法得到定义）。而现在，我们要想办法将其中一个类的子串移到另一个节点上，只保留其中一类的字符串，让q的endpos可以得到定义。</p>
<p>我们考虑把endpos多出了n的字符串转移。显然，旧串的后缀自动机中并没有endpos与其相同的节点（如果有，那p本来就应该连向它）。所以我们新建一个节点nq，让endpos多出了n的字符串转移到此节点。</p>
<p>新建了一个节点，要考虑它的连边 ，fa与len。</p>
<p>先考虑len。由上文我们知道，长度大于len(p)+1的字符串都不可能是新串的后缀。并且，p有一条连到nq的边。因此，我们把len(nq)设为len(p)+1。</p>
<p>然后考虑出边。由于nq只是q拆出来的一个点，我们考虑直接用q的边。这样做显然是正确的，因为把nq从q拆出来只是因为nq的endpos与q不一样。但是，在q后和nq后加同样的字符，得到的字符串必然属于同一个类（首先，它们之间必然存在后缀关系且在旧串中属于一个类。又因为这个类中的串必定不是新串的后缀，否则就应该先被跳到，没有受到新加入字符的影响，所以在它们新串中还是同属一个类）。</p>
<p>最后考虑fa。由于原来的q被拆成了两个点q与nq。len(fa(nq))&lt;len(nq)&lt;len(q)。又因为fa(nq)肯定为旧串中的fa(q)，因为在旧串中q和nq还未被分拆。因此，可以看做是nq插入到了这个父子关系中。所以我们让 fa(nq) 等于旧的fa(q)，然后让fa(q)等于nq，类似于链表的插入。</p>
<p>此时，我们考虑np的fa。这个fa肯定是q和nq之一，因为它们最先被跳到。q肯定是不行的，因为它的endpos没有n，而endpos(np)有n。所以fa(np)必为nq。</p>
<p>之后，我们进行一个类似case1的循环操作，不断往上跳fa。只不过，这里的判断条件变成了dian[p].ch[c]==q。意思即，因为q的endpos不包含n，而 “longest(p)+c”的endpos必然含n，不符合后缀自动机性质，所以我们让这条边连向新的节点nq，这样显然是正确的（本就连向q，只是endpos多了一个n，所以连到len紧随其后的fa(q)，即nq）。</p>
<p>那么，为什么当dian[p].ch[c]\not=q时，可以不继续跳了呢？那是因为，这时dian[p].ch[c]的指向的点肯定是q的某个祖先（p变短了，并且”longest(p)+c”还是原来 “longest(p)+c”的后缀，所以q与dian[p].ch[c]满足祖先关系（后缀和长度要求））。那么，我们知道q的父亲是 nq， endpos包含n，因此 q的祖先的endpos都包含n。所以再往上跳，dian[p].ch[c]都不会出现一个节点两种endpos的错误情况了。</p>
<p>另外说一下，程序里dian[nq]=dian[q]的语句是压缩的fa和边的赋值。可以拆分成：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">strcpy</span>(dian[nq].ch,dian[q].ch);</span><br><span class="line">dian[nq].fa=dian[q].fa;</span><br></pre></td></tr></table></figure><br>以上就是程序的基本思想。</p>
<p>我们继续上图吧（可以对照上面的讲解与程序看一看）。例子：aababa。前面 aaba的图可以继续用。这是aaba的后缀自动机：<br><img data-src="https://cdn.luogu.com.cn/upload/pic/49020.png" alt=""><br>加入b，创建6。5没有b边，连边，跳2。2有b边连向4，但是len(4)\not=len(2)+1，（此时ab和aab都到达4，但二者endpos不同）所以新建节点7，从4复制fa,ch，len(7)=len(2)+1=2，然后令fa(6),fa(4)等于2。之后跳fa，把2连向4的边连向7，1连向4的边连向7。（尽梨了……ppt的曲线就是那么诡异）<br><img data-src="https://cdn.luogu.com.cn/upload/pic/49022.png" alt=""><br>加入a，创建8。6没有a的边，连边，跳7。7有a边连向5，但len(5)\not=len(7)+1，所以新建9，重复之前的操作。<br><img data-src="https://cdn.luogu.com.cn/upload/pic/49026.png" alt=""><br>以上便是构造后缀自动机的全部内容。下面，我们再来证明一些东西。第二节中，我们已经证明了后缀自动机的空间复杂度。现在让我们来证明后缀自动机构造的时间复杂度。</p>
<p>根据程序我们知道，可能超时的地方只有两个跳fa的循环。让我们一一证明它们的均摊时间复杂度是$O(n)$的。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(;p&amp;&amp;!dian[p].ch[c];p=dian[p].fa)dian[p].ch[c]=np;</span><br></pre></td></tr></table></figure><br>这是case1的循环。简单想想就知道，这个循环的真面目其实就是加边。因为后缀自动机构造的整个过程中，边数都不会减少，所以这里循环的次数应该与边数数量级相同，不会超过$O(n)$。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(;p&amp;&amp;dian[p].ch[c]==q;p=dian[p].fa)dian[p].ch[c]=nq;</span><br></pre></td></tr></table></figure><br>这是case3的循环。这里显然就不能认为是加边了，所以我们得换个思路。是不是可以认为，我们在遍历连向nq的边？因为nq一个新建节点，所以下一次进行这个循环的时候，我们不会再遍历上一个nq的边。又因为所有边被遍历的均摊复杂度是线性的（本人并不怎么会证明，网上资料也不多，如果需要详细了解请参考更高级的教材）。于是，我们可以认为程序对每一个节点的入边都遍历了一次。因此，均摊时间复杂度与边数相同。</p>
<h2 id="后缀自动机该怎么用"><a href="#后缀自动机该怎么用" class="headerlink" title="后缀自动机该怎么用"></a>后缀自动机该怎么用</h2><p>（下文将把后缀自动机和后缀数组进行对比，请未学习后缀数组的同学补一下，或者跳过一些内容）</p>
<p>后缀数组和后缀自动机能处理的相同问题很多，并且各自也有对方不能处理的问题。</p>
<p>后缀数组的时间复杂度是$O(n\log n)$。后缀自动机的时间复杂度是$O(n)$，可能常数会稍微大一点点，但应该还是必后缀数组快（取决于个人代码常数）。但是后缀自动机的做法往往比后缀数组无脑。</p>
<p>下文会列举几个后缀自动机可以解决的问题。如果后缀数组可以解决，也会列出简单解法。<br><strong>问题1：判断子串</strong><br>直接在后缀自动机上跑边，跑完串还未跑到 NULL 则为原串子串。</p>
<p>后缀数组：跑出 sa，然后从最小的后缀开始，一个个往后枚举，记录下当前匹配到的位置，如果匹配不上就下一个后缀，否则位置向后移一位。如果枚举完了后缀还没有完全匹配则不是原串子串。</p>
<p><strong>问题2：不同子串个数</strong><br>DAG上DP。对于一个节点i，f[i]表示从i出发的子串个数（不含空串）。那么，f[i]就等于$\sum_{(i,j)\in Edge}(f[j]+1)$。f[1]即是答案。</p>
<p>或者直接求$\sum(len(i)-len(fa(i)))$，因为后缀自动机上无重复字符串。</p>
<p>后缀数组：每一个后缀的长度减去其height之和。</p>
<p><strong>问题3:在原串所有子串中（相同的不算一个）字典序第i大的是哪个（<span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3Uub3JnL3Byb2JsZW1uZXcvc2hvdy9QMzk3NQ==">P3975<i class="fa fa-external-link-alt"></i></span>）</strong><br>这题比较重要。</p>
<p>首先处理出每个节点的endpos大小，即每个类中的串在原串中出现的次数。考虑dp，f[i]代表i的大小。对于不包含任意一个个前缀的节点，$f[i]=\sum{(i,j)\in parent \space treeEdge}f[j]$，因为比longest(i)前面多一个字符的所有字符串的endpos的并集必然等于endpos(longest(i))。而对于包含前缀的节点，$f[i]=(\sum{(i,j)\in parent \space treeEdge}f[j])+1$，因为第1位的信息在加字符时丢失了。（这里是第二节遗留的问题，可以参考第二节的parent tree示意图来理解。因为parent tree上一个节点的出边（方向从fa到ch）相当于对此节点endpos的拆分，拆分方式为在此节点的$longest$前面添加字符。但由于此节点包含前缀，在添加字符时必将丢失此前缀位置的endpos（因为加上字符的子串已经大于前缀长度），所以丢失了1位信息，需要加回来（$update\space 2019.8.15$）（具体到程序来说，只需在case1里加一句f[np]=1即可）</p>
<p>然后DP出g[i]，表示从i出发的子串个数（不含空集且计算重复），则$g[i]=\sum_{(i,j)\in SAM\space Edge}(g[j]+f[j])$。</p>
<p>最后，在后缀自动机上dfs，按字典序遍历出边，排名还够的减去这边的所有子串，不够的跑到这条出边连向的节点，重复以上步骤。当排名变为非正数时输出跑过的路径形成的字符串。具体做法还请参考本题题解。<br><strong>问题4：判断两个串的最长公共子串</strong><br>把两个串拼起来，跑后缀自动机。然后用类似于上面处理出现次数的方法，跑出一个子串在拼起来的串前半部分出现的次数和后半部分出现的次数。然后遍历节点，找len最大的前后出现次数都不为0的节点。以上思路还可以处理多个字符串的最长公共子串。</p>
<p>后缀数组：同样是拼起来，然后处理sa和height，对于每个后缀，找到其之后第一个属于另一半部分的后缀（可以$O(n)$做到，具体做法请读者思考），求它们的lcp，最后取最大值。</p>
<p>还有一些题目与方法本文可能未涉及到，请多多谅解。毕竟这只是给初学者看的文章，想要了解更高级的内容请自行寻找资料。<br><strong>后缀自动机思路精巧，处理问题多样，不失为字符串题目的好算法。</strong></p>
<blockquote>
<p>转载自 <span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL2Jsb2cvS2VzZGlhZWwzL2hvdS16aHVpLXppLWRvbmctamkteWFuZy14aWU=">KesdiaelKen 的博客<i class="fa fa-external-link-alt"></i></span><br>直接转载格式有误，因此为手工转载，如有错误，请留言指出，或QQ指出。</p>
</blockquote>
]]></content>
      <tags>
        <tag>字符串</tag>
        <tag>SAM</tag>
      </tags>
  </entry>
  <entry>
    <title>算法模板合集</title>
    <url>/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-数论"><a href="#1-数论" class="headerlink" title="1.数论"></a>1.数论</h2><h3 id="1-1-与取模有关的函数"><a href="#1-1-与取模有关的函数" class="headerlink" title="1.1 与取模有关的函数"></a>1.1 与取模有关的函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> wjr &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uint unsigned int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bs bitset<span class="meta-string">&lt;N&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lb(x) x&amp;-x</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line">    <span class="keyword">int</span> mod = <span class="number">998244353</span>, inv2 = <span class="number">499122177</span>, inf = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">initial</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        inv2 = (mod + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a * <span class="number">1ll</span> * b % mod; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a += b, a &gt;= mod ? a - mod : a; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a -= b, a &lt; <span class="number">0</span> ? a + mod : a; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">int</span> s = <span class="number">1</span>; <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>, a = mul(a, a))<span class="keyword">if</span> (b &amp; <span class="number">1</span>)s = mul(s, a); <span class="keyword">return</span> s; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> T <span class="title">sqr</span><span class="params">(<span class="keyword">register</span> T x)</span> </span>&#123; <span class="keyword">return</span> x * x; &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> wjr;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h3 id="1-2-FWT-快速沃尔什变换"><a href="#1-2-FWT-快速沃尔什变换" class="headerlink" title="1.2 FWT(快速沃尔什变换)"></a>1.2 FWT(快速沃尔什变换)</h3><p>可用于求</p>
<script type="math/tex; mode=display">
C[i\oplus j]=\sum_{i}\sum_{j}a[i]*b[j]</script><p>逻辑运算符可以为 异或，与，或</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> wjr &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uint unsigned int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bs bitset<span class="meta-string">&lt;N&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lb(x) x&amp;-x</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line">    <span class="keyword">int</span> mod = <span class="number">998244353</span>, inv2 = <span class="number">499122177</span>, inf = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">initial</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        inv2 = (mod + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a * <span class="number">1ll</span> * b % mod; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a += b, a &gt;= mod ? a - mod : a; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a -= b, a &lt; <span class="number">0</span> ? a + mod : a; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">int</span> s = <span class="number">1</span>; <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>, a = mul(a, a))<span class="keyword">if</span> (b &amp; <span class="number">1</span>)s = mul(s, a); <span class="keyword">return</span> s; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> T <span class="title">sqr</span><span class="params">(<span class="keyword">register</span> T x)</span> </span>&#123; <span class="keyword">return</span> x * x; &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> wjr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> FWT &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">maintain</span><span class="params">(<span class="keyword">int</span>&amp; n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> q = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (q &lt; n)</span><br><span class="line">            q &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        n = q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FWT_and</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> n, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> step, s, i, j;</span><br><span class="line">        <span class="keyword">for</span> (step = <span class="number">1</span>, s = <span class="number">2</span>; step &lt; n; step &lt;&lt;= <span class="number">1</span>, s &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i += s)</span><br><span class="line">                <span class="keyword">for</span> (j = i; j &lt; i + step; ++j)</span><br><span class="line">                    a[j] = ~p ? add(a[j], a[j + step]) : del(a[j], a[j + step]);</span><br><span class="line">    &#125;<span class="function"><span class="keyword">void</span> <span class="title">FWT_or</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> n, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> step, s, i, j;</span><br><span class="line">        <span class="keyword">for</span> (step = <span class="number">1</span>, s = <span class="number">2</span>; step &lt; n; step &lt;&lt;= <span class="number">1</span>, s &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i += s)</span><br><span class="line">                <span class="keyword">for</span> (j = i; j &lt; i + step; ++j)</span><br><span class="line">                    a[j + step] = ~p ? add(a[j + step], a[j]) : del(a[j + step], a[j]);</span><br><span class="line">    &#125;<span class="function"><span class="keyword">void</span> <span class="title">FWT_xor</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> n, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> step, s, i, j, x;</span><br><span class="line">        <span class="keyword">for</span> (step = <span class="number">1</span>, s = <span class="number">2</span>; step &lt; n; step &lt;&lt;= <span class="number">1</span>, s &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i += s)</span><br><span class="line">                <span class="keyword">for</span> (j = i; j &lt; i + step; ++j) &#123;</span><br><span class="line">                    x = a[j];</span><br><span class="line">                    a[j] = add(a[j], a[j + step]);</span><br><span class="line">                    a[j + step] = del(x, a[j + step]);</span><br><span class="line">                    <span class="keyword">if</span> (~p)<span class="keyword">continue</span>;</span><br><span class="line">                    a[j] = mul(a[j], inv2);</span><br><span class="line">                    a[j + step] = mul(a[j + step], inv2);</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FWTAND</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> n, <span class="keyword">int</span>* b, <span class="keyword">int</span> m, <span class="keyword">int</span>* c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> A[N], B[N];</span><br><span class="line">        <span class="keyword">int</span> len = max(n, m);</span><br><span class="line">        maintain(len);</span><br><span class="line">        <span class="built_in">memcpy</span>(A, a, n &lt;&lt; <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">memset</span>(A + n, <span class="number">0</span>, (len - n) &lt;&lt; <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">memcpy</span>(B, b, m &lt;&lt; <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">memset</span>(B + m, <span class="number">0</span>, (len - m) &lt;&lt; <span class="number">2</span>);</span><br><span class="line">        FWT_and(A, len, <span class="number">1</span>);</span><br><span class="line">        FWT_and(B, len, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">            A[i] = mul(A[i], B[i]);</span><br><span class="line">        FWT_and(A, len, <span class="number">-1</span>);</span><br><span class="line">        len = max(n, m);</span><br><span class="line">        <span class="built_in">memcpy</span>(c,A,len&lt;&lt;<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FWTOR</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> n, <span class="keyword">int</span>* b, <span class="keyword">int</span> m, <span class="keyword">int</span>* c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> A[N], B[N];</span><br><span class="line">        <span class="keyword">int</span> len = max(n, m);</span><br><span class="line">        maintain(len);</span><br><span class="line">        <span class="built_in">memcpy</span>(A, a, n &lt;&lt; <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">memset</span>(A + n, <span class="number">0</span>, (len - n) &lt;&lt; <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">memcpy</span>(B, b, m &lt;&lt; <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">memset</span>(B + m, <span class="number">0</span>, (len - m) &lt;&lt; <span class="number">2</span>);</span><br><span class="line">        FWT_or(A, len, <span class="number">1</span>);</span><br><span class="line">        FWT_or(B, len, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">            A[i] = mul(A[i], B[i]);</span><br><span class="line">        FWT_or(A, len, <span class="number">-1</span>);</span><br><span class="line">        len = max(n, m);</span><br><span class="line">        <span class="built_in">memcpy</span>(c, A, len &lt;&lt; <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FWTXOR</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> n, <span class="keyword">int</span>* b, <span class="keyword">int</span> m, <span class="keyword">int</span>* c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> A[N], B[N];</span><br><span class="line">        <span class="keyword">int</span> len = max(n, m);</span><br><span class="line">        maintain(len);</span><br><span class="line">        <span class="built_in">memcpy</span>(A, a, n &lt;&lt; <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">memset</span>(A + n, <span class="number">0</span>, (len - n) &lt;&lt; <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">memcpy</span>(B, b, m &lt;&lt; <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">memset</span>(B + m, <span class="number">0</span>, (len - m) &lt;&lt; <span class="number">2</span>);</span><br><span class="line">        FWT_xor(A, len, <span class="number">1</span>);</span><br><span class="line">        FWT_xor(B, len, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">            A[i] = mul(A[i], B[i]);</span><br><span class="line">        FWT_xor(A, len, <span class="number">-1</span>);</span><br><span class="line">        len = max(n, m);</span><br><span class="line">        <span class="built_in">memcpy</span>(c, A, len &lt;&lt; <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>传入公式对应的a数组及其大小，b数组及其大小，以及答案数组C即可，N=1&lt;&lt;20，即数组最大为1&lt;&lt;20</p>
<h3 id="1-3-FST-快速子集变换"><a href="#1-3-FST-快速子集变换" class="headerlink" title="1.3 FST(快速子集变换)"></a>1.3 FST(快速子集变换)</h3><p>可用于求</p>
<script type="math/tex; mode=display">
C[T]=\sum a[S]*b[T \oplus S]</script><p>逻辑运算符为异或</p>
<p>也可以写成</p>
<script type="math/tex; mode=display">
C[k]=\sum_{i\&j=0\\i|j=k}a[i]*[j]</script><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> wjr &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uint unsigned int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bs bitset<span class="meta-string">&lt;N&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lb(x) x&amp;-x</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line">    <span class="keyword">int</span> mod = <span class="number">998244353</span>, inv2 = <span class="number">499122177</span>, inf = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">initial</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        inv2 = (mod + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a * <span class="number">1ll</span> * b % mod; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a += b, a &gt;= mod ? a - mod : a; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a -= b, a &lt; <span class="number">0</span> ? a + mod : a; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">int</span> s = <span class="number">1</span>; <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>, a = mul(a, a))<span class="keyword">if</span> (b &amp; <span class="number">1</span>)s = mul(s, a); <span class="keyword">return</span> s; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> T <span class="title">sqr</span><span class="params">(<span class="keyword">register</span> T x)</span> </span>&#123; <span class="keyword">return</span> x * x; &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> wjr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> FST &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">int</span> ctz[N];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">initial</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ctz[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        ctz[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; ++i) </span><br><span class="line">            ctz[i] = ctz[i ^ (i &amp; -i)] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">maintain</span><span class="params">(<span class="keyword">int</span>&amp; n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> q = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (q &lt; n)</span><br><span class="line">            q &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        n = q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FST</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> n, <span class="keyword">int</span>* b, <span class="keyword">int</span> m, <span class="keyword">int</span>* c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> A[<span class="number">21</span>][<span class="number">1</span> &lt;&lt; <span class="number">20</span>], B[<span class="number">21</span>][<span class="number">1</span> &lt;&lt; <span class="number">20</span>], C[<span class="number">21</span>][<span class="number">1</span> &lt;&lt; <span class="number">20</span>];</span><br><span class="line">        <span class="keyword">int</span> len = max(n, m);</span><br><span class="line">        maintain(len);</span><br><span class="line">        <span class="keyword">int</span> lim = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((<span class="number">1</span> &lt;&lt; lim) &lt; len)</span><br><span class="line">            ++lim;</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=lim;++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;len;++j)</span><br><span class="line">                A[i][j]=B[i][j]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            A[ctz[i]][i] = a[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">            B[ctz[i]][i] = b[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= lim; ++i)</span><br><span class="line">            FWT::FWT_or(A[i], len, <span class="number">1</span>), FWT::FWT_or(B[i], len, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= lim; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; ++j)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; len; ++k)</span><br><span class="line">                    C[i][k] = add(C[i][k], mul(A[j][k], B[i - j][k]));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= lim; ++i)</span><br><span class="line">            FWT::FWT_or(C[i], len, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; lim); ++i)</span><br><span class="line">            c[i] = C[ctz[i]][i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用方法：传入a数组及其大小，b数组及其大小，以及答案数组c</p>
<h3 id="1-4-NTT"><a href="#1-4-NTT" class="headerlink" title="1.4 NTT"></a>1.4 NTT</h3><p>多项式卷积（模数按需修改）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> wjr &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uint unsigned int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bs bitset<span class="meta-string">&lt;N&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lb(x) x&amp;-x</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line">    <span class="keyword">int</span> mod = <span class="number">998244353</span>, inv2 = <span class="number">499122177</span>, inf = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">initial</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        inv2 = (mod + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a * <span class="number">1ll</span> * b % mod; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a += b, a &gt;= mod ? a - mod : a; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a -= b, a &lt; <span class="number">0</span> ? a + mod : a; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">int</span> s = <span class="number">1</span>; <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>, a = mul(a, a))<span class="keyword">if</span> (b &amp; <span class="number">1</span>)s = mul(s, a); <span class="keyword">return</span> s; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> T <span class="title">sqr</span><span class="params">(<span class="keyword">register</span> T x)</span> </span>&#123; <span class="keyword">return</span> x * x; &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> wjr;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*---多项式 - NTT */</span></span><br><span class="line"><span class="keyword">namespace</span> Poly_NTT &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">int</span> g[<span class="number">25</span>], gi[<span class="number">25</span>], rev[N], INV[N | <span class="number">1</span>];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;<span class="comment">/*---初始化---*/</span></span><br><span class="line">        <span class="keyword">int</span> bit = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ((<span class="number">1</span> &lt;&lt; bit) &lt; (n &lt;&lt; <span class="number">1</span>))++bit;</span><br><span class="line">        <span class="keyword">int</span> I = qpow(<span class="number">3</span>, mod - <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= bit; ++i)g[i] = qpow(<span class="number">3</span>, (mod - <span class="number">1</span>) &gt;&gt; i), gi[i] = qpow(I, (mod - <span class="number">1</span>) &gt;&gt; i);</span><br><span class="line">        INV[<span class="number">0</span>] = INV[<span class="number">1</span>] = <span class="number">1</span>; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= (<span class="number">1</span> &lt;&lt; bit); ++i)INV[i] = mul(INV[mod % i], mod - mod / i);</span><br><span class="line">    &#125;<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> n, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i, j, step, s, enk, wn, x, now;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)<span class="keyword">if</span> (i &lt; rev[i])swap(a[i], a[rev[i]]);</span><br><span class="line">        <span class="keyword">for</span> (step = <span class="number">1</span>, s = <span class="number">2</span>, now = <span class="number">1</span>; step &lt; n; step &lt;&lt;= <span class="number">1</span>, s &lt;&lt;= <span class="number">1</span>, ++now) &#123;</span><br><span class="line">            wn = ~p ? g[now] : gi[now];</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i += s) &#123;</span><br><span class="line">                enk = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (j = i; j &lt; i + step; ++j) &#123;</span><br><span class="line">                    x = mul(enk, a[j + step]);</span><br><span class="line">                    a[j + step] = del(a[j], x);</span><br><span class="line">                    a[j] = add(a[j], x);</span><br><span class="line">                    enk = mul(enk, wn);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">if</span> (~p)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)a[i] = mul(a[i], INV[n]);</span><br><span class="line">    &#125;<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">get_rev</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123; <span class="keyword">int</span> Maxn = <span class="number">1</span> &lt;&lt; s; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Maxn; ++i)rev[i] = (rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (s - <span class="number">1</span>)); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Mul</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> n, <span class="keyword">int</span>* b, <span class="keyword">int</span> m)</span> </span>&#123;<span class="comment">/*---多项式乘法---*/</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> A[N], B[N];</span><br><span class="line">        <span class="keyword">int</span> i, bit, s, len; len = n + m - <span class="number">1</span>;</span><br><span class="line">        bit = <span class="number">1</span>, s = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (s &lt; len)++bit, s &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        get_rev(bit);</span><br><span class="line">        <span class="built_in">memcpy</span>(A, a, n &lt;&lt; <span class="number">2</span>), <span class="built_in">memset</span>(A + n, <span class="number">0</span>, (s - n) &lt;&lt; <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">memcpy</span>(B, b, m &lt;&lt; <span class="number">2</span>), <span class="built_in">memset</span>(B + m, <span class="number">0</span>, (s - m) &lt;&lt; <span class="number">2</span>);</span><br><span class="line">        NTT(A, s, <span class="number">1</span>), NTT(B, s, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; s; ++i)A[i] = mul(A[i], B[i]);</span><br><span class="line">        NTT(A, s, <span class="number">-1</span>); <span class="built_in">memcpy</span>(a, A, len &lt;&lt; <span class="number">2</span>);</span><br><span class="line">    &#125;<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Inv</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> n)</span> </span>&#123;<span class="comment">/*---多项式逆元---*/</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> A[N], B[N], s, i, j, k, now;</span><br><span class="line">        s = <span class="number">2</span>; <span class="keyword">while</span> (s &lt; n)s &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">memset</span>(a + n, <span class="number">0</span>, (s - n) &lt;&lt; <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">memset</span>(B, <span class="number">0</span>, s &lt;&lt; <span class="number">3</span>);</span><br><span class="line">        B[<span class="number">0</span>] = a[<span class="number">0</span>] &lt;= N ? INV[a[<span class="number">0</span>]] : qpow(a[<span class="number">0</span>], mod - <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">2</span>, j = <span class="number">4</span>, now = <span class="number">2</span>; i &lt;= s; i &lt;&lt;= <span class="number">1</span>, j &lt;&lt;= <span class="number">1</span>, ++now) &#123;</span><br><span class="line">            <span class="built_in">memcpy</span>(A, a, i &lt;&lt; <span class="number">2</span>), <span class="built_in">memset</span>(A + i, <span class="number">0</span>, i &lt;&lt; <span class="number">2</span>);</span><br><span class="line">            get_rev(now);</span><br><span class="line">            NTT(A, j, <span class="number">1</span>), NTT(B, j, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; j; ++k)B[k] = mul(B[k], del(<span class="number">2</span>, mul(A[k], B[k])));</span><br><span class="line">            NTT(B, j, <span class="number">-1</span>), <span class="built_in">memset</span>(B + i, <span class="number">0</span>, i &lt;&lt; <span class="number">2</span>);</span><br><span class="line">        &#125;<span class="built_in">memcpy</span>(a, B, n &lt;&lt; <span class="number">2</span>);</span><br><span class="line">    &#125;<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">deriv</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> n)</span> </span>&#123;<span class="comment">/*---求导函数---*/</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)a[i] = mul(a[i + <span class="number">1</span>], i + <span class="number">1</span>); a[n - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">intag</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> n)</span> </span>&#123;<span class="comment">/*---求原函数---*/</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i; --i)a[i] = mul(a[i - <span class="number">1</span>], INV[i]); a[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Ln</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> n)</span> </span>&#123;<span class="comment">/*---对数函数---*/</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> A[N];</span><br><span class="line">        <span class="built_in">memcpy</span>(A, a, n &lt;&lt; <span class="number">2</span>), Inv(A, n);</span><br><span class="line">        deriv(a, n),</span><br><span class="line">            Mul(a, n, A, n);</span><br><span class="line">        intag(a, n), <span class="built_in">memset</span>(a + n, <span class="number">0</span>, (n - <span class="number">1</span>) &lt;&lt; <span class="number">2</span>);</span><br><span class="line">    &#125;<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Exp</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> n)</span> </span>&#123;<span class="comment">/*---指数函数---*/</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> A[N], B[N], i, j, k, now, s;</span><br><span class="line">        s = <span class="number">2</span>; <span class="keyword">while</span> (s &lt; n)s &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">memset</span>(a + n, <span class="number">0</span>, (s - n) &lt;&lt; <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">memset</span>(B, <span class="number">0</span>, s &lt;&lt; <span class="number">3</span>);</span><br><span class="line">        B[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">2</span>, j = <span class="number">4</span>, now = <span class="number">2</span>; i &lt;= s; i &lt;&lt;= <span class="number">1</span>, j &lt;&lt;= <span class="number">1</span>, ++now) &#123;</span><br><span class="line">            <span class="built_in">memcpy</span>(A, B, i &lt;&lt; <span class="number">2</span>), <span class="built_in">memset</span>(A + i, <span class="number">0</span>, i &lt;&lt; <span class="number">2</span>);</span><br><span class="line">            Ln(A, i); <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; i; ++k)A[k] = del(a[k], A[k]);</span><br><span class="line">            A[<span class="number">0</span>] = add(A[<span class="number">0</span>], <span class="number">1</span>), get_rev(now);</span><br><span class="line">            NTT(A, j, <span class="number">1</span>), NTT(B, j, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; j; ++k)B[k] = mul(B[k], A[k]);</span><br><span class="line">            NTT(B, j, <span class="number">-1</span>), <span class="built_in">memset</span>(B + i, <span class="number">0</span>, i &lt;&lt; <span class="number">2</span>);</span><br><span class="line">        &#125;<span class="built_in">memcpy</span>(a, B, n &lt;&lt; <span class="number">2</span>);</span><br><span class="line">    &#125;<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Ksm</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;<span class="comment">/*---快速幂---*/</span></span><br><span class="line">        <span class="comment">/*---对于x^n取模，最终长度是n而不是(n-1)k---*/</span></span><br><span class="line">        <span class="keyword">int</span> t, p, inv;</span><br><span class="line">        t = <span class="number">0</span>; <span class="keyword">while</span> (!a[t] &amp;&amp; t &lt; n)++t;</span><br><span class="line">        <span class="keyword">if</span> (t &gt;= n)<span class="keyword">return</span>;</span><br><span class="line">        p = a[t], inv = p &lt;= N ? INV[p] : qpow(p, mod - <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - t; ++i)a[i] = mul(a[i + t], inv);</span><br><span class="line">        <span class="built_in">memset</span>(a + n - t, <span class="number">0</span>, t &lt;&lt; <span class="number">2</span>);</span><br><span class="line">        Ln(a, n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)a[i] = mul(a[i], k);</span><br><span class="line">        a[<span class="number">0</span>] = <span class="number">0</span>, Exp(a, n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= t; --i)</span><br><span class="line">            a[i] = mul(p, a[i - t]);</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, t &lt;&lt; <span class="number">2</span>);</span><br><span class="line">    &#125;<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Div</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> n, <span class="keyword">int</span>* b, <span class="keyword">int</span> m)</span> </span>&#123;<span class="comment">/*---多项式除法+取模---*/</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> F[N], G[N];</span><br><span class="line">        <span class="built_in">memcpy</span>(F, a, (n + <span class="number">1</span>) &lt;&lt; <span class="number">2</span>), <span class="built_in">memcpy</span>(G, b, (m + <span class="number">1</span>) &lt;&lt; <span class="number">2</span>);</span><br><span class="line">        reverse(b, b + <span class="number">1</span> + m), reverse(F, F + <span class="number">1</span> + n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - m + <span class="number">1</span>; i &lt;= m; ++i)b[i] = <span class="number">0</span>;</span><br><span class="line">        Inv(b, n - m + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - m + <span class="number">1</span>; i &lt;= n; ++i)F[i] = <span class="number">0</span>;</span><br><span class="line">        Mul(F, n - m + <span class="number">1</span>, b, n - m + <span class="number">1</span>);</span><br><span class="line">        reverse(F, F + n - m + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - m + <span class="number">1</span>; i &lt;= n; ++i)F[i] = <span class="number">0</span>;</span><br><span class="line">        Mul(G, m + <span class="number">1</span>, F, n - m + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)b[i] = del(a[i], G[i]);</span><br><span class="line">        <span class="built_in">memcpy</span>(a, F, n &lt;&lt; <span class="number">2</span>);</span><br><span class="line">    &#125;<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Sqrt</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> n)</span> </span>&#123;<span class="comment">//多项式开根 </span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> A[N], B[N];</span><br><span class="line">        <span class="keyword">int</span> s, i, j, k, now;</span><br><span class="line">        s = <span class="number">2</span>; <span class="keyword">while</span> (s &lt; n)s &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">memset</span>(a + n, <span class="number">0</span>, (s - n) &lt;&lt; <span class="number">2</span>), <span class="built_in">memset</span>(B, <span class="number">0</span>, s &lt;&lt; <span class="number">3</span>);</span><br><span class="line">        B[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">2</span>, j = <span class="number">4</span>, now = <span class="number">2</span>; i &lt;= s; i &lt;&lt;= <span class="number">1</span>, j &lt;&lt;= <span class="number">1</span>, ++now) &#123;</span><br><span class="line">            <span class="built_in">memcpy</span>(A, B, i &lt;&lt; <span class="number">2</span>), <span class="built_in">memset</span>(A + i, <span class="number">0</span>, i &lt;&lt; <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; i; ++k)A[k] = mul(A[k], <span class="number">2</span>);</span><br><span class="line">            Inv(A, i);</span><br><span class="line">            get_rev(now - <span class="number">1</span>);</span><br><span class="line">            NTT(B, i, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; i; ++k)B[k] = mul(B[k], B[k]);</span><br><span class="line">            NTT(B, i, <span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; i; ++k)B[k] = add(B[k], a[k]);</span><br><span class="line">            get_rev(now);</span><br><span class="line">            NTT(B, j, <span class="number">1</span>), NTT(A, j, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; j; ++k)B[k] = mul(B[k], A[k]);</span><br><span class="line">            NTT(B, j, <span class="number">-1</span>), <span class="built_in">memset</span>(B + i, <span class="number">0</span>, i &lt;&lt; <span class="number">2</span>);</span><br><span class="line">        &#125;<span class="built_in">memcpy</span>(a, B, n &lt;&lt; <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-5-FFT"><a href="#1-5-FFT" class="headerlink" title="1.5 FFT"></a>1.5 FFT</h3><p>NTT是带取模的FFT</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> wjr &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uint unsigned int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bs bitset<span class="meta-string">&lt;N&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lb(x) x&amp;-x</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line">    <span class="keyword">int</span> mod = <span class="number">998244353</span>, inv2 = <span class="number">499122177</span>, inf = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">initial</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        inv2 = (mod + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a * <span class="number">1ll</span> * b % mod; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a += b, a &gt;= mod ? a - mod : a; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a -= b, a &lt; <span class="number">0</span> ? a + mod : a; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">int</span> s = <span class="number">1</span>; <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>, a = mul(a, a))<span class="keyword">if</span> (b &amp; <span class="number">1</span>)s = mul(s, a); <span class="keyword">return</span> s; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> T <span class="title">sqr</span><span class="params">(<span class="keyword">register</span> T x)</span> </span>&#123; <span class="keyword">return</span> x * x; &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> wjr;</span><br><span class="line"><span class="keyword">namespace</span> Poly_FFT &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1</span> &lt;&lt; <span class="number">18</span>, zw = (<span class="number">1</span> &lt;&lt; <span class="number">15</span>) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">int</span> rev[N];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cd</span> &#123;</span></span><br><span class="line">        <span class="keyword">double</span> x, y;</span><br><span class="line">        cd(<span class="keyword">double</span> a = <span class="number">0</span>, <span class="keyword">double</span> b = <span class="number">0</span>) &#123; x = a, y = b; &#125;</span><br><span class="line">    &#125;w[<span class="number">18</span>][N];</span><br><span class="line">    <span class="keyword">inline</span> cd <span class="keyword">operator</span>+(cd a, cd b) &#123; <span class="keyword">return</span> cd(a.x + b.x, a.y + b.y); &#125;</span><br><span class="line">    <span class="keyword">inline</span> cd <span class="keyword">operator</span>-(cd a, cd b) &#123; <span class="keyword">return</span> cd(a.x - b.x, a.y - b.y); &#125;</span><br><span class="line">    <span class="keyword">inline</span> cd <span class="keyword">operator</span>*(cd a, cd b) &#123; <span class="keyword">return</span> cd(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x); &#125;</span><br><span class="line">    <span class="keyword">inline</span> cd <span class="keyword">operator</span>*(cd a, <span class="keyword">int</span> b) &#123; <span class="keyword">return</span> cd(a.x, a.y * b); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, k = <span class="number">1</span>, j; i &lt;= <span class="number">17</span>; ++i, k &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; k; ++j)</span><br><span class="line">                w[i][j] = cd(<span class="built_in">cos</span>(PI * j / k), <span class="built_in">sin</span>(PI * j / k));</span><br><span class="line">    &#125;<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">get_rev</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">int</span> Maxn = <span class="number">1</span> &lt;&lt; s; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Maxn; ++i)rev[i] = (rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (s - <span class="number">1</span>)); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">FFT</span><span class="params">(<span class="keyword">register</span> cd* a, <span class="keyword">int</span> n, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> step, s, i, j, now;</span><br><span class="line">        cd x;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)<span class="keyword">if</span> (i &lt; rev[i])swap(a[i], a[rev[i]]);</span><br><span class="line">        <span class="keyword">for</span> (step = <span class="number">1</span>, s = <span class="number">2</span>, now = <span class="number">0</span>; step &lt; n; step &lt;&lt;= <span class="number">1</span>, s &lt;&lt;= <span class="number">1</span>, ++now)</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i += s)</span><br><span class="line">                <span class="keyword">for</span> (j = i; j &lt; i + step; ++j) &#123;</span><br><span class="line">                    x = a[j + step] * (w[now][j - i] * p);</span><br><span class="line">                    a[j + step] = a[j] - x;</span><br><span class="line">                    a[j] = a[j] + x;</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">if</span> (~p)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)a[i].x /= n;</span><br><span class="line">    &#125;<span class="function"><span class="keyword">inline</span> LL <span class="title">get</span><span class="params">(cd x, <span class="keyword">int</span> Mod)</span> </span>&#123; <span class="keyword">return</span> LL(x.x + <span class="number">0.5</span>) % Mod; &#125;</span><br><span class="line">    <span class="keyword">int</span> siz = <span class="keyword">sizeof</span>(cd);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> pw = <span class="number">32767</span>;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">MTT</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> n,<span class="keyword">int</span>*b,<span class="keyword">int</span> m,<span class="keyword">int</span>*c, <span class="keyword">int</span> Mod)</span> </span>&#123;<span class="comment">//对于较大模数需要用MTT</span></span><br><span class="line">        <span class="keyword">static</span> cd A[N], B[N], C[N], D[N], e[N], f[N], g[N], h[N];</span><br><span class="line">        <span class="keyword">int</span> i, s, len,bit; </span><br><span class="line">        len = n + m - <span class="number">1</span>;</span><br><span class="line">        bit=<span class="number">1</span>;</span><br><span class="line">        s = <span class="number">2</span>; </span><br><span class="line">        <span class="keyword">while</span> (s &lt; len)s &lt;&lt;= <span class="number">1</span>,++bit;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; s; ++i) &#123;</span><br><span class="line">            A[i] = cd(a[i] &gt;&gt; <span class="number">15</span>, <span class="number">0</span>), B[i] = cd(a[i] &amp; pw, <span class="number">0</span>);</span><br><span class="line">            C[i] = cd(b[i] &gt;&gt; <span class="number">15</span>, <span class="number">0</span>), D[i] = cd(b[i] &amp; pw, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        get_rev(bit);</span><br><span class="line">        FFT(A, s, <span class="number">1</span>), FFT(B, s, <span class="number">1</span>), FFT(C, s, <span class="number">1</span>), FFT(D, s, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; s; ++i)</span><br><span class="line">            e[i] = A[i] * C[i], f[i] = A[i] * D[i], g[i] = B[i] * C[i], h[i] = B[i] * D[i];</span><br><span class="line">        FFT(e, s, <span class="number">-1</span>), FFT(f, s, <span class="number">-1</span>), FFT(g, s, <span class="number">-1</span>), FFT(h, s, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">            c[i] = (((get(e[i], Mod) &lt;&lt; <span class="number">30</span>) % Mod + (get(f[i], Mod) &lt;&lt; <span class="number">15</span>) % Mod) % Mod + (get(g[i], Mod) &lt;&lt; <span class="number">15</span>) % Mod + get(h[i], Mod) % Mod) % Mod;</span><br><span class="line">    &#125;<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">MTT_2</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> n, <span class="keyword">int</span>* b, <span class="keyword">int</span> m)</span> </span>&#123;<span class="comment">//黑科技优化版本 </span></span><br><span class="line">        <span class="keyword">static</span> cd A[N], B[N], C[N], D[N];</span><br><span class="line">        <span class="keyword">int</span> len = n + m - <span class="number">1</span>, s = <span class="number">2</span>, i, t, bit = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">register</span> LL q, w, e, r;</span><br><span class="line">        <span class="keyword">while</span> (s &lt; len)s &lt;&lt;= <span class="number">1</span>,++bit;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)A[i] = cd(a[i] &amp; zw, a[i] &gt;&gt; <span class="number">15</span>);</span><br><span class="line">        <span class="keyword">for</span> (i = n; i &lt; s; ++i)A[i] = cd(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; ++i)B[i] = cd(b[i] &amp; zw, b[i] &gt;&gt; <span class="number">15</span>);</span><br><span class="line">        <span class="keyword">for</span> (i = m; i &lt; s; ++i)B[i] = cd(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        get_rev(bit);</span><br><span class="line">        FFT(A, s, <span class="number">1</span>), FFT(B, s, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; s; ++i) &#123;</span><br><span class="line">            t = (s - i) &amp; (s - <span class="number">1</span>);</span><br><span class="line">            C[i] = cd(<span class="number">0.5</span> * (A[i].x + A[t].x), <span class="number">0.5</span> * (A[i].y - A[t].y)) * B[i];</span><br><span class="line">            D[i] = cd(<span class="number">0.5</span> * (A[i].y + A[t].y), <span class="number">0.5</span> * (A[t].x - A[i].x)) * B[i];</span><br><span class="line">        &#125;FFT(C, s, <span class="number">-1</span>), FFT(D, s, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            q = LL(C[i].x + <span class="number">0.5</span>) % mod, w = LL(C[i].y + <span class="number">0.5</span>) % mod, e = LL(D[i].x + <span class="number">0.5</span>) % mod, r = LL(D[i].y + <span class="number">0.5</span>) % mod;</span><br><span class="line">            a[i] = (q + ((w + e) &lt;&lt; <span class="number">15</span>) + (r &lt;&lt; <span class="number">30</span>)) % mod;</span><br><span class="line">            <span class="comment">//a[i]=(q+((w+e)&lt;&lt;15)+(r&lt;&lt;30))%mod+mod;</span></span><br><span class="line">            <span class="comment">//a[i]=a[i]&gt;=mod?a[i]-mod:a[i];</span></span><br><span class="line">            <span class="comment">//此题没卡,一般是要写%mod+mod,然后再取模的。 </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-6-BSGS"><a href="#1-6-BSGS" class="headerlink" title="1.6 BSGS"></a>1.6 BSGS</h3><p>求解形如</p>
<script type="math/tex; mode=display">
a^t \equiv b(mod \,p)</script><p>给定a,b,p，其中p是质数</p>
<p>求解 t</p>
<p>复杂度为$O(\sqrt{p})$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> myhash &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> fib = <span class="number">2654435769</span>;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> (x * fib) &gt;&gt; <span class="number">14</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*---BSGS---*/</span></span><br><span class="line"><span class="keyword">namespace</span> BSGS &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>  N = <span class="number">1e4</span> + <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> d[<span class="number">1</span>&lt;&lt;<span class="number">18</span>], nxt[N], to[N], id[N], tot;</span><br><span class="line">    <span class="keyword">int</span> stk[N], tail;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> now = myhash::hash(x);</span><br><span class="line">        <span class="keyword">if</span> (!d[now])stk[++tail] = d[now];</span><br><span class="line">        to[++tot] = x, nxt[tot] = d[now], d[now] = tot, id[tot] = i;</span><br><span class="line">    &#125;<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> now = myhash::hash(x);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = d[now]; i; i = nxt[i])</span><br><span class="line">            <span class="keyword">if</span> (to[i] == x)<span class="keyword">return</span> id[i];</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="keyword">while</span> (tail)d[stk[tail--]] = <span class="number">0</span>; tot = <span class="number">0</span>; &#125;<span class="comment">//初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> p)</span> </span>&#123; <span class="keyword">int</span> s = <span class="number">1</span>; <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>, a = a * <span class="number">1ll</span> * a % p)<span class="keyword">if</span> (b &amp; <span class="number">1</span>)s = s * <span class="number">1ll</span> * a % p; <span class="keyword">return</span> s; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">BSGS</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> p)</span> </span>&#123;<span class="comment">//求a^t ≡b (mod p)</span></span><br><span class="line">        <span class="keyword">if</span> (b == <span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(p));</span><br><span class="line">        <span class="keyword">int</span> t = qpow(a, tmp, p), x = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tmp; ++i) &#123;</span><br><span class="line">            x = x * <span class="number">1ll</span> * t % p;</span><br><span class="line">            <span class="keyword">if</span>(query(x)==<span class="number">-1</span>)Insert(x, i);</span><br><span class="line">        &#125;x = b;</span><br><span class="line">        <span class="keyword">int</span> A = qpow(a, p - <span class="number">2</span>, p);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tmp; ++i) &#123;</span><br><span class="line">            t = query(x);</span><br><span class="line">            <span class="keyword">if</span> (~t)<span class="keyword">return</span> t * tmp - i;</span><br><span class="line">            x = x * <span class="number">1ll</span> * A % p;</span><br><span class="line">        &#125;<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用前需要使用init初始化</p>
<h3 id="1-7-扩展BSGS"><a href="#1-7-扩展BSGS" class="headerlink" title="1.7 扩展BSGS"></a>1.7 扩展BSGS</h3><p>待填坑</p>
<h3 id="1-8-中国剩余定理"><a href="#1-8-中国剩余定理" class="headerlink" title="1.8 中国剩余定理"></a>1.8 中国剩余定理</h3><p>求解形如</p>
<script type="math/tex; mode=display">
\left \{ 
\begin{array}{c}
x \equiv a_1\,(mod\,b_1) \\
x \equiv a_2\,(mod\,b_2)\\
\vdots \\
x \equiv a_n\,(mod\,b_n)
\end{array}
\right .</script><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*---中国剩余定理---*/</span></span><br><span class="line"><span class="keyword">namespace</span> EXCRT &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span> + <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-2</span>;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">        LL a[N], b[N];</span><br><span class="line">        LL ans, M;</span><br><span class="line">    &#125;;</span><br><span class="line">    LL x, y;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> LL <span class="title">exgcd</span><span class="params">(LL a, LL b, LL&amp; x, LL&amp; y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!b) &#123; x = <span class="number">1</span>, y = <span class="number">0</span>; <span class="keyword">return</span> a; &#125;</span><br><span class="line">        LL g = exgcd(b, a % b, y, x);</span><br><span class="line">        y -= (a / b) * x;</span><br><span class="line">        <span class="keyword">return</span> g;</span><br><span class="line">    &#125;<span class="function"><span class="keyword">inline</span> LL <span class="title">Mul</span><span class="params">(LL a, LL b, LL p)</span> </span>&#123;</span><br><span class="line">        LL d = ((<span class="keyword">long</span> <span class="keyword">double</span>)a / p * b + eps);</span><br><span class="line">        LL r = a * b - p * d;</span><br><span class="line">        <span class="keyword">return</span> r &lt; <span class="number">0</span> ? r + p : r;</span><br><span class="line">    &#125;<span class="function"><span class="keyword">inline</span> LL <span class="title">Del</span><span class="params">(LL a, LL b, LL p)</span> </span>&#123; <span class="keyword">return</span> a -= b, a &lt; <span class="number">0</span> ? a + p : a; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">CRT</span><span class="params">(node&amp; a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        a.ans = a.a[<span class="number">1</span>], a.M = a.b[<span class="number">1</span>];</span><br><span class="line">        LL c, exg, p;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;<span class="comment">//a.ans+x*a.M≡a.a[i](mod a.b[i]) </span></span><br><span class="line">            c = Del(a.a[i], a.ans, a.b[i]);<span class="comment">//x*a.M≡a.a[i]-a.ans(mod a.b[i])</span></span><br><span class="line">            exg = exgcd(a.M, a.b[i], x, y);</span><br><span class="line">            p = a.b[i] / exg;</span><br><span class="line">            <span class="keyword">if</span> (c % exg != <span class="number">0</span>) &#123; a.ans = <span class="number">-1</span>; <span class="keyword">return</span>; &#125;</span><br><span class="line">            x = Mul(x, c / exg, p);</span><br><span class="line">            a.ans += x * a.M;</span><br><span class="line">            a.M *= p;</span><br><span class="line">            a.ans = (a.ans % a.M + a.M) % a.M;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-9-矩阵树"><a href="#1-9-矩阵树" class="headerlink" title="1.9 矩阵树"></a>1.9 矩阵树</h3><p>基础应用：<br>给定一张图，求生成树个数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> wjr &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uint unsigned int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bs bitset<span class="meta-string">&lt;N&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lb(x) x&amp;-x</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line">    <span class="keyword">int</span> mod = <span class="number">998244353</span>, inv2 = <span class="number">499122177</span>, inf = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">initial</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        inv2 = (mod + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a * <span class="number">1ll</span> * b % mod; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a += b, a &gt;= mod ? a - mod : a; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a -= b, a &lt; <span class="number">0</span> ? a + mod : a; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">int</span> s = <span class="number">1</span>; <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>, a = mul(a, a))<span class="keyword">if</span> (b &amp; <span class="number">1</span>)s = mul(s, a); <span class="keyword">return</span> s; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> T <span class="title">sqr</span><span class="params">(<span class="keyword">register</span> T x)</span> </span>&#123; <span class="keyword">return</span> x * x; &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> wjr;</span><br><span class="line"><span class="comment">/*---Matrix_Tree矩阵树---*/</span></span><br><span class="line"><span class="keyword">namespace</span> Matrix_tree &#123;<span class="comment">//用于求解生成树个数 </span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">205</span>;</span><br><span class="line">    <span class="keyword">int</span> a[N][N];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123; ++a[u][u], ++a[v][v], --a[u][v], --a[v][u]; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gauss</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;<span class="comment">//如果是m*m矩阵,n=m-1,即忽略最后一行 </span></span><br><span class="line">        --n;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>, i, j, k, div, tmp;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            k = i;</span><br><span class="line">            <span class="keyword">for</span> (j = i; j &lt;= n; ++j)</span><br><span class="line">                <span class="keyword">if</span> (a[j][i]) &#123; k = j; <span class="keyword">break</span>; &#125;</span><br><span class="line">            <span class="keyword">if</span> (k != i)ans = -ans, swap(a[i], a[k]);</span><br><span class="line">            <span class="keyword">if</span> (!a[i][i])<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            div = qpow(a[i][i], mod - <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!a[j][i])<span class="keyword">continue</span>;</span><br><span class="line">                tmp = mul(div, a[j][i]);</span><br><span class="line">                <span class="keyword">for</span> (k = i; k &lt;= n; ++k)</span><br><span class="line">                    a[j][k] = del(a[j][k], mul(tmp, a[i][k]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            ans = mul(ans, a[i][i]);</span><br><span class="line">        <span class="keyword">return</span> ans &lt; <span class="number">0</span> ? ans + mod : ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">NonePrimeGauss</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;<span class="comment">//模数为非质数的求法</span></span><br><span class="line">        --n;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>, i, j, k, tmp;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                <span class="keyword">while</span> (a[j][i]) &#123;</span><br><span class="line">                    tmp = a[i][i] ? a[j][i] / a[i][i] : <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">for</span> (k = i; k &lt;= n; ++k)</span><br><span class="line">                        a[j][k] = del(a[j][k], mul(tmp, a[i][k]));</span><br><span class="line">                    ans = -ans, swap(a[i], a[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            ans = mul(ans, a[i][i]);</span><br><span class="line">        <span class="keyword">return</span> ans &lt; <span class="number">0</span> ? ans + mod : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-10-高斯消元法"><a href="#1-10-高斯消元法" class="headerlink" title="1.10 高斯消元法"></a>1.10 高斯消元法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> wjr &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uint unsigned int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bs bitset<span class="meta-string">&lt;N&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lb(x) x&amp;-x</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>, inv2 = <span class="number">499122177</span>, inf = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> eps=<span class="number">1e-6</span>;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a * <span class="number">1ll</span> * b % mod; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a += b, a &gt;= mod ? a - mod : a; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a -= b, a &lt; <span class="number">0</span> ? a + mod : a; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">int</span> s = <span class="number">1</span>; <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>, a = mul(a, a))<span class="keyword">if</span> (b &amp; <span class="number">1</span>)s = mul(s, a); <span class="keyword">return</span> s; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> T <span class="title">sqr</span><span class="params">(<span class="keyword">register</span> T x)</span> </span>&#123; <span class="keyword">return</span> x * x; &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> wjr;</span><br><span class="line"><span class="comment">/*---高斯消元---*/</span></span><br><span class="line"><span class="keyword">namespace</span> Gauss &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">105</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">matrix</span> &#123;</span><span class="comment">//整数（带取模）高斯消元</span></span><br><span class="line">        <span class="keyword">int</span> a[N][N];</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">doublematrix</span> &#123;</span><span class="comment">//小数高斯消元</span></span><br><span class="line">        <span class="keyword">double</span> a[N][N];</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Gauss</span><span class="params">(matrix&amp;x, <span class="keyword">int</span> n,<span class="keyword">int</span> m)</span> </span>&#123;<span class="comment">//n行m列 int（带取模）高斯消元</span></span><br><span class="line">        <span class="keyword">int</span> i, j, k, tmp;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            k = i;</span><br><span class="line">            <span class="keyword">for</span> (j = i; j &lt;= n; ++j)</span><br><span class="line">                <span class="keyword">if</span> (x.a[j][i]) &#123; k = j; <span class="keyword">break</span>; &#125;</span><br><span class="line">            <span class="keyword">if</span> (i != k)swap(x.a[k], x.a[i]);</span><br><span class="line">            tmp = qpow(x.a[i][i], mod - <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">for</span> (k = i; k &lt;= m; ++k)x.a[i][k] = mul(x.a[i][k], tmp);</span><br><span class="line">            <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                tmp = x.a[j][i];</span><br><span class="line">                <span class="keyword">for</span> (k = i; k &lt;= m; ++k)</span><br><span class="line">                    x.a[j][k] = del(x.a[j][k], mul(tmp, x.a[i][k]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i = n ; i ; --i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                tmp=x.a[i][j];</span><br><span class="line">                x.a[i][j]=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(k=n+<span class="number">1</span>;k&lt;=m;++k)</span><br><span class="line">                    x.a[i][k]=del(x.a[i][k],mul(x.a[j][k],tmp));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Gauss</span><span class="params">(doublematrix&amp; x, <span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;<span class="comment">//double高斯消元</span></span><br><span class="line">        <span class="keyword">int</span> i, j, k, tmp;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            k = i;</span><br><span class="line">            <span class="keyword">for</span> (j = i; j &lt;= n; ++j)</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">abs</span>(x.a[j][i])&gt;<span class="built_in">abs</span>(x.a[k][i])) k = j; </span><br><span class="line">            <span class="keyword">if</span> (i != k)swap(x.a[k], x.a[i]);</span><br><span class="line">            <span class="keyword">if</span> (x.a[i][i] &lt; <span class="number">0</span>)<span class="keyword">return</span> ;<span class="comment">//出问题了</span></span><br><span class="line">            tmp=x.a[i][i];</span><br><span class="line">            <span class="keyword">for</span> (k = i; k &lt;= m; ++k)x.a[i][k]/=tmp;</span><br><span class="line">            <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                tmp = x.a[j][i];</span><br><span class="line">                <span class="keyword">for</span> (k = i; k &lt;= m; ++k)</span><br><span class="line">                    x.a[j][k] -= tmp * x.a[i][k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i = n; i; --i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                tmp = x.a[i][j];</span><br><span class="line">                x.a[i][j] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (k = n + <span class="number">1</span>; k &lt;= m; ++k)</span><br><span class="line">                    x.a[i][k] -=  x.a[j][k]* tmp ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="1-11-莫比乌斯反演"><a href="#1-11-莫比乌斯反演" class="headerlink" title="1.11 莫比乌斯反演"></a>1.11 莫比乌斯反演</h3><ol>
<li>对于任意正整数 n ，$\sum_{d|n}\mu(d)=[n=1]$（这个性质非常重要，后面给出证明）</li>
<li>对于任意正整数 n , $\sum_{d|n}{\frac{\mu(d)}{d}}=\frac{\phi(n)}{n}$（这个性质也很重要）</li>
</ol>
<p>莫比乌斯函数求解：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> mu[maxn],pri[maxn];<span class="comment">//prime简写</span></span><br><span class="line"><span class="keyword">bool</span> f[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>]=<span class="number">1</span>;f[<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!f[i])&#123;</span><br><span class="line">            pri[++pri[<span class="number">0</span>]]=i;</span><br><span class="line">            mu[i]=<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=pri[<span class="number">0</span>]&amp;&amp;i*pri[j]&lt;=n;++j)&#123;</span><br><span class="line">            f[i*pri[j]]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%pri[j]==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">            mu[i*pri[j]]=-mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>定理：F(n)和f(n)是定义在非负整数集合上的两个函数，并且满足条件：</li>
</ul>
<script type="math/tex; mode=display">
F(n)=\sum_{d|n} f(d)</script><p>​       那么存在一个结论：</p>
<script type="math/tex; mode=display">
f(n)=\sum_{d|n}\mu(d)F(\frac{n}{d})</script><ul>
<li>当然，莫比乌斯反演有另外的一种形式，当F(n)和f(n)满足：<script type="math/tex; mode=display">
F(n)=\sum_{n|d}f(d)</script>可以推出<script type="math/tex; mode=display">
f(n)=\sum_{n|d}\mu(\frac{d}{n})F(d)</script>通常用整除分块优化复杂度。</li>
</ul>
<h3 id="1-12-狄利克雷卷积"><a href="#1-12-狄利克雷卷积" class="headerlink" title="1.12 狄利克雷卷积"></a>1.12 狄利克雷卷积</h3><ul>
<li><p>基本性质</p>
<p>一个函数卷积自己$mod$次就是$[n=1]$，卷积自己$mod+1$次就是自己</p>
</li>
<li><p>求法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dirichlet</span><span class="params">(<span class="keyword">int</span> f[],<span class="keyword">int</span> g[],<span class="keyword">int</span> ans[],<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(ans,<span class="number">0</span>,<span class="keyword">sizeof</span> ans);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;i*j&lt;=n;j++)</span><br><span class="line">            ans[i*j]+=f[i]*g[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="2-数据结构"><a href="#2-数据结构" class="headerlink" title="2. 数据结构"></a>2. 数据结构</h2><h3 id="2-1-双栈模拟-队列-双端队列"><a href="#2-1-双栈模拟-队列-双端队列" class="headerlink" title="2.1 双栈模拟 队列/双端队列"></a>2.1 双栈模拟 队列/双端队列</h3><ul>
<li>双栈模拟队列（兼容队列和双端队列）</li>
</ul>
<p>主要用途：</p>
<p>栈中容易维护，但是队列/双端队列中不好维护</p>
<p>将队列/双端队列转为栈的形式维护</p>
<p>复杂度O(n log n * 栈中维护复杂度)</p>
<hr>
<p>a[0]是队首栈，a[1]是队尾栈</p>
<ul>
<li><p>push：插入到栈 F 中。</p>
</li>
<li><p>pop：如果 S 非空，让 S 弹栈；否则将F中前一半的元素倒着插入S，F中只保留后一半，再在S中弹栈。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//a[0]表示队首栈，a[1]表示队尾栈</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stk</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> st[N],top;</span><br><span class="line">&#125;a[<span class="number">2</span>];</span><br><span class="line"><span class="comment">//向队首/队尾压栈，压栈时一般需要维护栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> o,<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    a[o].st[++a[o].top]=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">(<span class="keyword">int</span> o)</span> </span>&#123;<span class="comment">//弹栈，兼容队列和双端队列，复杂度为O(nlogn)</span></span><br><span class="line">    <span class="keyword">if</span> (a[o].top) &#123;<span class="comment">//如果栈中有元素直接弹栈</span></span><br><span class="line">        --a[o].top;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则，将另一个栈中一半的元素倒着压入该栈并弹栈</span></span><br><span class="line">    <span class="keyword">int</span> k=!o;</span><br><span class="line">    <span class="keyword">int</span> mid=(a[k].top+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>,top=a[k].top;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=mid;i&gt;=<span class="number">1</span>;--i)push(o,a[k].st[i]);</span><br><span class="line">    a[k].top=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=mid+<span class="number">1</span>;i&lt;=top;++i)push(k,a[k].st[i]);</span><br><span class="line">    --a[o].top;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-哈希表"><a href="#2-2-哈希表" class="headerlink" title="2. 2 哈希表"></a>2. 2 哈希表</h3><h4 id="斐波那契散列法-卡常用"><a href="#斐波那契散列法-卡常用" class="headerlink" title="斐波那契散列法(卡常用)"></a>斐波那契散列法(卡常用)</h4><p>1，对于16位整数而言，这个乘数是40503 </p>
<p>2，对于32位整数而言，这个乘数是2654435769 </p>
<p>3，对于64位整数而言，这个乘数是11400714819323198485</p>
<p>对于常见的32位整数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> fib= <span class="number">2654435769</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> (x* fib)&gt;&gt;<span class="number">14</span>;&#125;</span><br><span class="line"><span class="comment">//根据需要&gt;&gt;p，p越大所需空间越小，也越容易产生冲突</span></span><br></pre></td></tr></table></figure>
<h3 id="2-3-并查集"><a href="#2-3-并查集" class="headerlink" title="2.3 并查集"></a>2.3 并查集</h3><p>合并</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    u=find(u),v=find(v);</span><br><span class="line">    <span class="keyword">if</span>(u==v)<span class="keyword">return</span>;</span><br><span class="line">    fa[u]=v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启发式合并</p>
<p>并查集基础上记个size</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    u=find(u),v=find(v);</span><br><span class="line">    <span class="keyword">if</span>(u==v)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(siz[u]&gt;siz[v])</span><br><span class="line">        swap(u,v);</span><br><span class="line">    fa[u]=v;</span><br><span class="line">    siz[v]+=siz[u];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于路径压缩单次合并可能造成大量修改，有时路径压缩并不适合使用。例如，在可持久化并查集、线段树分治 + 并查集中，一般使用只启发式合并的并查集。</p>
<hr>
<h4 id="带权并查集"><a href="#带权并查集" class="headerlink" title="带权并查集"></a>带权并查集</h4><p>在并查集的<strong>边上</strong>定义某种权值并维护即可。</p>
<h3 id="2-4-堆"><a href="#2-4-堆" class="headerlink" title="2.4 堆"></a>2.4 堆</h3><h4 id="左偏树"><a href="#左偏树" class="headerlink" title="左偏树"></a>左偏树</h4><p>不带并查集</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,v,d;<span class="comment">//左儿子，右儿子，权值，dis</span></span><br><span class="line">&#125;a[N];</span><br><span class="line"><span class="comment">//合并</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x||!y)<span class="keyword">return</span> x|y;</span><br><span class="line">    <span class="keyword">if</span>(a[x].v&gt;a[y].v)swap(x,y);</span><br><span class="line">    a[x].r=Merge(a[x].r,y);</span><br><span class="line">    <span class="keyword">if</span>(a[a[x].r].d&gt;a[a[x].l].d)</span><br><span class="line">        swap(a[x].l,a[x].r);</span><br><span class="line">    a[x].d=a[a[x].r].d+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除根节点</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    Merge(a[x].l,a[x].r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>带并查集</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,v,d;<span class="comment">//左儿子，右儿子，权值，dis</span></span><br><span class="line">&#125;a[N];</span><br><span class="line"><span class="keyword">int</span> fa[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> x==fa[x]?x:fa[x]=find(fa[x]);&#125;</span><br><span class="line"><span class="comment">//合并</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x||!y)<span class="keyword">return</span> x|y;</span><br><span class="line">    <span class="keyword">if</span>(a[x].v&gt;a[y].v)swap(x,y);</span><br><span class="line">    a[x].r=Merge(a[x].r,y);</span><br><span class="line">    <span class="keyword">if</span>(a[a[x].r].d&gt;a[a[x].l].d)</span><br><span class="line">        swap(a[x].l,a[x].r);</span><br><span class="line">    a[x].d=a[a[x].r].d+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除根节点</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k=Merge(a[x].l,a[x].r);</span><br><span class="line">    fa[x]=fa[k]=k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将堆顶是x和y的合并，注意：并不是x,y所在堆</span></span><br><span class="line"><span class="comment">//需要先find</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _Merge(<span class="keyword">int</span> x,<span class="keyword">int</span> y)&#123;</span><br><span class="line">    <span class="keyword">int</span> k=Merge(x,y);</span><br><span class="line">    fa[x]=fa[y]=k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-5-李超线段树"><a href="#2-5-李超线段树" class="headerlink" title="2.5 李超线段树"></a>2.5 李超线段树</h3><p>功能：给定若干个线段，求某个点的最值。</p>
<p>用途：</p>
<ul>
<li>$min\{A<em>x+B\}/max\{A</em>x-B\}$  其中 x 为定值，可以用于优化DP等</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">line</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> k,b;<span class="comment">//斜率和截距</span></span><br><span class="line">    <span class="keyword">int</span> id;<span class="comment">//记录线段编号</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getf</span><span class="params">(line&amp;x,<span class="keyword">int</span> pos)</span></span>&#123;<span class="keyword">return</span> x.k*pos+x.b;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">inter</span><span class="params">(line&amp;a,line&amp;b)</span></span>&#123;<span class="keyword">return</span> (a.b-b.b)/(b.k-a.k); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span>&amp; x, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> ll, <span class="keyword">int</span> rr, line&amp; k)</span> </span>&#123;<span class="comment">//[ll,rr]上的线段</span></span><br><span class="line">    <span class="keyword">if</span> (!x)x = ++cnt;</span><br><span class="line">    <span class="keyword">if</span> (rr&lt;L || ll&gt;R)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = L + R &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (ll &lt;= L &amp;&amp; R &lt;= rr) &#123;</span><br><span class="line">        <span class="keyword">double</span> fl = getf(a[x], L), fr = getf(a[x], R), ql = getf(k, L), qr = getf(k, R);</span><br><span class="line">        <span class="keyword">if</span> (!a[x].id) &#123;<span class="comment">//没有就直接插入</span></span><br><span class="line">            a[x] = k;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ql &lt;= fl &amp;&amp; qr &lt;= fr)<span class="keyword">return</span>;<span class="comment">//如果整个区间比该节点线段更劣，或者相同但编号更大</span></span><br><span class="line">        <span class="keyword">if</span> (ql &gt;= fl &amp;&amp; qr &gt;= fr) &#123;<span class="comment">//如果整个区间都比该节点线段更优</span></span><br><span class="line">            a[x] = k;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> i = inter(a[x], k);<span class="comment">//交点</span></span><br><span class="line">        <span class="keyword">if</span> (ql &gt;= fl) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt;= mid)update(lc, L, mid, ll, rr, k);</span><br><span class="line">            <span class="keyword">else</span> update(rc, mid + <span class="number">1</span>, R, ll, rr, a[x]), a[x] = k;<span class="comment">//将a[x]递归更新子区间</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; mid)update(rc, mid + <span class="number">1</span>, R, ll, rr, k);</span><br><span class="line">            <span class="keyword">else</span> update(lc, L, mid, ll, rr, a[x]), a[x] = k;<span class="comment">//将a[x]递归更新子区间</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    update(lc, L, mid, ll, rr, k);</span><br><span class="line">    update(rc, mid + <span class="number">1</span>, R, ll, rr, k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查询的话根据需要，用所有包含pos的区间更新答案</span></span><br></pre></td></tr></table></figure>
<h3 id="2-6-吉斯林线段树"><a href="#2-6-吉斯林线段树" class="headerlink" title="2.6 吉斯林线段树"></a>2.6 吉斯林线段树</h3><p>功能：</p>
<p>对区间取min或max，求区间最值/区间和。</p>
<hr>
<p>线段树每个节点记录最大值，次大值，最大值个数，标记。</p>
<ol>
<li>如果 $MAX\leq t$，显然这个 是没有意义的，直接返回；</li>
<li>如果$Se &lt; t \leq Max$ ，那么这个 就能更新当前区间中的最大值。于是我们让区间和加上 ，然后更新 为 ，并打一个标记。</li>
<li>如果 $t\leq Se$，那么这时你发现你不知道有多少个数涉及到更新的问题。于是我们的策略就是，暴力递归向下操作。然后上传信息。</li>
</ol>
<p>势能分析法可得复杂度是O(mlogn)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    sum[x]=sum[lc]+sum[rc];</span><br><span class="line">    <span class="keyword">if</span> (mx[lc] == mx[rc]) &#123;</span><br><span class="line">        mx[x]=mx[lc];</span><br><span class="line">        se[x]=max(se[lc],se[rc]);</span><br><span class="line">        cnt[x]=cnt[lc]+cnt[rc];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (mx[lc] &gt; mx[rc]) &#123;</span><br><span class="line">        mx[x]=mx[lc];</span><br><span class="line">        se[x]=max(se[lc],mx[rc]);</span><br><span class="line">        cnt[x]=cnt[lc];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        mx[x]=mx[rc];</span><br><span class="line">        se[x]=max(mx[lc],se[rc]);</span><br><span class="line">        cnt[x]=cnt[rc];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushr</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(mx[x]&lt;=v)<span class="keyword">return</span>;</span><br><span class="line">    sum[x]+=(v-mx[x])*<span class="number">1ll</span>*cnt[x];</span><br><span class="line">    tag[x]=mx[x]=v;</span><br><span class="line">&#125;<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tag[x] != -inf) &#123;</span><br><span class="line">        pushr(lc,tag[x]);</span><br><span class="line">        pushr(rc,tag[x]);</span><br><span class="line">        tag[x]=-inf;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span>&amp; x, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    x=++tot;</span><br><span class="line">    tag[x]=-inf;</span><br><span class="line">    <span class="keyword">if</span> (L == R) &#123;</span><br><span class="line">        mx[x]=sum[x]=b[L];</span><br><span class="line">        cnt[x]=<span class="number">1</span>;</span><br><span class="line">        se[x]=-inf;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="keyword">int</span> mid=L+R&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    build(lc,L,mid);</span><br><span class="line">    build(rc,mid+<span class="number">1</span>,R);</span><br><span class="line">    pushup(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> ll, <span class="keyword">int</span> rr, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(mx[x]&lt;=v)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (ll &lt;= L &amp;&amp; R &lt;= rr&amp;&amp;se[x]&lt;v) <span class="keyword">return</span> pushr(x,v);</span><br><span class="line">    <span class="keyword">int</span> mid=L+R&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    pushdown(x);</span><br><span class="line">    <span class="keyword">if</span>(ll&lt;=mid)update(lc,L,mid,ll,rr,v);</span><br><span class="line">    <span class="keyword">if</span>(rr&gt;mid) update(rc,mid+<span class="number">1</span>,R,ll,rr,v);</span><br><span class="line">    pushup(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-7-K-D-tree"><a href="#2-7-K-D-tree" class="headerlink" title="2.7 K-D tree"></a>2.7 K-D tree</h3><p>k维n个点求 最近点对/最远点对，k远点对，k近点对等（k不能很大）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*---KD-Tree---*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">sqr</span><span class="params">(T&amp;x)</span></span>&#123;<span class="keyword">return</span> x*x;&#125;</span><br><span class="line"><span class="keyword">namespace</span> KDT &#123; </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>, M = N &lt;&lt; <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lc ch[x][0]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rc ch[x][1]</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pnt</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> x[<span class="number">2</span>];</span><br><span class="line">    &#125;a[N];</span><br><span class="line">    <span class="keyword">int</span> opt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span> </span><br><span class="line">        <span class="keyword">int</span> dis; </span><br><span class="line">        node(<span class="keyword">int</span> a = <span class="number">0</span>) &#123; </span><br><span class="line">            dis = a; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> node&amp; other)<span class="keyword">const</span> &#123; <span class="keyword">return</span> dis &gt; other.dis; &#125; </span><br><span class="line">    &#125;;<span class="comment">//小根堆 </span></span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;node&gt;q;</span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">register</span> pnt a, <span class="keyword">register</span> pnt b)</span> </span>&#123; <span class="keyword">return</span> a.x[opt] &lt; b.x[opt]; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(pnt a, pnt b)</span> </span>&#123; <span class="keyword">return</span> sqr(a.x[<span class="number">0</span>] - b.x[<span class="number">0</span>]) + sqr(a.x[<span class="number">1</span>] - b.x[<span class="number">1</span>]); &#125;</span><br><span class="line">    <span class="keyword">int</span> ch[M][<span class="number">2</span>], minn[M][<span class="number">2</span>], maxn[M][<span class="number">2</span>], cnt;</span><br><span class="line">    pnt*d[M];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp;x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i)</span><br><span class="line">            maxn[x][i] = minn[x][i] = d[x]-&gt;x[i];</span><br><span class="line">        <span class="keyword">if</span> (lc)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i)</span><br><span class="line">                maxn[x][i] = max(maxn[x][i], maxn[lc][i]), </span><br><span class="line">                minn[x][i] = min(minn[x][i], minn[lc][i]);</span><br><span class="line">        <span class="keyword">if</span> (rc)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i)</span><br><span class="line">                maxn[x][i] = max(maxn[x][i], maxn[rc][i]), </span><br><span class="line">                minn[x][i] = min(minn[x][i], minn[rc][i]);</span><br><span class="line">    &#125;<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (L &gt; R)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> x = ++cnt; </span><br><span class="line">        opt = k;</span><br><span class="line">        <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        nth_element(a + L, a + mid, a + R + <span class="number">1</span>, cmp);</span><br><span class="line">        d[x] = &amp;a[mid];</span><br><span class="line">        lc = build(L, mid - <span class="number">1</span>, k ^ <span class="number">1</span>), rc = build(mid + <span class="number">1</span>, R, k ^ <span class="number">1</span>);</span><br><span class="line">        pushup(x);</span><br><span class="line">    &#125;<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">mindis</span><span class="params">(pnt&amp;a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sqr(max(a.x[<span class="number">0</span>]-maxn[b][<span class="number">0</span>],<span class="number">0</span>)+max(minn[b][<span class="number">0</span>]-a.x[<span class="number">0</span>],<span class="number">0</span>))+sqr(max(a.x[<span class="number">1</span>]-maxn[b][<span class="number">1</span>],<span class="number">0</span>)+max(minn[b][<span class="number">1</span>]-a.x[<span class="number">1</span>],<span class="number">0</span>));</span><br><span class="line">    &#125;<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">maxdis</span><span class="params">(pnt&amp;a, <span class="keyword">int</span> b)</span> </span>&#123;<span class="comment">//最远距离</span></span><br><span class="line">        <span class="keyword">return</span> max(sqr(maxn[b][<span class="number">0</span>] - a.x[<span class="number">0</span>]), sqr(minn[b][<span class="number">0</span>] - a.x[<span class="number">0</span>])) + max(sqr(maxn[b][<span class="number">1</span>] - a.x[<span class="number">1</span>]), sqr(minn[b][<span class="number">1</span>] - a.x[<span class="number">1</span>]));</span><br><span class="line">     &#125;<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">kqueryMax</span><span class="params">(<span class="keyword">int</span> x, pnt&amp;O)</span> </span>&#123;<span class="comment">//k远点对查询</span></span><br><span class="line">         <span class="keyword">if</span>(!x)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> dl = -inf, dr = -inf;</span><br><span class="line">     	<span class="keyword">if</span> (lc)dl = maxdis(O, lc);</span><br><span class="line">        <span class="keyword">if</span> (rc)dr = maxdis(O, rc);</span><br><span class="line">        <span class="keyword">if</span> (d[x] != &amp;O) &#123;</span><br><span class="line">            <span class="keyword">int</span> dis = f(*d[x], O);</span><br><span class="line">            <span class="keyword">if</span> (q.top().dis &lt; dis)</span><br><span class="line">                q.pop(), q.push(dis);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dl &gt; dr) &#123; </span><br><span class="line">            <span class="keyword">if</span> (q.top().dis &lt; dl)kqueryMax(lc, O); </span><br><span class="line">            <span class="keyword">if</span> (q.top().dis &lt; dr)kqueryMax(rc, O); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; </span><br><span class="line">            <span class="keyword">if</span> (q.top().dis &lt; dr)kqueryMax(rc, O); </span><br><span class="line">            <span class="keyword">if</span> (q.top().dis &lt; dl)kqueryMax(lc, O); </span><br><span class="line">        &#125;</span><br><span class="line">     &#125;<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">queryMin</span><span class="params">(<span class="keyword">int</span> x, pnt&amp;O)</span> </span>&#123;<span class="comment">//最近距离</span></span><br><span class="line">         <span class="keyword">if</span> (!x)<span class="keyword">return</span>;</span><br><span class="line">         <span class="keyword">int</span> dl = inf, dr = inf;</span><br><span class="line">         <span class="keyword">if</span> (lc)dl = mindis(O, lc);</span><br><span class="line">         <span class="keyword">if</span> (rc)dr = mindis(O, rc);</span><br><span class="line">         <span class="keyword">if</span> (d[x] != &amp;O)<span class="comment">//不是相同的点</span></span><br><span class="line">             ans = min(ans, f(*d[x], O));</span><br><span class="line">         <span class="keyword">if</span> (dl &lt; dr) &#123;</span><br><span class="line">             <span class="keyword">if</span> (dl &lt; ans)queryMin(lc, O);</span><br><span class="line">             <span class="keyword">if</span> (dr &lt; ans)queryMin(rc, O);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="keyword">if</span> (dr &lt; ans)queryMin(rc, O);</span><br><span class="line">             <span class="keyword">if</span> (dl &lt; ans)queryMin(lc, O);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">queryMax</span><span class="params">(<span class="keyword">int</span> x, pnt&amp; O)</span> </span>&#123;<span class="comment">//最远距离</span></span><br><span class="line">         <span class="keyword">if</span> (!x)<span class="keyword">return</span>;</span><br><span class="line">         <span class="keyword">int</span> dl = -inf, dr = -inf;</span><br><span class="line">         <span class="keyword">if</span> (lc)dl = maxdis(O, lc);</span><br><span class="line">         <span class="keyword">if</span> (rc)dr = maxdis(O, rc);</span><br><span class="line">         <span class="keyword">if</span> (d[x] != &amp;O)<span class="comment">//不是相同的点</span></span><br><span class="line">             ans = max(ans, f(*d[x], O));</span><br><span class="line">         <span class="keyword">if</span> (dl &gt; dr) &#123;</span><br><span class="line">             <span class="keyword">if</span> (ans &lt; dl)queryMax(lc, O);</span><br><span class="line">             <span class="keyword">if</span> (ans &lt; dr)queryMax(rc, O);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="keyword">if</span> (ans &lt; dr)queryMax(rc, O);</span><br><span class="line">             <span class="keyword">if</span> (ans &lt; dl)queryMax(lc, O);</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> lc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> rc </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意事项：</p>
<p>1.这是int类型的点，坐标是double的话改一下即可</p>
<p>2.单次查询复杂度最坏是O(n)</p>
<p>3.k远点对需要现在最小堆丢入2k个 0，k近点对即丢入2k个inf</p>
<h2 id="3-字符串"><a href="#3-字符串" class="headerlink" title="3.字符串"></a>3.字符串</h2><h3 id="3-1-KMP"><a href="#3-1-KMP" class="headerlink" title="3.1 KMP"></a>3.1 KMP</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*---KMP---*/</span></span><br><span class="line"><span class="keyword">namespace</span> KMP &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span> + <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> nxt[N],n;</span><br><span class="line">    <span class="keyword">char</span> s[N];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">getnxt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">-1</span>;</span><br><span class="line">        nxt[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span>(j==<span class="number">-1</span>||s[i]==s[j])</span><br><span class="line">                nxt[++i]=++j;</span><br><span class="line">            <span class="keyword">else</span> j=nxt[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">KMP</span><span class="params">(<span class="keyword">char</span>* g, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; n &amp;&amp; i &lt; m) &#123;</span><br><span class="line">            <span class="keyword">if</span>(j==<span class="number">-1</span>||s[j]==g[i])</span><br><span class="line">                ++i,++j;</span><br><span class="line">            <span class="keyword">else</span> j=nxt[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-SA"><a href="#3-2-SA" class="headerlink" title="3.2 SA"></a>3.2 SA</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*---SA后缀数组---*/</span></span><br><span class="line"><span class="keyword">namespace</span> SA &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span> + <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> tax[N], sa[N], rk[N], tp[N];</span><br><span class="line">    <span class="keyword">int</span> h[N], bit[N], s[<span class="number">30</span>];</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">int</span> Min[N][<span class="number">19</span>];</span><br><span class="line">    <span class="comment">//h为height数组,Min用于RMQ</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;<span class="comment">//预处理 </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)bit[i] = bit[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        s[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= bit[n]; ++i)s[i] = s[i - <span class="number">1</span>] &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">qsort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="built_in">memset</span>(tax + <span class="number">1</span>, <span class="number">0</span>, m &lt;&lt; <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i)++tax[rk[i]];</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; ++i)tax[i] += tax[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (i = n; i; --i)sa[tax[rk[tp[i]]]--] = tp[i];</span><br><span class="line">    &#125;<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">suffix_sort</span><span class="params">(<span class="keyword">register</span> <span class="keyword">char</span>* s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i, j, p;</span><br><span class="line">        n = <span class="built_in">strlen</span>(s + <span class="number">1</span>), m = <span class="number">26</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i)rk[i] = s[i] - <span class="string">&#x27;a&#x27;</span>, tp[i] = i;</span><br><span class="line">        qsort();</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>, p = <span class="number">0</span>; p &lt; n; m = p, i &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            p = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= i; ++j)tp[++p] = n - i + j;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n; ++j)<span class="keyword">if</span> (sa[j] &gt; i)tp[++p] = sa[j] - i;</span><br><span class="line">            qsort(), swap(tp, rk);</span><br><span class="line">            rk[sa[<span class="number">1</span>]] = p = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">2</span>; j &lt;= n; ++j)</span><br><span class="line">                rk[sa[j]] = (tp[sa[j]] == tp[sa[j - <span class="number">1</span>]] &amp;&amp; tp[sa[j] + i] == tp[sa[j - <span class="number">1</span>] + i]) ? p : ++p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">register</span> <span class="keyword">char</span>* s)</span> </span>&#123;</span><br><span class="line">        suffix_sort(s);</span><br><span class="line">        <span class="keyword">int</span> i, j, k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (k)--k;</span><br><span class="line">            j = sa[rk[i] - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">while</span> (s[i + k] == s[j + k])++k;</span><br><span class="line">            h[rk[i]] = k;</span><br><span class="line">        &#125;<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i)Min[i][<span class="number">0</span>] = h[i];</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= bit[n]; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> p = s[j - <span class="number">1</span>], q = s[j];</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n - q + <span class="number">1</span>; ++i)</span><br><span class="line">                Min[i][j] = min(Min[i][j - <span class="number">1</span>], Min[i + p][j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-Manacher"><a href="#3-3-Manacher" class="headerlink" title="3.3 Manacher"></a>3.3 Manacher</h3><p>求出一个字符串每个位置的最长回文子串</p>
<p>$p[i]$表示从$i$ 向两侧延伸（当然要保证两侧对应位置相等）的最大长度。</p>
<p>为了处理方便，我们把原串每两个字符之间加一个（不包含在原串中的）<code>#</code>，开头加一个 <code>$</code>。</p>
<p>这样得到的回文串长度就保证是奇数了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Manacher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mx=<span class="number">0</span>,id;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;n ; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(mx&gt;i)p[i]=min(p[id*<span class="number">2</span>-i],p[id]+id-i);</span><br><span class="line">        <span class="keyword">else</span> p[i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=p[i]&amp;&amp;s[i+p[i]]==s[i-p[i]])++p[i];</span><br><span class="line">        <span class="keyword">if</span> (p[i] + i &gt; mx) &#123;</span><br><span class="line">            mx=p[i]+i;</span><br><span class="line">            id=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-随机化"><a href="#4-随机化" class="headerlink" title="4.随机化"></a>4.随机化</h2><h3 id="4-1-随机数"><a href="#4-1-随机数" class="headerlink" title="4.1 随机数"></a>4.1 随机数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"><span class="function">mt19937 <span class="title">mt_rand</span><span class="params">(time(<span class="number">0</span>))</span></span>;</span><br><span class="line">mt_rand();</span><br></pre></td></tr></table></figure>
<h3 id="4-2-模拟退火"><a href="#4-2-模拟退火" class="headerlink" title="4.2 模拟退火"></a>4.2 模拟退火</h3><p>对于答案更优的就接受，对于答案更劣的概率接受</p>
<p>假设当前温度为Temp，则接受的概率为$e^{\frac{\Delta f}{Temp}}(\Delta f&lt;0)$</p>
<p>其中有几个需要注意的点：</p>
<ul>
<li>初始点的选取对算法结果有一定的影响，最好是多次运行对结果进行综合判断。</li>
<li>在算法运行初期，温度下降快，避免接受过多的差结果。当运行时间增加，温度下降减缓，以便于更快稳定结果。</li>
<li>当迭代次数增加到一定次数时，结果可能已经达到稳定，但是距离算法结束还有一段时间。在设计程序时应该加入适当的输出条件，满足输出条件即可结束程序。</li>
</ul>
<p>降温可以每次乘以一个$tmp,tmp\in [0.95,0.99]$</p>
<p>或者自定义温度函数以使得算法更优。</p>
<p>（模拟退火乱搞过了ECFinal题）</p>
<h2 id="5-动态规划"><a href="#5-动态规划" class="headerlink" title="5.动态规划"></a>5.动态规划</h2><h3 id="5-1-多重背包"><a href="#5-1-多重背包" class="headerlink" title="5.1 多重背包"></a>5.1 多重背包</h3><p>用二进制分组优化</p>
<p>例如：</p>
<ul>
<li>6=1+2+3</li>
<li>8=1+2+4+1</li>
<li>18=1+2+4+8+3</li>
<li>31=1+2+4+8+16</li>
</ul>
<p>对于$k_i+1$不是2的整次幂，最后需要添加一个$k_i-2^{\lfloor log_2(k_i+1)\rfloor}+1$的物品</p>
<p>拆分后用01背包做即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">  <span class="keyword">int</span> c = <span class="number">1</span>, p, h, k;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; p &gt;&gt; h &gt;&gt; k;</span><br><span class="line">  <span class="keyword">while</span> (k - c &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    k -= c;</span><br><span class="line">    <span class="built_in">list</span>[++index].w = c * p;</span><br><span class="line">    <span class="built_in">list</span>[index].v = c * h;</span><br><span class="line">    c *= <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">list</span>[++index].w = p * k;</span><br><span class="line">  <span class="built_in">list</span>[index].v = h * k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-2-混合背包"><a href="#5-2-混合背包" class="headerlink" title="5.2 混合背包"></a>5.2 混合背包</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (循环物品种类) &#123;</span><br><span class="line">  <span class="keyword">if</span> (是 <span class="number">0</span> - <span class="number">1</span> 背包)</span><br><span class="line">    套用 <span class="number">0</span> - <span class="number">1</span> 背包代码;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (是完全背包)</span><br><span class="line">    套用完全背包代码;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (是多重背包)</span><br><span class="line">    套用多重背包代码;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>01背包是从大到小更新，完全背包从小到大更新，多重背包转化为01背包。</p>
<h3 id="5-3-二维费用背包"><a href="#5-3-二维费用背包" class="headerlink" title="5.3 二维费用背包"></a>5.3 二维费用背包</h3><p>多开一维进行转移即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &gt;= mi; i--)    <span class="comment">// 对经费进行一层枚举</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = t; j &gt;= ti; j--)  <span class="comment">// 对时间进行一层枚举</span></span><br><span class="line">      dp[i][j] = max(dp[i][j], dp[i - mi][j - ti] + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-4-分组背包"><a href="#5-4-分组背包" class="headerlink" title="5.4 分组背包"></a>5.4 分组背包</h3><p>所谓分组背包，就是将物品分组，每组的物品相互冲突，最多只能选一个物品放进去。</p>
<p>这种题怎么想呢？其实是从「在所有物品中选择一件」变成了「从当前组中选择一件」，于是就对每一组进行一次 0-1 背包就可以了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= ts; k++)          <span class="comment">// 循环每一组</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &gt;= <span class="number">0</span>; i--)         <span class="comment">// 循环背包容量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt[k]; j++)  <span class="comment">// 循环该组的每一个物品</span></span><br><span class="line">      <span class="keyword">if</span> (i &gt;= w[t[k][j]])</span><br><span class="line">        dp[i] = max(dp[i],dp[i - w[t[k][j]]] + c[t[k][j]]);  <span class="comment">// 像0-1背包一样状态转移</span></span><br></pre></td></tr></table></figure>
<p>即对于每一组只能取0/1件，因此从大到小枚举背包容量</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
