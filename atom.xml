<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>个人学习记录</title>
  
  <subtitle>Explosion!</subtitle>
  <link href="https://wjr-z.com/atom.xml" rel="self"/>
  
  <link href="https://wjr-z.com/"/>
  <updated>2021-08-17T11:41:37.946Z</updated>
  <id>https://wjr-z.com/</id>
  
  <author>
    <name>wjr</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Gym - 101086C Everything</title>
    <link href="https://wjr-z.com/Gym-101086C-Everything/"/>
    <id>https://wjr-z.com/Gym-101086C-Everything/</id>
    <published>2021-08-17T11:31:58.000Z</published>
    <updated>2021-08-17T11:41:37.946Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定$n$​个字符串，询问每次查询每一个字符串最少需要操作数  </p><span id="more"></span><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>对于一个字符串，不妨考虑枚举对于其每一个前缀统计答案  </p><p>我们求出所有前缀为S的大于当前字符串的数目为suf，前缀为S的字符串的个数为size,则最小操作数为|S|+min(size-suf-1,suf+1)+1  </p><p>即输入|S|的操作数，第一次向下的操作  </p><p>然后有两种选择，一种是不断按down，一种是先按end，再不断按up，取min即可  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> T, n;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>, M = N * <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ch[M][<span class="number">26</span>], tot;</span><br><span class="line"><span class="keyword">int</span> siz[M];</span><br><span class="line"><span class="keyword">int</span> pos[N];</span><br><span class="line"><span class="keyword">int</span> dep[M];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i)</span><br><span class="line">        siz[i] = fa[i] = <span class="number">0</span>, <span class="built_in">memset</span>(ch[i], <span class="number">0</span>, <span class="keyword">sizeof</span>(ch[i]));</span><br><span class="line">    tot = <span class="number">1</span>;</span><br><span class="line">    pos[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> p = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!ch[x][p]) &#123;</span><br><span class="line">            ch[x][p] = ++tot;</span><br><span class="line">            fa[tot] = x;</span><br><span class="line">            dep[tot] = dep[x] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        x = ch[x][p];</span><br><span class="line">    &#125;</span><br><span class="line">    pos[++pos[<span class="number">0</span>]] = x;</span><br><span class="line">    siz[x] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//预处理出size</span></span><br><span class="line">    <span class="keyword">if</span> (!x)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) &#123;</span><br><span class="line">        dfs1(ch[x][i]);</span><br><span class="line">        siz[x] += siz[ch[x][i]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//向上跳</span></span><br><span class="line">    <span class="keyword">int</span> suf = siz[x] - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//pre表示该子树下小于该字符串的数目</span></span><br><span class="line">    <span class="comment">//suf表示大于该字符串的数目</span></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> pre = siz[x] - suf - <span class="number">1</span>;</span><br><span class="line">        ans = min(ans, dep[x] + min(pre, suf + <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">1</span>)<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> Fa = fa[x];</span><br><span class="line">        <span class="keyword">for</span> (p = <span class="number">0</span>; p &lt; <span class="number">26</span>; ++p)</span><br><span class="line">            <span class="keyword">if</span> (ch[Fa][p] == x)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = p + <span class="number">1</span>; i &lt; <span class="number">26</span>; ++i) &#123;</span><br><span class="line">            suf += siz[ch[Fa][i]];</span><br><span class="line">        &#125;</span><br><span class="line">        x = Fa;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        tot = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">            insert(s);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs1(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, query(pos[i]));</span><br><span class="line">        clear();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h3&gt;&lt;p&gt;给定$n$​个字符串，询问每次查询每一个字符串最少需要操作数  &lt;/p&gt;</summary>
    
    
    
    
    <category term="trie树" scheme="https://wjr-z.com/tags/trie%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>Gym - 102433J Interstellar Travel</title>
    <link href="https://wjr-z.com/Gym-102433J-Interstellar-Travel/"/>
    <id>https://wjr-z.com/Gym-102433J-Interstellar-Travel/</id>
    <published>2021-08-13T12:37:17.000Z</published>
    <updated>2021-08-13T12:45:44.449Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>给定$n$​个实数三元组$(t_i,s_i,a_i)$​，选定一个$a$，使得$\sum_{i=1}^{n}max(0,t_i-s_i*dist(a,a_i))$最大，其中$dist(a_i,a)=min(|a-a_i|,2\pi-|a-a_i| )$。  </p><p>数据范围：$n\leq 10^5,0&lt;t\leq 1000,0\leq s_i\leq1000,0\leq a_i&lt;2*\pi$</p><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>可以不用分段的方法，使用模拟退火可做。  </p><p>类似于<span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3Uub3JnL3Byb2JsZW1uZXcvc2hvdy9QMTMzNw==">平衡点<i class="fa fa-external-link-alt"></i></span>的做法  </p><p>我们定义初始delta为$\pi$，每次加$delta*rd,rd\in[-1,1]$  </p><p>每次使delta减少，例如每次乘0.99，当delta&lt;1e-8时退出循环  </p><p>此题不难想到一个贪心我们可以将所有的点表示为$(si<em>cos(a_i),s_i</em>sin(a_i))$，并且将所有的向量加起来，其合向量的方向作为为我们的初始向量  </p><p>代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> T[N],s[N],a[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">dist</span><span class="params">(<span class="keyword">double</span> angle1, <span class="keyword">double</span> angle2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> delta=<span class="built_in">fabs</span>(angle1-angle2);</span><br><span class="line">    <span class="keyword">return</span> min(delta,<span class="number">2</span>*PI-delta);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">calc</span><span class="params">(<span class="keyword">double</span> angle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        sum+=max(<span class="number">0.0</span>,T[i]-s[i]*dist(a[i],angle));</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"><span class="function">mt19937 <span class="title">mt_rand</span><span class="params">(time(<span class="literal">NULL</span>))</span></span>;</span><br><span class="line"><span class="function">uniform_real_distribution&lt;<span class="keyword">double</span>&gt; <span class="title">rd</span><span class="params">(<span class="number">-1.0</span>,<span class="number">1.0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">maintain</span><span class="params">(<span class="keyword">double</span> Angle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Angle&lt;<span class="number">0</span>)Angle+=<span class="number">2</span>*PI;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(Angle&gt;=<span class="number">2</span>*PI)Angle-=<span class="number">2</span>*PI;</span><br><span class="line">    <span class="keyword">return</span> Angle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">initAngle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> X=<span class="number">0</span>,Y=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        X+=<span class="built_in">cos</span>(a[i])*s[i]/n,Y+=<span class="built_in">sin</span>(a[i])*s[i]/n;</span><br><span class="line">    <span class="keyword">return</span> maintain(<span class="built_in">atan</span>(Y/X));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps=<span class="number">1e-8</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> delta=PI;</span><br><span class="line">    <span class="keyword">double</span> angle=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> ans=calc(angle);</span><br><span class="line">    <span class="keyword">int</span> step=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (delta&gt;eps) &#123;</span><br><span class="line">        <span class="keyword">double</span> RandAngle=maintain(angle+delta*rd(mt_rand));</span><br><span class="line">        <span class="keyword">double</span> RandAns=calc(RandAngle);</span><br><span class="line">        <span class="keyword">if</span> (RandAns &gt; ans) &#123;</span><br><span class="line">            angle=RandAngle;</span><br><span class="line">            ans=RandAns;</span><br><span class="line">        &#125;</span><br><span class="line">        delta*=<span class="number">0.99</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lf%lf%lf&quot;</span>,&amp;T[i],&amp;s[i],&amp;a[i]);</span><br><span class="line">    solve();</span><br><span class="line">    <span class="keyword">double</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;++i)</span><br><span class="line">        ans=max(ans,solve());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.10f\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="模拟退火" scheme="https://wjr-z.com/tags/%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB/"/>
    
  </entry>
  
  <entry>
    <title>曼哈顿距离转切比雪夫距离</title>
    <link href="https://wjr-z.com/%E6%9B%BC%E5%93%88%E9%A1%BF%E8%B7%9D%E7%A6%BB%E8%BD%AC%E5%88%87%E6%AF%94%E9%9B%AA%E5%A4%AB%E8%B7%9D%E7%A6%BB/"/>
    <id>https://wjr-z.com/%E6%9B%BC%E5%93%88%E9%A1%BF%E8%B7%9D%E7%A6%BB%E8%BD%AC%E5%88%87%E6%AF%94%E9%9B%AA%E5%A4%AB%E8%B7%9D%E7%A6%BB/</id>
    <published>2021-07-21T08:15:24.000Z</published>
    <updated>2021-07-21T08:29:07.155Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>设第$i$个点坐标为$(x_i,y_i)$</p><h3 id="曼哈顿距离："><a href="#曼哈顿距离：" class="headerlink" title="曼哈顿距离："></a>曼哈顿距离：</h3><script type="math/tex; mode=display">|x_i-x_j|+|y_i-y_j|</script><h3 id="切比雪夫距离："><a href="#切比雪夫距离：" class="headerlink" title="切比雪夫距离："></a>切比雪夫距离：</h3><script type="math/tex; mode=display">max(|x_i-x_j|,|y_i-y_j|)</script><p>曼哈顿距离可以和切比雪夫距离互相转化！  </p><p>将每个点从$(x_i,y_i)$变为$(x_i+y_i,x_i-y_i)$即可将求曼哈顿距离转为求切比雪夫距离。  </p><span id="more"></span><p>曼哈顿距离又可以表示为  </p><p>$max(\pm(x_i-x_j)\pm(y_i-y_j))$</p><p>转化后的切比雪夫距离可以表示为  </p><p>$max(|x_i-x_j|\pm|y_i-y_j|)$</p><p>两者实际上是等价的。  </p><h3 id="实际应用："><a href="#实际应用：" class="headerlink" title="实际应用："></a>实际应用：</h3><p>求与某一个点曼哈顿距离小于等于C的点数，如果问题可以离线，则可以转换为求切比雪夫距离小于等于C的点数，此时需要求一个矩形内的点数，有很多方式都可以实现。</p><p>例题：<span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDI5MDY=">P2906 [USACO08OPEN]Cow Neighborhoods G - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)<i class="fa fa-external-link-alt"></i></span></p><p>此题只用将x排序后，维护y即可。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;设第$i$个点坐标为$(x_i,y_i)$&lt;/p&gt;
&lt;h3 id=&quot;曼哈顿距离：&quot;&gt;&lt;a href=&quot;#曼哈顿距离：&quot; class=&quot;headerlink&quot; title=&quot;曼哈顿距离：&quot;&gt;&lt;/a&gt;曼哈顿距离：&lt;/h3&gt;&lt;script type=&quot;math/tex; mode=display&quot;&gt;
|x_i-x_j|+|y_i-y_j|&lt;/script&gt;&lt;h3 id=&quot;切比雪夫距离：&quot;&gt;&lt;a href=&quot;#切比雪夫距离：&quot; class=&quot;headerlink&quot; title=&quot;切比雪夫距离：&quot;&gt;&lt;/a&gt;切比雪夫距离：&lt;/h3&gt;&lt;script type=&quot;math/tex; mode=display&quot;&gt;
max(|x_i-x_j|,|y_i-y_j|)&lt;/script&gt;&lt;p&gt;曼哈顿距离可以和切比雪夫距离互相转化！  &lt;/p&gt;
&lt;p&gt;将每个点从$(x_i,y_i)$变为$(x_i+y_i,x_i-y_i)$即可将求曼哈顿距离转为求切比雪夫距离。  &lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>2020 ICPC Asia East Continent Final J.Circle 题解</title>
    <link href="https://wjr-z.com/2020-ICPC-Asia-East-Continent-Final-J-Circle-%E9%A2%98%E8%A7%A3/"/>
    <id>https://wjr-z.com/2020-ICPC-Asia-East-Continent-Final-J-Circle-%E9%A2%98%E8%A7%A3/</id>
    <published>2021-07-10T01:49:10.000Z</published>
    <updated>2021-08-04T11:57:36.456Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>给出$n$个半径相同的圆，求出$n$个圆的公共面积。</p><span id="more"></span><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>将每个圆按照相同方法近似成正$C$边形，然后对于$C*n$条边进行半平面交，但很显然这样做$C$取大了会TLE，取小了会精度不够WA。  </p><p>我们取三角形上$C$个点，这$C$个点均匀分布，第$i$个点$P_i$为<script type="math/tex">(r*cos(\frac{2*\pi*i}{C}), r * sin (\frac{2*\pi*i}{C})) , i\in [0,C)</script>，第$i$条线段即<script type="math/tex">\vec{p_{i}p_{i+1}},i\in [0,C)</script></p><p>这样对于每个圆上的第$i$条线段其极角相同，对于极角相同且直线也重合的两个圆，可以推出这条线段对于答案没有贡献（画个图很容易看出），可以不用考虑。  </p><p>则对于$n$个圆上的第$i$条线段，因为极角均相同，实际上只有一个圆的第$i$条线段可以对答案产生贡献。  </p><p>因此实际上$n$个圆总共只用取出$C$条线段均可。    </p><p>假设有一条线段是$(0,1)$，那么这条线段很显然是圆心坐标最小的圆的最右侧最优，如果是$(0,-1)$，是圆心左边最大的圆的左侧最优。  </p><p>题目还好心的给了我们圆心的凸包，因为半径相同，所以可以将问题转化为比较圆心的相对位置（如果半径不同，则比较麻烦，但我感觉还是可以用数据结构进行查找）    </p><p>第一条线段我们先找到一个圆心坐标最小的圆$t$，我们设$vec=\vec{O_{t+1}O{t}}$，如果$\vec{p_{i}p_{i+1}}$在$vec$左侧，说明下一个圆更优，直到找到一个最优的圆。就有点像是旋转卡壳。可以画两个圆理解一下，其实很简单。    </p><p>然后就可以半平面交求面积了。    </p><p>不过因为我们用了线段去切圆，所以最后需要加一些弓形面积进行矫正，可以直接求出答案多边形边数乘以每一个小弓形面积（均相同）或者对于答案凸包的每条线段求出小弓形面积（不一定相同），$C$取4000就可以过这题。  </p><p>不过这题因为可能出现测试点很多，$n$很小的情况，此时固定取点并不太好，可以使用暴力。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">double</span> r;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> C = <span class="number">4000</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vec</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">    vec() &#123;&#125;</span><br><span class="line">    vec(<span class="keyword">double</span> a, <span class="keyword">double</span> b) &#123; x = a, y = b; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">len</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">sqrt</span>(dot(*<span class="keyword">this</span>, *<span class="keyword">this</span>)); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">double</span> <span class="title">dot</span><span class="params">(vec a, vec b)</span> </span>&#123; <span class="keyword">return</span> a.x * b.x + a.y * b.y; &#125;</span><br><span class="line">    <span class="function">vec <span class="title">rotate</span><span class="params">(<span class="keyword">double</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vec(x * <span class="built_in">cos</span>(a) - y * <span class="built_in">sin</span>(a), x * <span class="built_in">sin</span>(a) + y * <span class="built_in">cos</span>(a));</span><br><span class="line">    &#125;</span><br><span class="line">    vec <span class="keyword">operator</span>-(vec a) &#123; <span class="keyword">return</span> vec(x - a.x, y - a.y); &#125;</span><br><span class="line">    vec <span class="keyword">operator</span>+(vec a) &#123; <span class="keyword">return</span> vec(x + a.x, y + a.y); &#125;</span><br><span class="line">    vec <span class="keyword">operator</span>*(<span class="keyword">double</span> a) &#123; <span class="keyword">return</span> vec(x * a, y * a); &#125;</span><br><span class="line">    vec <span class="keyword">operator</span>/(<span class="keyword">double</span> a) &#123; <span class="keyword">return</span> vec(x / a, y / a); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">ang</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">atan2</span>(y, x); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">double</span> <span class="title">cross</span><span class="params">(vec a, vec b)</span> </span>&#123; <span class="keyword">return</span> a.x * b.y - a.y * b.x; &#125;</span><br><span class="line">&#125; p[C + <span class="number">10</span>];</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">line</span> &#123;</span></span><br><span class="line">    vec s, e;</span><br><span class="line">    <span class="keyword">double</span> ang;</span><br><span class="line">    line() &#123;&#125;</span><br><span class="line">    line(vec a, vec b) &#123; s = a, e = b; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> vec <span class="title">inter</span><span class="params">(line a, line b)</span> </span>&#123;  <span class="comment">// 直线交点解方程</span></span><br><span class="line">        <span class="keyword">double</span> s1 = cross(a.e - b.s, a.s - b.s);</span><br><span class="line">        <span class="keyword">double</span> s2 = cross(b.e - a.e, a.s - a.e);</span><br><span class="line">        <span class="keyword">return</span> (b.s * s2 + b.e * s1) / (s1 + s2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">bool</span> <span class="title">cut</span><span class="params">(line a, line b, line c)</span> </span>&#123;  <span class="comment">// 若ab交点在c右侧则删除</span></span><br><span class="line">        <span class="keyword">return</span> cross(c.e - c.s, inter(a, b) - c.s) &lt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; l[C + <span class="number">10</span>];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nxt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> (x + <span class="number">1</span>) % n; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">half_plane</span><span class="params">(line* l, vec* p, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = n;</span><br><span class="line">    <span class="keyword">int</span> head = <span class="number">0</span>, tail = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (head &lt; tail &amp;&amp; cut(l[tail - <span class="number">1</span>], l[tail], l[i]))</span><br><span class="line">            tail--;  <span class="comment">// i对上一个的影响</span></span><br><span class="line">        <span class="keyword">while</span> (head &lt; tail &amp;&amp; cut(l[head], l[head + <span class="number">1</span>], l[i]))</span><br><span class="line">            head++;  <span class="comment">// i对第一个的影响</span></span><br><span class="line">        l[++tail] = l[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (head &lt; tail &amp;&amp; cut(l[tail - <span class="number">1</span>], l[tail], l[head]))</span><br><span class="line">        tail--;  <span class="comment">//删除最后多加的边</span></span><br><span class="line">    l[++tail] = l[head];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tail - head; i++) &#123;</span><br><span class="line">        p[i] = inter(l[head + i], l[head + i + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tail - head;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">size</span><span class="params">(vec* p, <span class="keyword">int</span> n)</span> </span>&#123;  <span class="comment">//多边形边面积s</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> ans = <span class="number">0</span>;</span><br><span class="line">    p[n] = p[<span class="number">0</span>], p[n + <span class="number">1</span>] = p[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) ans += p[i + <span class="number">1</span>].y * (p[i].x - p[i + <span class="number">2</span>].x);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fabs</span>(ans / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这下面是暴力</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">100000007</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Ty&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Ty <span class="title">sqr</span><span class="params">(<span class="keyword">const</span> Ty&amp; x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">double</span> area[N];</span><br><span class="line"><span class="keyword">double</span> R;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dcmp</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; -eps)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> x &gt; eps;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> f = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = <span class="literal">false</span>;</span><br><span class="line">        c = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (c - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        c = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f ? x : -x;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cp</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y, r, angle;</span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line">    cp() &#123;&#125;</span><br><span class="line">    cp(<span class="keyword">const</span> <span class="keyword">double</span>&amp; xx, <span class="keyword">const</span> <span class="keyword">double</span>&amp; yy, <span class="keyword">const</span> <span class="keyword">double</span>&amp; ang = <span class="number">0</span>, <span class="keyword">int</span> t = <span class="number">0</span>) &#123;</span><br><span class="line">        x = xx;</span><br><span class="line">        y = yy;</span><br><span class="line">        angle = ang;</span><br><span class="line">        d = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        x = read();</span><br><span class="line">        y = read();</span><br><span class="line"> </span><br><span class="line">        r = R;</span><br><span class="line">        d = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; cir[N], tp[N * <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dis</span><span class="params">(<span class="keyword">const</span> cp&amp; a, <span class="keyword">const</span> cp&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(sqr(a.x - b.x) + sqr(a.y - b.y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cross</span><span class="params">(<span class="keyword">const</span> cp&amp; p0, <span class="keyword">const</span> cp&amp; p1, <span class="keyword">const</span> cp&amp; p2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (p1.x - p0.x) * (p2.y - p0.y) - (p1.y - p0.y) * (p2.x - p0.x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CirCrossCir</span><span class="params">(<span class="keyword">const</span> cp&amp; p1, <span class="keyword">const</span> <span class="keyword">double</span>&amp; r1, <span class="keyword">const</span> cp&amp; p2, <span class="keyword">const</span> <span class="keyword">double</span>&amp; r2,</span></span></span><br><span class="line"><span class="function"><span class="params">                cp&amp; cp1, cp&amp; cp2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> mx = p2.x - p1.x, sx = p2.x + p1.x, mx2 = mx * mx;</span><br><span class="line">    <span class="keyword">double</span> my = p2.y - p1.y, sy = p2.y + p1.y, my2 = my * my;</span><br><span class="line">    <span class="keyword">double</span> sq = mx2 + my2, d = -(sq - sqr(r1 - r2)) * (sq - sqr(r1 + r2));</span><br><span class="line">    <span class="keyword">if</span> (d + eps &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    d = d &lt; eps ? <span class="number">0</span> : <span class="built_in">sqrt</span>(d);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">double</span> x = mx * ((r1 + r2) * (r1 - r2) + mx * sx) + sx * my2;</span><br><span class="line">    <span class="keyword">double</span> y = my * ((r1 + r2) * (r1 - r2) + my * sy) + sy * mx2;</span><br><span class="line">    <span class="keyword">double</span> dx = mx * d, dy = my * d;</span><br><span class="line">    sq *= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">double</span> g = <span class="number">1.0</span> / sq;</span><br><span class="line">    cp1.x = (x - dy) * g;</span><br><span class="line">    cp1.y = (y + dx) * g;</span><br><span class="line">    cp2.x = (x + dy) * g;</span><br><span class="line">    cp2.y = (y - dx) * g;</span><br><span class="line">    <span class="keyword">return</span> d &gt; eps ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">circmp</span><span class="params">(<span class="keyword">const</span> cp&amp; u, <span class="keyword">const</span> cp&amp; v)</span> </span>&#123; <span class="keyword">return</span> dcmp(u.r - v.r) &lt; <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> cp&amp; u, <span class="keyword">const</span> cp&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dcmp(u.angle - v.angle)) <span class="keyword">return</span> u.angle &lt; v.angle;</span><br><span class="line">    <span class="keyword">return</span> u.d &gt; v.d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">calc</span><span class="params">(cp cir, cp cp1, cp cp2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> ans = (cp2.angle - cp1.angle) * sqr(cir.r) - cross(cir, cp1, cp2) +</span><br><span class="line">                 cross(cp(<span class="number">0</span>, <span class="number">0</span>), cp1, cp2);</span><br><span class="line">    <span class="keyword">return</span> ans * <span class="number">0.5</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CirUnion</span><span class="params">(cp cir[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    cp cp1, cp2;</span><br><span class="line">    sort(cir, cir + n, circmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j)</span><br><span class="line">            <span class="keyword">if</span> (dcmp(dis(cir[i], cir[j]) + cir[i].r - cir[j].r) &lt;= <span class="number">0</span>)</span><br><span class="line">                cir[i].d++;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> tn = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == j) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (CirCrossCir(cir[i], cir[i].r, cir[j], cir[j].r, cp2, cp1) &lt; <span class="number">2</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            cp1.angle = <span class="built_in">atan2</span>(cp1.y - cir[i].y, cp1.x - cir[i].x);</span><br><span class="line">            cp2.angle = <span class="built_in">atan2</span>(cp2.y - cir[i].y, cp2.x - cir[i].x);</span><br><span class="line">            cp1.d = <span class="number">1</span>;</span><br><span class="line">            tp[tn++] = cp1;</span><br><span class="line">            cp2.d = <span class="number">-1</span>;</span><br><span class="line">            tp[tn++] = cp2;</span><br><span class="line">            <span class="keyword">if</span> (dcmp(cp1.angle - cp2.angle) &gt; <span class="number">0</span>) cnt++;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        tp[tn++] = cp(cir[i].x - cir[i].r, cir[i].y, PI, -cnt);</span><br><span class="line">        tp[tn++] = cp(cir[i].x - cir[i].r, cir[i].y, -PI, cnt);</span><br><span class="line">        sort(tp, tp + tn, cmp);</span><br><span class="line">        <span class="keyword">int</span> p, s = cir[i].d + tp[<span class="number">0</span>].d;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; tn; ++j) &#123;</span><br><span class="line">            p = s;</span><br><span class="line">            s += tp[j].d;</span><br><span class="line">            area[p] += calc(cir[i], tp[j - <span class="number">1</span>], tp[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    R = r;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) cir[i].get();</span><br><span class="line">    <span class="built_in">memset</span>(area, <span class="number">0</span>, <span class="keyword">sizeof</span>(area));</span><br><span class="line">    CirUnion(cir, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)  <span class="comment">//去掉重复计算的</span></span><br><span class="line">        area[i] -= area[i + <span class="number">1</span>];   <span class="comment">// area[i]为重叠了i次的面积</span></span><br><span class="line">    <span class="keyword">double</span> tot = <span class="number">0</span>;               <span class="comment">// tot 为总面积</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) tot += area[i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.11lf\n&quot;</span>, area[n]);</span><br><span class="line">    <span class="comment">// printf(&quot;%f\n&quot;, tot);  //这句就是求总面积</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以上是暴力</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%lf&quot;</span>, &amp;n, &amp;r);</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">40</span>) &#123;</span><br><span class="line">            solve();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>, tt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lf%lf&quot;</span>, &amp;p[i].x, &amp;p[i].y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p[i].x &lt; p[t].x || p[i].x == p[t].x &amp;&amp; p[i].y &lt; p[t].y) t = i;</span><br><span class="line">            <span class="comment">//初始选点</span></span><br><span class="line">        &#125;</span><br><span class="line">        tt = nxt(t);</span><br><span class="line">        <span class="keyword">double</span> theta = <span class="number">2</span> * pi / C;</span><br><span class="line">        <span class="keyword">double</span> tql = r * r / <span class="number">2</span> * (theta - <span class="built_in">sin</span>(theta));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; C; i++) &#123;</span><br><span class="line">            <span class="keyword">double</span> q = <span class="number">2</span> * pi * i / C;</span><br><span class="line">            vec x = vec(r * <span class="built_in">cos</span>(q), r * <span class="built_in">sin</span>(q));</span><br><span class="line">            vec y = x.rotate(theta);</span><br><span class="line">            <span class="keyword">while</span> (dcmp(cross(y - x, p[t] - p[tt])) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                t = tt;</span><br><span class="line">                tt = nxt(t);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//找到最优圆</span></span><br><span class="line"> </span><br><span class="line">            l[i] = line(x + p[t], y + p[t]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = half_plane(l, p, C);</span><br><span class="line">        <span class="keyword">double</span> ans = size(p, m);</span><br><span class="line">        <span class="keyword">if</span> (m &gt; <span class="number">2</span>)<span class="comment">//误差矫正</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                <span class="keyword">double</span> x = (p[i + <span class="number">1</span>] - p[i]).len();</span><br><span class="line">                <span class="keyword">double</span> y = <span class="built_in">asin</span>(x / (r * <span class="number">2</span>)) * <span class="number">2</span>;</span><br><span class="line">                ans += (y - <span class="built_in">sin</span>(y)) * r * r / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.12f\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;题意：&quot;&gt;&lt;a href=&quot;#题意：&quot; class=&quot;headerlink&quot; title=&quot;题意：&quot;&gt;&lt;/a&gt;题意：&lt;/h3&gt;&lt;p&gt;给出$n$个半径相同的圆，求出$n$个圆的公共面积。&lt;/p&gt;</summary>
    
    
    
    
    <category term="计算几何" scheme="https://wjr-z.com/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>大数进制转换</title>
    <link href="https://wjr-z.com/%E5%A4%A7%E6%95%B0%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/"/>
    <id>https://wjr-z.com/%E5%A4%A7%E6%95%B0%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/</id>
    <published>2021-07-04T01:20:12.000Z</published>
    <updated>2021-07-04T02:01:18.279Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>对于一个大数可以使用分治法+FFT做到$O(nlog^2n)$进行任意进制转换。</p><p>假设从$a$进制转换到$b$进制，设$x_i$表示待转换的数的第$i$位，共$n$位，设$s_i$表示转换后的数的第$i$位，共$m$位：  </p><p>则有$\sum_{i=0}^{n-1}x_i<em>a^i=\sum_{i=0}^{m-1}s_i</em>b^i$</p><p>不妨令$mid=\lfloor\frac{n}{2}\rfloor$，则有</p><script type="math/tex; mode=display">\sum_{i=0}^{mid-1}x_i*a^i+\sum_{i=mid}^{n-1}x_i*a^i=\sum_{i=0}^{m-1}s_i*b^i  \\\sum_{i=0}^{mid-1}x_i*a^i+a^{mid}*\sum_{i=mid}^{n-1}x_i*a^{i-mid}=\sum_{i=0}^{m-1}s_i*b^i</script><p>则只需要分别对于$[0,mid)$位和$[mid,n)$求出转换后的数$L,R$，然后在$b$进制下令$s=L+R*a^{mid}$即可。</p><p>对于长度小于某个阈值时应暴力计算。</p><p>复杂度分析：  </p><p>$f(n)=2<em>f(\frac{n}{2})+2</em>g(\frac{n}{2})$（其中$g(n)$为$n$位乘$n$位的时间复杂度，使用$FFT$时有$g(n)=nlogn$）</p><p>其中$2g(\frac{n}{2})$是求$a^{mid}和R*a^{mid}$的时间复杂度，对于$a^{mid}$其实可以预处理出来。</p><p>得出$f(n)=nlog^2n$</p><p>实际测得常数较小</p><p>在此附上已经封装好的大数类，包含10进制大数，2进制大数，二进制和十进制转化等。</p><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dqci16L0FsZ29yaXRobUFuZERhdGFTdHJ1Y3R1cmU=">https://github.com/wjr-z/AlgorithmAndDataStructure<i class="fa fa-external-link-alt"></i></span></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="大整数" scheme="https://wjr-z.com/tags/%E5%A4%A7%E6%95%B4%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>Problem Buyer</title>
    <link href="https://wjr-z.com/Problem-Buyer/"/>
    <id>https://wjr-z.com/Problem-Buyer/</id>
    <published>2021-06-12T04:17:48.000Z</published>
    <updated>2021-06-12T04:33:54.266Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>给定 $n$个题目，每个题目有一个难度范围$[a_i,b_i]$。你需要举办一场$m$个题目的比赛，其中第$i$题难度应该是$c_i$，若你选择的题目难度范围是$[A,B]且A\leq c_i \leq B$，则可以作为第$i$题。现在你需要买给定的$n$题中的$k$题，但是买到的题目是随机的，求出能保证可以举办比赛的最小的$k$。</p><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>看着很像是点覆盖之类的，不过又是要求任意$k$题可以构成比赛，因此考虑贪心。  </p><p>如果每道题的难度区间只会覆盖至多一个考题，设第$i$题被$d_i$个区间覆盖。最坏情况是第$i$题外的每一道题对应区间都被选了，然后我们第$i$题随意来一题即可，枚举所有的$i$并取max，所以答案$ans=max\{n-d_i+1\}$。</p><p>考虑一个区间可能覆盖多个点，那么我们将$c$从小到大排序，从左往右选择考题时，每次选出一题将符合这题的区间右端点最左的一道题去掉即可。可以证明，这样对于后面选择影响是最小的，会使得后面的$d_i$尽可能小，使得答案尽可能大。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt;&gt;q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> node&amp; other)<span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> l&lt;other.l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;a[N];</span><br><span class="line"><span class="keyword">int</span> c[N];</span><br><span class="line"><span class="keyword">int</span> T,n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> ii = <span class="number">1</span>; ii &lt;= T; ++ii) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a[i].l,&amp;a[i].r);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;c[i]);</span><br><span class="line">        sort(c+<span class="number">1</span>,c+<span class="number">1</span>+m);</span><br><span class="line">        sort(a+<span class="number">1</span>,a+<span class="number">1</span>+n);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())q.pop();</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>,j=<span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span>(j&lt;=n&amp;&amp;a[j].l&lt;=c[i])</span><br><span class="line">                q.push(a[j++].r);</span><br><span class="line">            <span class="keyword">while</span>(!q.empty()&amp;&amp;q.top()&lt;c[i])q.pop();</span><br><span class="line">            ans=max(ans,n-(<span class="keyword">int</span>)q.size()+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(!q.empty())</span><br><span class="line">                q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: &quot;</span>,ii);</span><br><span class="line">        <span class="keyword">if</span>(ans&lt;=n)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;IMPOSSIBLE!\n&quot;</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="贪心" scheme="https://wjr-z.com/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>第十八届浙江省大学生程序设计大赛F. Fair Distribution</title>
    <link href="https://wjr-z.com/%E7%AC%AC%E5%8D%81%E5%85%AB%E5%B1%8A%E6%B5%99%E6%B1%9F%E7%9C%81%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%A7%E8%B5%9BF-Fair-Distribution/"/>
    <id>https://wjr-z.com/%E7%AC%AC%E5%8D%81%E5%85%AB%E5%B1%8A%E6%B5%99%E6%B1%9F%E7%9C%81%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%A7%E8%B5%9BF-Fair-Distribution/</id>
    <published>2021-04-26T14:21:53.000Z</published>
    <updated>2021-04-26T14:32:55.106Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定T组询问，每次给出一个n，m </p><p>每次你可以让n减一或者m加一</p><p>问使得m是n的倍数最小步数</p><span id="more"></span><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>有趣的脑子题</p><p>我们枚举A，使得n变为A</p><p>让m变成kA</p><p>则有$k=\lceil\frac{m}{A}\rceil$</p><p>这是使得m变成kA最小的k</p><p>所以步数即为$n-A+\lceil\frac{m}{A}\rceil*A-m$</p><p>即$n-m+A*(\lceil\frac{m}{A}\rceil-1)$</p><p>我的写法是把A替换为k了（不替换的可以自己想怎么写，其实差不多）</p><p>因为$k=\lceil\frac{m}{A}\rceil$</p><p>所以$A=\lceil\frac{m}{k}\rceil$</p><p>然后变为$n-m+\lceil\frac{m}{k}\rceil*(k-1)$</p><p>这样的话对于相同的$\lceil\frac{m}{k}\rceil$只用求一个最小的k</p><p>然后这个的取值是$O(\sqrt{m})$的</p><p>就做完了</p><p>枚举不同的$\lceil\frac{m}{k}\rceil$可以用整除分块，不过其实二分也行的，跑的也还挺快</p><p>下面附上代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Floor</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n/m+(n%m!=<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMaxK</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L=k,R=m,mid,ans=L;</span><br><span class="line">    <span class="keyword">while</span> (L &lt;= R) &#123;</span><br><span class="line">        mid=L+R&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(Floor(m,mid)==Floor(m,k))ans=mid,L=mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> R=mid<span class="number">-1</span>;</span><br><span class="line">    &#125;<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">        <span class="keyword">int</span> K=Floor(m,n);</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">1e9</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = K; k &lt;= m; ++k) &#123;</span><br><span class="line">            ans=min(ans,Floor(m,k)*(k<span class="number">-1</span>));</span><br><span class="line">            k=getMaxK(k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans+n-m);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是超简单！</p>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h4&gt;&lt;p&gt;给定T组询问，每次给出一个n，m &lt;/p&gt;
&lt;p&gt;每次你可以让n减一或者m加一&lt;/p&gt;
&lt;p&gt;问使得m是n的倍数最小步数&lt;/p&gt;</summary>
    
    
    
    
    <category term="思维题" scheme="https://wjr-z.com/tags/%E6%80%9D%E7%BB%B4%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>2018-2019 ACM-ICPC EC Final I - Misunderstood … Missing</title>
    <link href="https://wjr-z.com/2018-2019-ACM-ICPC-EC-Final-I-Misunderstood-%E2%80%A6-Missing/"/>
    <id>https://wjr-z.com/2018-2019-ACM-ICPC-EC-Final-I-Misunderstood-%E2%80%A6-Missing/</id>
    <published>2021-04-10T13:00:33.000Z</published>
    <updated>2021-04-10T13:48:23.091Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这题正解是反着DP，不过我用模拟退火就过了。</p><p>因此分享下模拟退火做法</p><span id="more"></span><p>关于模拟退火的讲解可以看下<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vZmxhc2hodS9wLzg4ODQxMzIuaHRtbA==">这一篇博客<i class="fa fa-external-link-alt"></i></span></p><p>这题的话实际上就是很基础的模拟退火应用了</p><p>我令$k[i]$代表第$i$次是哪个操作</p><p>每次随机找到一个$x$，将$k[x]$改为一个随机数$y$（$1\leq y\leq 3$）</p><p>然后如果更优直接修改，如果更劣，则有一定概率接受，具体概率见那篇博客。</p><p>然后这样其实不太保险，因为还是可能陷入局部最优解，注意到这题$n$很小，所以我们可以在外层继续套循环</p><p>如果我们一次掉入了局部最优解，我们下一次开始重新模拟退火，就有可能跳出该局部最优解，跑个几千次还在局部最优解的概率就很低了。</p><p>对了，随机化最好用$mt_rand$，会快很多，并且更加随机。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">105</span>;</span><br><span class="line"><span class="keyword">int</span> a[N], b[N], c[N];</span><br><span class="line"><span class="keyword">int</span> k[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> A, D;</span><br><span class="line">    A = D = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        A += D;</span><br><span class="line">        <span class="keyword">switch</span> (k[i]) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:ans += A + a[i]; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:D += b[i]; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:A += c[i]; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ansk[N];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> tmp = <span class="number">0.99</span>, e = <span class="number">2.714</span>;</span><br><span class="line"><span class="keyword">double</span> R[<span class="number">1000</span>], temp[<span class="number">1000</span>];</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">qpow</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> s = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)s *= a;</span><br><span class="line">        a *= a;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> Maxd;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i)</span><br><span class="line">        Maxd |= (<span class="number">1u</span> &lt;&lt; i);</span><br><span class="line">    <span class="function">mt19937 <span class="title">mt_rand</span><span class="params">(time(<span class="number">0</span>))</span></span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    temp[<span class="number">1</span>] = <span class="number">1</span>; R[<span class="number">1</span>] = <span class="built_in">pow</span>(e, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">500</span>; ++i) &#123;</span><br><span class="line">        temp[i] = temp[i - <span class="number">1</span>] * tmp;</span><br><span class="line">        R[i] = <span class="built_in">pow</span>(e, <span class="number">-1.0</span> / temp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a[i], &amp;b[i], &amp;c[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)ansk[i] = k[i] = mt_rand() % <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> Mans = work();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> kase = <span class="number">1</span>; kase &lt;= <span class="number">15</span> * n; ++kase) &#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> ans = work();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> Case = <span class="number">1</span>; Case &lt;= <span class="number">5</span> * n; ++Case) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = mt_rand() % n + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> y = mt_rand() % <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> nowk = k[x];</span><br><span class="line">                <span class="keyword">if</span>(y==k[x])<span class="keyword">continue</span>;</span><br><span class="line">                k[x] = y;</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> kans = work();</span><br><span class="line">                <span class="keyword">if</span> (kans &gt;= ans)</span><br><span class="line">                    ans = kans;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">double</span> zz = qpow(R[Case], ans - kans);</span><br><span class="line">                    <span class="keyword">if</span> (mt_rand() &lt;= zz * Maxd) &#123;</span><br><span class="line">                        ans = kans;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> k[x] = nowk;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ans &gt; Mans)</span><br><span class="line">                Mans = ans, <span class="built_in">memcpy</span>(ansk, k, <span class="keyword">sizeof</span>(k));</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">memcpy</span>(k, ansk, <span class="keyword">sizeof</span>(k));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, Mans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数啥的都可以调调，如果求稳，就把循环调大点，如果速度慢了，求把循环调小点。</p><p>这个复杂度是$O(75*n^3)$</p><p>然后跑的还挺快，实际上把参数调小点，可以达到最快大概$O(12*n^3)$，不过就是正确率低了点。</p><p>这个代码正确率还挺高的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这题正解是反着DP，不过我用模拟退火就过了。&lt;/p&gt;
&lt;p&gt;因此分享下模拟退火做法&lt;/p&gt;</summary>
    
    
    
    
    <category term="ACM" scheme="https://wjr-z.com/tags/ACM/"/>
    
    <category term="模拟退火" scheme="https://wjr-z.com/tags/%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB/"/>
    
  </entry>
  
  <entry>
    <title>关于cin和cout</title>
    <link href="https://wjr-z.com/%E5%85%B3%E4%BA%8Ecin%E5%92%8Ccout/"/>
    <id>https://wjr-z.com/%E5%85%B3%E4%BA%8Ecin%E5%92%8Ccout/</id>
    <published>2021-04-05T09:58:12.000Z</published>
    <updated>2021-04-05T10:12:12.520Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在我ICPC 昆明赛区因为使用 cin 和 cout TLE一发后，我改成了scanf和printf，从 2s 的TLE变成了 267 ms …</p><p>然后我在赛后进行了一些测试</p><span id="more"></span><p>cin和cout是挺慢的，但我真没想到能差这么多，以至于比我的$O(nlogn)$算法还慢上几倍。</p><p><span class="exturl" data-url="aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL2NvbnRlc3QvMTI1NDgvTA==">测试题目<i class="fa fa-external-link-alt"></i></span></p><p>效率测试：</p><ol><li><p>scanf和printf</p><p><span class="exturl" data-url="aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL2NvbnRlc3Qvdmlldy1zdWJtaXNzaW9uP3N1Ym1pc3Npb25JZD00NzM4MzU5NQ==">测试代码<i class="fa fa-external-link-alt"></i></span></p><p>用时：267ms</p></li><li><p>cin和cout（不关闭流同步以及使用endl）</p><p><span class="exturl" data-url="aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL2NvbnRlc3Qvdmlldy1zdWJtaXNzaW9uP3N1Ym1pc3Npb25JZD00NzM4MzY2NQ==">测试代码<i class="fa fa-external-link-alt"></i></span></p><p>用时：2001 ms（TLE)</p></li><li><p>cin和cout（关闭流同步以及使用endl）</p><p><span class="exturl" data-url="aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL2NvbnRlc3Qvdmlldy1zdWJtaXNzaW9uP3N1Ym1pc3Npb25JZD00NzM4MzY5MA==">测试代码<i class="fa fa-external-link-alt"></i></span></p><p>用时：2001ms（TLE）</p></li><li><p>cin和cout(不关闭流同步和不使用endl)</p><p><span class="exturl" data-url="aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL2NvbnRlc3Qvdmlldy1zdWJtaXNzaW9uP3N1Ym1pc3Npb25JZD00NzM4MzY2Nw==">测试代码<i class="fa fa-external-link-alt"></i></span></p><p>用时：1425ms</p></li><li><p>cin和cout（关闭流同步和不使用endl）</p><p><span class="exturl" data-url="aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL2NvbnRlc3Qvdmlldy1zdWJtaXNzaW9uP3N1Ym1pc3Npb25JZD00NzM4MzY5NA==">测试代码<i class="fa fa-external-link-alt"></i></span></p><p>用时：218ms</p></li></ol><p>关闭流同步会使得cin和cout速度变快，这我早就知道了</p><p>从 4 和 5 的对比就能看得出来，还是快了很多的</p><p>并且可以发现<strong>频繁使用endl刷新缓冲区</strong>会导致速度严重降低，即便关闭了流同步也会导致效率相差很大</p><p>题外话：</p><p>我第一次TLE后，我是真的不太相信就是cin 和 cout 会导致效率低那么多…</p><p>然后犹豫了几分钟后才抱着试试的心态交了一发，结果过了…</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在我ICPC 昆明赛区因为使用 cin 和 cout TLE一发后，我改成了scanf和printf，从 2s 的TLE变成了 267 ms …&lt;/p&gt;
&lt;p&gt;然后我在赛后进行了一些测试&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>第 45 届国际大学生程序设计竞赛（ICPC）亚洲区域赛（昆明）</title>
    <link href="https://wjr-z.com/%E7%AC%AC-45-%E5%B1%8A%E5%9B%BD%E9%99%85%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%EF%BC%88ICPC%EF%BC%89%E4%BA%9A%E6%B4%B2%E5%8C%BA%E5%9F%9F%E8%B5%9B%EF%BC%88%E6%98%86%E6%98%8E%EF%BC%89/"/>
    <id>https://wjr-z.com/%E7%AC%AC-45-%E5%B1%8A%E5%9B%BD%E9%99%85%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%EF%BC%88ICPC%EF%BC%89%E4%BA%9A%E6%B4%B2%E5%8C%BA%E5%9F%9F%E8%B5%9B%EF%BC%88%E6%98%86%E6%98%8E%EF%BC%89/</id>
    <published>2021-04-03T13:05:33.000Z</published>
    <updated>2021-04-05T14:26:03.097Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>战绩：</p><p>H、I、J、M、L</p><p>排名86，银牌</p><span id="more"></span><p>这一场 A 题就是在钓鱼…</p><p>题目名字叫AC ，通过率 2/515，幸亏没做</p><p>刚开始我也觉得是一道签到题，但是当我看到0/60的时候我就果断放弃了</p><h3 id="H-Hard-Calculation"><a href="#H-Hard-Calculation" class="headerlink" title="H.Hard Calculation"></a>H.Hard Calculation</h3><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>昆明赛区2021年第一次举办ICPC，假设每年举办一次，问第x届是多少年？</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>直接输出2020+x即可</p><h3 id="L-Simone-and-graph-coloring"><a href="#L-Simone-and-graph-coloring" class="headerlink" title="L.Simone and graph coloring"></a>L.Simone and graph coloring</h3><h4 id="题目大意：-1"><a href="#题目大意：-1" class="headerlink" title="题目大意："></a>题目大意：</h4><p>T组，每一组给出n个数的排列$a_1,a_2…a_n$，对于每个$i<j\,and\,a_i>a_j$有一条边，你现在要给每条点染上一种颜色$c_i$，使得任意一条边的两个点颜色不同，并最小化不同颜色数，任意输出一种方案即可。</p><h4 id="题解：-1"><a href="#题解：-1" class="headerlink" title="题解："></a>题解：</h4><p>$a_i&gt;a_j$看着不太舒服</p><p>我们不妨将序列旋转过来（从尾到头）</p><p>对于一个点x，会与所有在他前面且小于他的连边，其中有一个是最长的链，不难发现我们让x的颜色为最长的链的长度即可</p><p>这样一定是最小的，且一定能满足题目要求</p><h3 id="I-Mr-Main-and-Windmills"><a href="#I-Mr-Main-and-Windmills" class="headerlink" title="I.Mr. Main and Windmills"></a>I.Mr. Main and Windmills</h3><h4 id="题目大意：-2"><a href="#题目大意：-2" class="headerlink" title="题目大意："></a>题目大意：</h4><p>说不清楚，具体看原题吧</p><h4 id="题解：-2"><a href="#题解：-2" class="headerlink" title="题解："></a>题解：</h4><p>枚举所有点对$(i,j)$，先判断是否和ST线段平行，平行则跳过</p><p>否则求出和ST的交点P，然后要判断P是否在线段上，如果不在则跳过</p><p>否则说明 P前和P后这两个点相对的 左/右 发生了改变</p><p>记$vector\,v[N]$ ，其中$v[x]$代表 x 点所有得到的这样的点P，$v[i]$和$v[j]$都push_back(P)即可</p><p>之后根据P到S的距离将对于每个$v[x]$排序即可</p><p>然后对于询问$h,k$</p><p>我们先看$v[h].size()$是否大于等于k</p><p>不是的话输出-1</p><p>否则输出$v[h][k-1]$即可</p><h3 id="J-Parallel-Sort"><a href="#J-Parallel-Sort" class="headerlink" title="J.Parallel Sort"></a>J.Parallel Sort</h3><h4 id="题目大意：-3"><a href="#题目大意：-3" class="headerlink" title="题目大意："></a>题目大意：</h4><p>n个数的一个排列$a_1,a_2…a_n$</p><p>每轮可以交换任意多次$i,j$位置上的数</p><p>但是每个位置$i$每轮最多被交换一次</p><p>问需要多少轮交换使得对于$\forall i,a_i=i$</p><p>现在要最小化交换轮数，但对于交换次数没有要求</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">1</span> <span class="number">2</span> <span class="number">4</span> </span><br></pre></td></tr></table></figure><p>我不能直接第一轮交换$(1,2)$变成$1,3,2,4$再交换$(2,3)$变成$(1,2,3,4)$ </p><p>因为这样2交换了两次</p><p>最少需要两轮</p><p>第一轮：交换$(1,2)$变成$1,3,2,4$</p><p>第二轮：交换$(2,3)$变成$1,2,3,4$</p><h4 id="题解：-3"><a href="#题解：-3" class="headerlink" title="题解："></a>题解：</h4><p>我们将所有$i$点与$a_i$点连边，不难发现肯定能构成一个环</p><p>如果$a_i=i$则说明不用交换</p><p>其余都是需要交换的情况</p><p>对于所有环最多只有两个点的情况，那么只需要最多一轮</p><p>对于有的环有大于两个点时，我们可以任意取环中任意一个点作为中心点，然后交换这个点左右两边第一个，左右两边第二个…直到让这个环变成若干个最多只有两个点的环</p><p>例：</p><p><img data-src="https://tu.sunpma.com/imgs/2021/04/53f9ccec2d563a4f.png" alt=""></p><p><img data-src="https://tu.sunpma.com/imgs/2021/04/241e79c702169f5e.png" alt=""></p><p><img data-src="https://tu.sunpma.com/imgs/2021/04/9300dc400425163a.png" alt=""></p><p>对于任意多个点都可以这样子通过某个点将左右两边交换变成一个更小的环和一个点数为2的环</p><p>而且可以发现第$i$次交换的就是第一次选的中心点的左右两边$i$个（也可能有其他方法，但是本质一样的）</p><p>这样这题就做出来了</p><p>特判 m = 0 和 m = 1</p><p>然后对于 m = 2 </p><p>我们对于每个点 dfs 找环，每个点最多被找到 1 次</p><p>找环时按照先后顺序将这些点记到数组</p><p>如果点数小于等于2 continue即可</p><p>否则我们以最后一个点（或者第一个点或者其他）为中心点，然后中心点左右两边第$1,2,…k$个交换即可</p><p>比如最后一个点为中心点时，假设总共k个数</p><p>那么是交换$(1,k-1),(2,k-2)…(i,k-i)(i&lt;k-i)$</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">&#125;b[N];</span><br><span class="line"><span class="keyword">bool</span> used[N];</span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="keyword">int</span> cnt,c[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(used[x])<span class="keyword">return</span>;</span><br><span class="line">    used[x]=<span class="literal">true</span>;</span><br><span class="line">    c[++cnt]=x;</span><br><span class="line">    dfs(a[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">bool</span> f=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] != i) &#123;</span><br><span class="line">            f=<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (f) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    f=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] != i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[a[i]] != i) &#123;</span><br><span class="line">                f=<span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (f) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;1\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]&gt;i)</span><br><span class="line">                ++m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,m);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] &gt; i) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d %d &quot;</span>,i,a[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;2\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        cnt=<span class="number">0</span>;</span><br><span class="line">        dfs(i);</span><br><span class="line">        <span class="keyword">if</span> (cnt &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; cnt-j; ++j) &#123;</span><br><span class="line">                b[++m].l=c[j];</span><br><span class="line">                b[m].r=c[cnt-j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d &quot;</span>,b[i].l,b[i].r),swap(a[b[i].l],a[b[i].r]);</span><br><span class="line">    m=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &gt; i)</span><br><span class="line">            ++m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &gt; i) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d %d &quot;</span>, i, a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="M-Stone-Games"><a href="#M-Stone-Games" class="headerlink" title="M.Stone Games"></a>M.Stone Games</h3><h4 id="题目大意：-4"><a href="#题目大意：-4" class="headerlink" title="题目大意："></a>题目大意：</h4><p>给出一个n，给出一个长度为n的序列$a_1,a_2…a_n$</p><p>每次询问给出一个$L,R$（强制在线了，需要自己转换下）</p><p>求出下标在$[L,R]$中最小的不能得到的非负整数（每个数可以选或者不选，这样能得出一个能得到的数的序列）</p><p>假设现在有 1 ，2 ，4 ，9</p><p>则可以得到的数是 0，1 , 2 , 3 , 4 , 5 , 6 , 7 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16</p><p>那么最小的不能得到的数是8</p><h4 id="题解：-4"><a href="#题解：-4" class="headerlink" title="题解："></a>题解：</h4><p>一开始想了一堆乱七八糟的</p><p>后来想到初步正解</p><p>假设序列是从小到大排序好了的</p><p>那么我们顺着做</p><p>假设前i个数最大能得到的数是$A$，如果第i+1个数$P$小于等于$A+1$则前$i+1$个数最大能得到的数是$P+A$</p><p>否则的话后面的数都大于$A+1$了，则$A+1$永远不能得到</p><p>这样的话就变成了找到第一个$i$使得前$i$个数的和+1小于第$i+1$个数即可</p><p>因为不一定有序，所以我们选择用主席树将他变成有序</p><p>这样变成了求出一个区间内第一个i，使得前$i$个最小的数的和+1小于第$i+1$小的数即可</p><p>我一开始以为这个满足二分性质，但后来发现错了</p><p>之后我队友（tql)提到了一个方法</p><p>我之前是想着枚举第几个，这样复杂度肯定超了</p><p>但是如果是枚举$A$这样就不会超了</p><p>我们假设当前能得到的数最大是$A$（初始为0）</p><p>我们在区间求$\leq A+1$的和，将这个和作为新的$A$</p><p>如果这个和就是$A$那么break出来（因为找不到数能让他更大了）</p><p>然后是复杂度证明</p><p>我们假设当前是$A$，我们现在将$A$更新为所有$\leq A+1$的和</p><p>假设变为了$S$</p><p>则下一次的和为$S$+所有权值在$[A+2,S+1]$中的和 或者是break</p><p>因为下一次我们会更新为$\leq S+1$的和，而上次更新到了$\leq A+1$的和</p><p>没有算权值在$[A+2,S+1]$中的和，所以这次要加上这一部分的和</p><p>因为至少存在一个</p><p>则经过两次后$A$至少变为了$2*A$</p><p>那么这个复杂度是最多$log_2 n$的</p><p>实际上呢完全跑不满！因为这是最极端情况</p><p>所以正解就是个while + 主席树</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> maxn=<span class="number">1e15</span>;</span><br><span class="line"><span class="keyword">int</span> ch[N*<span class="number">70</span>][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="keyword">int</span> rt[N];</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> s[N],sum[N*<span class="number">70</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span>&amp; las, <span class="keyword">int</span>&amp; now, <span class="keyword">long</span> <span class="keyword">long</span> L, <span class="keyword">long</span> <span class="keyword">long</span> R, <span class="keyword">long</span> <span class="keyword">long</span> pos)</span> </span>&#123;</span><br><span class="line">    now=++cnt;</span><br><span class="line">    sum[now]=sum[las]+pos;</span><br><span class="line">    <span class="keyword">if</span>(L==R)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> mid=L+R&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (pos &lt;= mid) &#123;</span><br><span class="line">        ch[now][<span class="number">1</span>]=ch[las][<span class="number">1</span>];</span><br><span class="line">        ins(ch[las][<span class="number">0</span>],ch[now][<span class="number">0</span>],L,mid,pos);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        ch[now][<span class="number">0</span>]=ch[las][<span class="number">0</span>];</span><br><span class="line">        ins(ch[las][<span class="number">1</span>],ch[now][<span class="number">1</span>],mid+<span class="number">1</span>,R,pos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span>&amp; las, <span class="keyword">int</span>&amp; now, <span class="keyword">long</span> <span class="keyword">long</span> L, <span class="keyword">long</span> <span class="keyword">long</span> R, <span class="keyword">long</span> <span class="keyword">long</span> pos)</span> </span>&#123;<span class="comment">//区间第k小</span></span><br><span class="line">    <span class="keyword">if</span> (L == R)<span class="keyword">return</span> sum[now] - sum[las];</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> mid = L + R &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos&lt;=mid)<span class="keyword">return</span> query(ch[las][<span class="number">0</span>],ch[now][<span class="number">0</span>],L,mid,pos);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> sum[ch[now][<span class="number">0</span>]]-sum[ch[las][<span class="number">0</span>]]+query(ch[las][<span class="number">1</span>],ch[now][<span class="number">1</span>],mid+<span class="number">1</span>,R,pos);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> lastans;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span>(x+lastans)%n+<span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        ins(rt[i<span class="number">-1</span>],rt[i],<span class="number">1</span>,maxn,a[i]),s[i]=s[i<span class="number">-1</span>]+a[i];</span><br><span class="line">    <span class="keyword">while</span> (k--) &#123;</span><br><span class="line">        <span class="keyword">int</span> L,R;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;L,&amp;R);</span><br><span class="line">        L=get(L),R=get(R);</span><br><span class="line">        <span class="keyword">if</span>(L&gt;R)swap(L,R);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> r=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> k = query(rt[L - <span class="number">1</span>], rt[R], <span class="number">1</span>, maxn, r+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(k&lt;=r)<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> r=k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,lastans=(r+<span class="number">1</span>));</span><br><span class="line">        lastans%=n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只用了 1400ms ，没有管常数啥的</p><h3 id="C-Cities"><a href="#C-Cities" class="headerlink" title="C. Cities"></a>C. Cities</h3><h4 id="题目大意：-5"><a href="#题目大意：-5" class="headerlink" title="题目大意："></a>题目大意：</h4><p>有T组数据</p><p>每组给出n个数$a_1,a_2…a_n(a_i\leq n)$</p><p>每次可以将连续的相同的数并将他们变成任意数</p><p>问最小需要多少次可以将所有数变成相同的</p><h4 id="题解：-5"><a href="#题解：-5" class="headerlink" title="题解："></a>题解：</h4><p>这题有一个非常重要的性质！</p><p>知道了这个性质，这题就是大水题了 </p><p>对于任意一个区间$[L,R]$最优解一定包含了整个区间变成$a_L$或者是$a_R$的解</p><p>所以对于任意区间$[L,R]$，都可以看做是将其变为$a_L$ </p><p>下面证明此性质（给出了全部变成$a_L$的证明，$a_R$同理）：</p><p>对于<strong>任意一个长度为1的区间</strong>，很显然该性质成立</p><p>对于<strong>任意一个长度为2的区间</strong>，很显然也成立</p><p>对于<strong>任意一个长度为$i$的区间$<a href="L+i-1=R">L,R</a>$</strong>：</p><p>我们假设$[L,R]$最优解是$[L,k]$和$[k+1,R]$的最优解合并</p><p>如果我们能证明任意长度为$k-L+1$和$R-k$的区间最优解包括全变成左端点的解</p><p>则可将问题简化为$a_L$和$a_{k+1}$合并，这样的话，很显然最优解也包括左端点的解</p><p>这样我们就能用归纳法证明对于<strong>任意一个区间</strong>，其最优解必定包括整个区间变为左端点的解（右端点同理）</p><p>定义$dp[L][R]$为$[L,R]$变为$a_L$的最优解</p><p>答案统计就变为$dp[L][R]=min(dp[L][k-1]+dp[k][R]+(a_k\neq a_L))$</p><p>不过这个方法会超时，因此考虑进一步优化</p><p>发现题目有一个关键的条件，相同的数最多不超过15个</p><p>我们不妨对于$a_k=a_L$和$a_k\neq a_L$分别考虑：</p><ul><li><p>$a_k=a_L$</p><p>$dp[L][R]=min(dp[L][k-1]+dp[k][R])$即可</p></li><li><p>$a_k\neq a_L$</p><p>$dp[L+1][R]+1\leq min(dp[L][k-1]+dp[k][R]+1)$</p><p>证明：</p><p>欲证明$dp[L+1][R]+1\leq min(dp[L][k-1]+dp[k][R]+1)$</p><p>即证明$dp[L+1][R]\leq min(dp[L][k-1]+dp[k][R])$</p><p>即证明$min(dp[L+1][k’-1]+dp[k’][R]+(a_{k’}\neq a_{L+1}))\leq min(dp[L][k-1]+dp[k][R])$</p><p>即证明$min(dp[L][k’])$</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;战绩：&lt;/p&gt;
&lt;p&gt;H、I、J、M、L&lt;/p&gt;
&lt;p&gt;排名86，银牌&lt;/p&gt;</summary>
    
    
    
    
    <category term="ACM" scheme="https://wjr-z.com/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>算法模板合集</title>
    <link href="https://wjr-z.com/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%90%88%E9%9B%86/"/>
    <id>https://wjr-z.com/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%90%88%E9%9B%86/</id>
    <published>2021-03-31T14:08:50.000Z</published>
    <updated>2021-04-25T03:28:21.652Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-数论"><a href="#1-数论" class="headerlink" title="1.数论"></a>1.数论</h2><h3 id="1-1-与取模有关的函数"><a href="#1-1-与取模有关的函数" class="headerlink" title="1.1 与取模有关的函数"></a>1.1 与取模有关的函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> wjr &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uint unsigned int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bs bitset<span class="meta-string">&lt;N&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lb(x) x&amp;-x</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line">    <span class="keyword">int</span> mod = <span class="number">998244353</span>, inv2 = <span class="number">499122177</span>, inf = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">initial</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        inv2 = (mod + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a * <span class="number">1ll</span> * b % mod; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a += b, a &gt;= mod ? a - mod : a; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a -= b, a &lt; <span class="number">0</span> ? a + mod : a; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">int</span> s = <span class="number">1</span>; <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>, a = mul(a, a))<span class="keyword">if</span> (b &amp; <span class="number">1</span>)s = mul(s, a); <span class="keyword">return</span> s; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> T <span class="title">sqr</span><span class="params">(<span class="keyword">register</span> T x)</span> </span>&#123; <span class="keyword">return</span> x * x; &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> wjr;</span><br><span class="line"></span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="1-2-FWT-快速沃尔什变换"><a href="#1-2-FWT-快速沃尔什变换" class="headerlink" title="1.2 FWT(快速沃尔什变换)"></a>1.2 FWT(快速沃尔什变换)</h3><p>可用于求</p><script type="math/tex; mode=display">C[i\oplus j]=\sum_{i}\sum_{j}a[i]*b[j]</script><p>逻辑运算符可以为 异或，与，或</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> wjr &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uint unsigned int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bs bitset<span class="meta-string">&lt;N&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lb(x) x&amp;-x</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line">    <span class="keyword">int</span> mod = <span class="number">998244353</span>, inv2 = <span class="number">499122177</span>, inf = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">initial</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        inv2 = (mod + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a * <span class="number">1ll</span> * b % mod; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a += b, a &gt;= mod ? a - mod : a; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a -= b, a &lt; <span class="number">0</span> ? a + mod : a; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">int</span> s = <span class="number">1</span>; <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>, a = mul(a, a))<span class="keyword">if</span> (b &amp; <span class="number">1</span>)s = mul(s, a); <span class="keyword">return</span> s; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> T <span class="title">sqr</span><span class="params">(<span class="keyword">register</span> T x)</span> </span>&#123; <span class="keyword">return</span> x * x; &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> wjr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> FWT &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">maintain</span><span class="params">(<span class="keyword">int</span>&amp; n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> q = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (q &lt; n)</span><br><span class="line">            q &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        n = q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FWT_and</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> n, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> step, s, i, j;</span><br><span class="line">        <span class="keyword">for</span> (step = <span class="number">1</span>, s = <span class="number">2</span>; step &lt; n; step &lt;&lt;= <span class="number">1</span>, s &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i += s)</span><br><span class="line">                <span class="keyword">for</span> (j = i; j &lt; i + step; ++j)</span><br><span class="line">                    a[j] = ~p ? add(a[j], a[j + step]) : del(a[j], a[j + step]);</span><br><span class="line">    &#125;<span class="function"><span class="keyword">void</span> <span class="title">FWT_or</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> n, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> step, s, i, j;</span><br><span class="line">        <span class="keyword">for</span> (step = <span class="number">1</span>, s = <span class="number">2</span>; step &lt; n; step &lt;&lt;= <span class="number">1</span>, s &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i += s)</span><br><span class="line">                <span class="keyword">for</span> (j = i; j &lt; i + step; ++j)</span><br><span class="line">                    a[j + step] = ~p ? add(a[j + step], a[j]) : del(a[j + step], a[j]);</span><br><span class="line">    &#125;<span class="function"><span class="keyword">void</span> <span class="title">FWT_xor</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> n, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> step, s, i, j, x;</span><br><span class="line">        <span class="keyword">for</span> (step = <span class="number">1</span>, s = <span class="number">2</span>; step &lt; n; step &lt;&lt;= <span class="number">1</span>, s &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i += s)</span><br><span class="line">                <span class="keyword">for</span> (j = i; j &lt; i + step; ++j) &#123;</span><br><span class="line">                    x = a[j];</span><br><span class="line">                    a[j] = add(a[j], a[j + step]);</span><br><span class="line">                    a[j + step] = del(x, a[j + step]);</span><br><span class="line">                    <span class="keyword">if</span> (~p)<span class="keyword">continue</span>;</span><br><span class="line">                    a[j] = mul(a[j], inv2);</span><br><span class="line">                    a[j + step] = mul(a[j + step], inv2);</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FWTAND</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> n, <span class="keyword">int</span>* b, <span class="keyword">int</span> m, <span class="keyword">int</span>* c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> A[N], B[N];</span><br><span class="line">        <span class="keyword">int</span> len = max(n, m);</span><br><span class="line">        maintain(len);</span><br><span class="line">        <span class="built_in">memcpy</span>(A, a, n &lt;&lt; <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">memset</span>(A + n, <span class="number">0</span>, (len - n) &lt;&lt; <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">memcpy</span>(B, b, m &lt;&lt; <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">memset</span>(B + m, <span class="number">0</span>, (len - m) &lt;&lt; <span class="number">2</span>);</span><br><span class="line">        FWT_and(A, len, <span class="number">1</span>);</span><br><span class="line">        FWT_and(B, len, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">            A[i] = mul(A[i], B[i]);</span><br><span class="line">        FWT_and(A, len, <span class="number">-1</span>);</span><br><span class="line">        len = max(n, m);</span><br><span class="line">        <span class="built_in">memcpy</span>(c,A,len&lt;&lt;<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FWTOR</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> n, <span class="keyword">int</span>* b, <span class="keyword">int</span> m, <span class="keyword">int</span>* c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> A[N], B[N];</span><br><span class="line">        <span class="keyword">int</span> len = max(n, m);</span><br><span class="line">        maintain(len);</span><br><span class="line">        <span class="built_in">memcpy</span>(A, a, n &lt;&lt; <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">memset</span>(A + n, <span class="number">0</span>, (len - n) &lt;&lt; <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">memcpy</span>(B, b, m &lt;&lt; <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">memset</span>(B + m, <span class="number">0</span>, (len - m) &lt;&lt; <span class="number">2</span>);</span><br><span class="line">        FWT_or(A, len, <span class="number">1</span>);</span><br><span class="line">        FWT_or(B, len, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">            A[i] = mul(A[i], B[i]);</span><br><span class="line">        FWT_or(A, len, <span class="number">-1</span>);</span><br><span class="line">        len = max(n, m);</span><br><span class="line">        <span class="built_in">memcpy</span>(c, A, len &lt;&lt; <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FWTXOR</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> n, <span class="keyword">int</span>* b, <span class="keyword">int</span> m, <span class="keyword">int</span>* c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> A[N], B[N];</span><br><span class="line">        <span class="keyword">int</span> len = max(n, m);</span><br><span class="line">        maintain(len);</span><br><span class="line">        <span class="built_in">memcpy</span>(A, a, n &lt;&lt; <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">memset</span>(A + n, <span class="number">0</span>, (len - n) &lt;&lt; <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">memcpy</span>(B, b, m &lt;&lt; <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">memset</span>(B + m, <span class="number">0</span>, (len - m) &lt;&lt; <span class="number">2</span>);</span><br><span class="line">        FWT_xor(A, len, <span class="number">1</span>);</span><br><span class="line">        FWT_xor(B, len, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">            A[i] = mul(A[i], B[i]);</span><br><span class="line">        FWT_xor(A, len, <span class="number">-1</span>);</span><br><span class="line">        len = max(n, m);</span><br><span class="line">        <span class="built_in">memcpy</span>(c, A, len &lt;&lt; <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传入公式对应的a数组及其大小，b数组及其大小，以及答案数组C即可，N=1&lt;&lt;20，即数组最大为1&lt;&lt;20</p><h3 id="1-3-FST-快速子集变换"><a href="#1-3-FST-快速子集变换" class="headerlink" title="1.3 FST(快速子集变换)"></a>1.3 FST(快速子集变换)</h3><p>可用于求</p><script type="math/tex; mode=display">C[T]=\sum a[S]*b[T \oplus S]</script><p>逻辑运算符为异或</p><p>也可以写成</p><script type="math/tex; mode=display">C[k]=\sum_{i\&j=0\\i|j=k}a[i]*[j]</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> wjr &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uint unsigned int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bs bitset<span class="meta-string">&lt;N&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lb(x) x&amp;-x</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line">    <span class="keyword">int</span> mod = <span class="number">998244353</span>, inv2 = <span class="number">499122177</span>, inf = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">initial</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        inv2 = (mod + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a * <span class="number">1ll</span> * b % mod; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a += b, a &gt;= mod ? a - mod : a; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a -= b, a &lt; <span class="number">0</span> ? a + mod : a; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">int</span> s = <span class="number">1</span>; <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>, a = mul(a, a))<span class="keyword">if</span> (b &amp; <span class="number">1</span>)s = mul(s, a); <span class="keyword">return</span> s; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> T <span class="title">sqr</span><span class="params">(<span class="keyword">register</span> T x)</span> </span>&#123; <span class="keyword">return</span> x * x; &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> wjr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> FST &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">int</span> ctz[N];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">initial</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ctz[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        ctz[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; ++i) </span><br><span class="line">            ctz[i] = ctz[i ^ (i &amp; -i)] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">maintain</span><span class="params">(<span class="keyword">int</span>&amp; n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> q = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (q &lt; n)</span><br><span class="line">            q &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        n = q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FST</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> n, <span class="keyword">int</span>* b, <span class="keyword">int</span> m, <span class="keyword">int</span>* c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> A[<span class="number">21</span>][<span class="number">1</span> &lt;&lt; <span class="number">20</span>], B[<span class="number">21</span>][<span class="number">1</span> &lt;&lt; <span class="number">20</span>], C[<span class="number">21</span>][<span class="number">1</span> &lt;&lt; <span class="number">20</span>];</span><br><span class="line">        <span class="keyword">int</span> len = max(n, m);</span><br><span class="line">        maintain(len);</span><br><span class="line">        <span class="keyword">int</span> lim = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((<span class="number">1</span> &lt;&lt; lim) &lt; len)</span><br><span class="line">            ++lim;</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=lim;++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;len;++j)</span><br><span class="line">                A[i][j]=B[i][j]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            A[ctz[i]][i] = a[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">            B[ctz[i]][i] = b[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= lim; ++i)</span><br><span class="line">            FWT::FWT_or(A[i], len, <span class="number">1</span>), FWT::FWT_or(B[i], len, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= lim; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; ++j)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; len; ++k)</span><br><span class="line">                    C[i][k] = add(C[i][k], mul(A[j][k], B[i - j][k]));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= lim; ++i)</span><br><span class="line">            FWT::FWT_or(C[i], len, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; lim); ++i)</span><br><span class="line">            c[i] = C[ctz[i]][i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用方法：传入a数组及其大小，b数组及其大小，以及答案数组c</p><h3 id="1-4-NTT"><a href="#1-4-NTT" class="headerlink" title="1.4 NTT"></a>1.4 NTT</h3><p>多项式卷积（模数按需修改）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> wjr &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uint unsigned int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bs bitset<span class="meta-string">&lt;N&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lb(x) x&amp;-x</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line">    <span class="keyword">int</span> mod = <span class="number">998244353</span>, inv2 = <span class="number">499122177</span>, inf = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">initial</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        inv2 = (mod + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a * <span class="number">1ll</span> * b % mod; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a += b, a &gt;= mod ? a - mod : a; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a -= b, a &lt; <span class="number">0</span> ? a + mod : a; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">int</span> s = <span class="number">1</span>; <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>, a = mul(a, a))<span class="keyword">if</span> (b &amp; <span class="number">1</span>)s = mul(s, a); <span class="keyword">return</span> s; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> T <span class="title">sqr</span><span class="params">(<span class="keyword">register</span> T x)</span> </span>&#123; <span class="keyword">return</span> x * x; &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> wjr;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*---多项式 - NTT */</span></span><br><span class="line"><span class="keyword">namespace</span> Poly_NTT &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">int</span> g[<span class="number">25</span>], gi[<span class="number">25</span>], rev[N], INV[N | <span class="number">1</span>];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;<span class="comment">/*---初始化---*/</span></span><br><span class="line">        <span class="keyword">int</span> bit = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ((<span class="number">1</span> &lt;&lt; bit) &lt; (n &lt;&lt; <span class="number">1</span>))++bit;</span><br><span class="line">        <span class="keyword">int</span> I = qpow(<span class="number">3</span>, mod - <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= bit; ++i)g[i] = qpow(<span class="number">3</span>, (mod - <span class="number">1</span>) &gt;&gt; i), gi[i] = qpow(I, (mod - <span class="number">1</span>) &gt;&gt; i);</span><br><span class="line">        INV[<span class="number">0</span>] = INV[<span class="number">1</span>] = <span class="number">1</span>; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= (<span class="number">1</span> &lt;&lt; bit); ++i)INV[i] = mul(INV[mod % i], mod - mod / i);</span><br><span class="line">    &#125;<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> n, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i, j, step, s, enk, wn, x, now;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)<span class="keyword">if</span> (i &lt; rev[i])swap(a[i], a[rev[i]]);</span><br><span class="line">        <span class="keyword">for</span> (step = <span class="number">1</span>, s = <span class="number">2</span>, now = <span class="number">1</span>; step &lt; n; step &lt;&lt;= <span class="number">1</span>, s &lt;&lt;= <span class="number">1</span>, ++now) &#123;</span><br><span class="line">            wn = ~p ? g[now] : gi[now];</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i += s) &#123;</span><br><span class="line">                enk = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (j = i; j &lt; i + step; ++j) &#123;</span><br><span class="line">                    x = mul(enk, a[j + step]);</span><br><span class="line">                    a[j + step] = del(a[j], x);</span><br><span class="line">                    a[j] = add(a[j], x);</span><br><span class="line">                    enk = mul(enk, wn);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">if</span> (~p)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)a[i] = mul(a[i], INV[n]);</span><br><span class="line">    &#125;<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">get_rev</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123; <span class="keyword">int</span> Maxn = <span class="number">1</span> &lt;&lt; s; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Maxn; ++i)rev[i] = (rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (s - <span class="number">1</span>)); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Mul</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> n, <span class="keyword">int</span>* b, <span class="keyword">int</span> m)</span> </span>&#123;<span class="comment">/*---多项式乘法---*/</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> A[N], B[N];</span><br><span class="line">        <span class="keyword">int</span> i, bit, s, len; len = n + m - <span class="number">1</span>;</span><br><span class="line">        bit = <span class="number">1</span>, s = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (s &lt; len)++bit, s &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        get_rev(bit);</span><br><span class="line">        <span class="built_in">memcpy</span>(A, a, n &lt;&lt; <span class="number">2</span>), <span class="built_in">memset</span>(A + n, <span class="number">0</span>, (s - n) &lt;&lt; <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">memcpy</span>(B, b, m &lt;&lt; <span class="number">2</span>), <span class="built_in">memset</span>(B + m, <span class="number">0</span>, (s - m) &lt;&lt; <span class="number">2</span>);</span><br><span class="line">        NTT(A, s, <span class="number">1</span>), NTT(B, s, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; s; ++i)A[i] = mul(A[i], B[i]);</span><br><span class="line">        NTT(A, s, <span class="number">-1</span>); <span class="built_in">memcpy</span>(a, A, len &lt;&lt; <span class="number">2</span>);</span><br><span class="line">    &#125;<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Inv</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> n)</span> </span>&#123;<span class="comment">/*---多项式逆元---*/</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> A[N], B[N], s, i, j, k, now;</span><br><span class="line">        s = <span class="number">2</span>; <span class="keyword">while</span> (s &lt; n)s &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">memset</span>(a + n, <span class="number">0</span>, (s - n) &lt;&lt; <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">memset</span>(B, <span class="number">0</span>, s &lt;&lt; <span class="number">3</span>);</span><br><span class="line">        B[<span class="number">0</span>] = a[<span class="number">0</span>] &lt;= N ? INV[a[<span class="number">0</span>]] : qpow(a[<span class="number">0</span>], mod - <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">2</span>, j = <span class="number">4</span>, now = <span class="number">2</span>; i &lt;= s; i &lt;&lt;= <span class="number">1</span>, j &lt;&lt;= <span class="number">1</span>, ++now) &#123;</span><br><span class="line">            <span class="built_in">memcpy</span>(A, a, i &lt;&lt; <span class="number">2</span>), <span class="built_in">memset</span>(A + i, <span class="number">0</span>, i &lt;&lt; <span class="number">2</span>);</span><br><span class="line">            get_rev(now);</span><br><span class="line">            NTT(A, j, <span class="number">1</span>), NTT(B, j, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; j; ++k)B[k] = mul(B[k], del(<span class="number">2</span>, mul(A[k], B[k])));</span><br><span class="line">            NTT(B, j, <span class="number">-1</span>), <span class="built_in">memset</span>(B + i, <span class="number">0</span>, i &lt;&lt; <span class="number">2</span>);</span><br><span class="line">        &#125;<span class="built_in">memcpy</span>(a, B, n &lt;&lt; <span class="number">2</span>);</span><br><span class="line">    &#125;<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">deriv</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> n)</span> </span>&#123;<span class="comment">/*---求导函数---*/</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)a[i] = mul(a[i + <span class="number">1</span>], i + <span class="number">1</span>); a[n - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">intag</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> n)</span> </span>&#123;<span class="comment">/*---求原函数---*/</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i; --i)a[i] = mul(a[i - <span class="number">1</span>], INV[i]); a[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Ln</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> n)</span> </span>&#123;<span class="comment">/*---对数函数---*/</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> A[N];</span><br><span class="line">        <span class="built_in">memcpy</span>(A, a, n &lt;&lt; <span class="number">2</span>), Inv(A, n);</span><br><span class="line">        deriv(a, n),</span><br><span class="line">            Mul(a, n, A, n);</span><br><span class="line">        intag(a, n), <span class="built_in">memset</span>(a + n, <span class="number">0</span>, (n - <span class="number">1</span>) &lt;&lt; <span class="number">2</span>);</span><br><span class="line">    &#125;<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Exp</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> n)</span> </span>&#123;<span class="comment">/*---指数函数---*/</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> A[N], B[N], i, j, k, now, s;</span><br><span class="line">        s = <span class="number">2</span>; <span class="keyword">while</span> (s &lt; n)s &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">memset</span>(a + n, <span class="number">0</span>, (s - n) &lt;&lt; <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">memset</span>(B, <span class="number">0</span>, s &lt;&lt; <span class="number">3</span>);</span><br><span class="line">        B[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">2</span>, j = <span class="number">4</span>, now = <span class="number">2</span>; i &lt;= s; i &lt;&lt;= <span class="number">1</span>, j &lt;&lt;= <span class="number">1</span>, ++now) &#123;</span><br><span class="line">            <span class="built_in">memcpy</span>(A, B, i &lt;&lt; <span class="number">2</span>), <span class="built_in">memset</span>(A + i, <span class="number">0</span>, i &lt;&lt; <span class="number">2</span>);</span><br><span class="line">            Ln(A, i); <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; i; ++k)A[k] = del(a[k], A[k]);</span><br><span class="line">            A[<span class="number">0</span>] = add(A[<span class="number">0</span>], <span class="number">1</span>), get_rev(now);</span><br><span class="line">            NTT(A, j, <span class="number">1</span>), NTT(B, j, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; j; ++k)B[k] = mul(B[k], A[k]);</span><br><span class="line">            NTT(B, j, <span class="number">-1</span>), <span class="built_in">memset</span>(B + i, <span class="number">0</span>, i &lt;&lt; <span class="number">2</span>);</span><br><span class="line">        &#125;<span class="built_in">memcpy</span>(a, B, n &lt;&lt; <span class="number">2</span>);</span><br><span class="line">    &#125;<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Ksm</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;<span class="comment">/*---快速幂---*/</span></span><br><span class="line">        <span class="comment">/*---对于x^n取模，最终长度是n而不是(n-1)k---*/</span></span><br><span class="line">        <span class="keyword">int</span> t, p, inv;</span><br><span class="line">        t = <span class="number">0</span>; <span class="keyword">while</span> (!a[t] &amp;&amp; t &lt; n)++t;</span><br><span class="line">        <span class="keyword">if</span> (t &gt;= n)<span class="keyword">return</span>;</span><br><span class="line">        p = a[t], inv = p &lt;= N ? INV[p] : qpow(p, mod - <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - t; ++i)a[i] = mul(a[i + t], inv);</span><br><span class="line">        <span class="built_in">memset</span>(a + n - t, <span class="number">0</span>, t &lt;&lt; <span class="number">2</span>);</span><br><span class="line">        Ln(a, n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)a[i] = mul(a[i], k);</span><br><span class="line">        a[<span class="number">0</span>] = <span class="number">0</span>, Exp(a, n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= t; --i)</span><br><span class="line">            a[i] = mul(p, a[i - t]);</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, t &lt;&lt; <span class="number">2</span>);</span><br><span class="line">    &#125;<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Div</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> n, <span class="keyword">int</span>* b, <span class="keyword">int</span> m)</span> </span>&#123;<span class="comment">/*---多项式除法+取模---*/</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> F[N], G[N];</span><br><span class="line">        <span class="built_in">memcpy</span>(F, a, (n + <span class="number">1</span>) &lt;&lt; <span class="number">2</span>), <span class="built_in">memcpy</span>(G, b, (m + <span class="number">1</span>) &lt;&lt; <span class="number">2</span>);</span><br><span class="line">        reverse(b, b + <span class="number">1</span> + m), reverse(F, F + <span class="number">1</span> + n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - m + <span class="number">1</span>; i &lt;= m; ++i)b[i] = <span class="number">0</span>;</span><br><span class="line">        Inv(b, n - m + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - m + <span class="number">1</span>; i &lt;= n; ++i)F[i] = <span class="number">0</span>;</span><br><span class="line">        Mul(F, n - m + <span class="number">1</span>, b, n - m + <span class="number">1</span>);</span><br><span class="line">        reverse(F, F + n - m + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - m + <span class="number">1</span>; i &lt;= n; ++i)F[i] = <span class="number">0</span>;</span><br><span class="line">        Mul(G, m + <span class="number">1</span>, F, n - m + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)b[i] = del(a[i], G[i]);</span><br><span class="line">        <span class="built_in">memcpy</span>(a, F, n &lt;&lt; <span class="number">2</span>);</span><br><span class="line">    &#125;<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Sqrt</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> n)</span> </span>&#123;<span class="comment">//多项式开根 </span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> A[N], B[N];</span><br><span class="line">        <span class="keyword">int</span> s, i, j, k, now;</span><br><span class="line">        s = <span class="number">2</span>; <span class="keyword">while</span> (s &lt; n)s &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">memset</span>(a + n, <span class="number">0</span>, (s - n) &lt;&lt; <span class="number">2</span>), <span class="built_in">memset</span>(B, <span class="number">0</span>, s &lt;&lt; <span class="number">3</span>);</span><br><span class="line">        B[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">2</span>, j = <span class="number">4</span>, now = <span class="number">2</span>; i &lt;= s; i &lt;&lt;= <span class="number">1</span>, j &lt;&lt;= <span class="number">1</span>, ++now) &#123;</span><br><span class="line">            <span class="built_in">memcpy</span>(A, B, i &lt;&lt; <span class="number">2</span>), <span class="built_in">memset</span>(A + i, <span class="number">0</span>, i &lt;&lt; <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; i; ++k)A[k] = mul(A[k], <span class="number">2</span>);</span><br><span class="line">            Inv(A, i);</span><br><span class="line">            get_rev(now - <span class="number">1</span>);</span><br><span class="line">            NTT(B, i, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; i; ++k)B[k] = mul(B[k], B[k]);</span><br><span class="line">            NTT(B, i, <span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; i; ++k)B[k] = add(B[k], a[k]);</span><br><span class="line">            get_rev(now);</span><br><span class="line">            NTT(B, j, <span class="number">1</span>), NTT(A, j, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; j; ++k)B[k] = mul(B[k], A[k]);</span><br><span class="line">            NTT(B, j, <span class="number">-1</span>), <span class="built_in">memset</span>(B + i, <span class="number">0</span>, i &lt;&lt; <span class="number">2</span>);</span><br><span class="line">        &#125;<span class="built_in">memcpy</span>(a, B, n &lt;&lt; <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-FFT"><a href="#1-5-FFT" class="headerlink" title="1.5 FFT"></a>1.5 FFT</h3><p>NTT是带取模的FFT</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> wjr &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uint unsigned int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bs bitset<span class="meta-string">&lt;N&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lb(x) x&amp;-x</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line">    <span class="keyword">int</span> mod = <span class="number">998244353</span>, inv2 = <span class="number">499122177</span>, inf = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">initial</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        inv2 = (mod + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a * <span class="number">1ll</span> * b % mod; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a += b, a &gt;= mod ? a - mod : a; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a -= b, a &lt; <span class="number">0</span> ? a + mod : a; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">int</span> s = <span class="number">1</span>; <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>, a = mul(a, a))<span class="keyword">if</span> (b &amp; <span class="number">1</span>)s = mul(s, a); <span class="keyword">return</span> s; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> T <span class="title">sqr</span><span class="params">(<span class="keyword">register</span> T x)</span> </span>&#123; <span class="keyword">return</span> x * x; &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> wjr;</span><br><span class="line"><span class="keyword">namespace</span> Poly_FFT &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1</span> &lt;&lt; <span class="number">18</span>, zw = (<span class="number">1</span> &lt;&lt; <span class="number">15</span>) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">int</span> rev[N];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cd</span> &#123;</span></span><br><span class="line">        <span class="keyword">double</span> x, y;</span><br><span class="line">        cd(<span class="keyword">double</span> a = <span class="number">0</span>, <span class="keyword">double</span> b = <span class="number">0</span>) &#123; x = a, y = b; &#125;</span><br><span class="line">    &#125;w[<span class="number">18</span>][N];</span><br><span class="line">    <span class="keyword">inline</span> cd <span class="keyword">operator</span>+(cd a, cd b) &#123; <span class="keyword">return</span> cd(a.x + b.x, a.y + b.y); &#125;</span><br><span class="line">    <span class="keyword">inline</span> cd <span class="keyword">operator</span>-(cd a, cd b) &#123; <span class="keyword">return</span> cd(a.x - b.x, a.y - b.y); &#125;</span><br><span class="line">    <span class="keyword">inline</span> cd <span class="keyword">operator</span>*(cd a, cd b) &#123; <span class="keyword">return</span> cd(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x); &#125;</span><br><span class="line">    <span class="keyword">inline</span> cd <span class="keyword">operator</span>*(cd a, <span class="keyword">int</span> b) &#123; <span class="keyword">return</span> cd(a.x, a.y * b); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, k = <span class="number">1</span>, j; i &lt;= <span class="number">17</span>; ++i, k &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; k; ++j)</span><br><span class="line">                w[i][j] = cd(<span class="built_in">cos</span>(PI * j / k), <span class="built_in">sin</span>(PI * j / k));</span><br><span class="line">    &#125;<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">get_rev</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">int</span> Maxn = <span class="number">1</span> &lt;&lt; s; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Maxn; ++i)rev[i] = (rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (s - <span class="number">1</span>)); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">FFT</span><span class="params">(<span class="keyword">register</span> cd* a, <span class="keyword">int</span> n, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> step, s, i, j, now;</span><br><span class="line">        cd x;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)<span class="keyword">if</span> (i &lt; rev[i])swap(a[i], a[rev[i]]);</span><br><span class="line">        <span class="keyword">for</span> (step = <span class="number">1</span>, s = <span class="number">2</span>, now = <span class="number">0</span>; step &lt; n; step &lt;&lt;= <span class="number">1</span>, s &lt;&lt;= <span class="number">1</span>, ++now)</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i += s)</span><br><span class="line">                <span class="keyword">for</span> (j = i; j &lt; i + step; ++j) &#123;</span><br><span class="line">                    x = a[j + step] * (w[now][j - i] * p);</span><br><span class="line">                    a[j + step] = a[j] - x;</span><br><span class="line">                    a[j] = a[j] + x;</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">if</span> (~p)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)a[i].x /= n;</span><br><span class="line">    &#125;<span class="function"><span class="keyword">inline</span> LL <span class="title">get</span><span class="params">(cd x, <span class="keyword">int</span> Mod)</span> </span>&#123; <span class="keyword">return</span> LL(x.x + <span class="number">0.5</span>) % Mod; &#125;</span><br><span class="line">    <span class="keyword">int</span> siz = <span class="keyword">sizeof</span>(cd);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> pw = <span class="number">32767</span>;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">MTT</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> n,<span class="keyword">int</span>*b,<span class="keyword">int</span> m,<span class="keyword">int</span>*c, <span class="keyword">int</span> Mod)</span> </span>&#123;<span class="comment">//对于较大模数需要用MTT</span></span><br><span class="line">        <span class="keyword">static</span> cd A[N], B[N], C[N], D[N], e[N], f[N], g[N], h[N];</span><br><span class="line">        <span class="keyword">int</span> i, s, len,bit; </span><br><span class="line">        len = n + m - <span class="number">1</span>;</span><br><span class="line">        bit=<span class="number">1</span>;</span><br><span class="line">        s = <span class="number">2</span>; </span><br><span class="line">        <span class="keyword">while</span> (s &lt; len)s &lt;&lt;= <span class="number">1</span>,++bit;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; s; ++i) &#123;</span><br><span class="line">            A[i] = cd(a[i] &gt;&gt; <span class="number">15</span>, <span class="number">0</span>), B[i] = cd(a[i] &amp; pw, <span class="number">0</span>);</span><br><span class="line">            C[i] = cd(b[i] &gt;&gt; <span class="number">15</span>, <span class="number">0</span>), D[i] = cd(b[i] &amp; pw, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        get_rev(bit);</span><br><span class="line">        FFT(A, s, <span class="number">1</span>), FFT(B, s, <span class="number">1</span>), FFT(C, s, <span class="number">1</span>), FFT(D, s, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; s; ++i)</span><br><span class="line">            e[i] = A[i] * C[i], f[i] = A[i] * D[i], g[i] = B[i] * C[i], h[i] = B[i] * D[i];</span><br><span class="line">        FFT(e, s, <span class="number">-1</span>), FFT(f, s, <span class="number">-1</span>), FFT(g, s, <span class="number">-1</span>), FFT(h, s, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">            c[i] = (((get(e[i], Mod) &lt;&lt; <span class="number">30</span>) % Mod + (get(f[i], Mod) &lt;&lt; <span class="number">15</span>) % Mod) % Mod + (get(g[i], Mod) &lt;&lt; <span class="number">15</span>) % Mod + get(h[i], Mod) % Mod) % Mod;</span><br><span class="line">    &#125;<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">MTT_2</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> n, <span class="keyword">int</span>* b, <span class="keyword">int</span> m)</span> </span>&#123;<span class="comment">//黑科技优化版本 </span></span><br><span class="line">        <span class="keyword">static</span> cd A[N], B[N], C[N], D[N];</span><br><span class="line">        <span class="keyword">int</span> len = n + m - <span class="number">1</span>, s = <span class="number">2</span>, i, t, bit = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">register</span> LL q, w, e, r;</span><br><span class="line">        <span class="keyword">while</span> (s &lt; len)s &lt;&lt;= <span class="number">1</span>,++bit;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)A[i] = cd(a[i] &amp; zw, a[i] &gt;&gt; <span class="number">15</span>);</span><br><span class="line">        <span class="keyword">for</span> (i = n; i &lt; s; ++i)A[i] = cd(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; ++i)B[i] = cd(b[i] &amp; zw, b[i] &gt;&gt; <span class="number">15</span>);</span><br><span class="line">        <span class="keyword">for</span> (i = m; i &lt; s; ++i)B[i] = cd(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        get_rev(bit);</span><br><span class="line">        FFT(A, s, <span class="number">1</span>), FFT(B, s, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; s; ++i) &#123;</span><br><span class="line">            t = (s - i) &amp; (s - <span class="number">1</span>);</span><br><span class="line">            C[i] = cd(<span class="number">0.5</span> * (A[i].x + A[t].x), <span class="number">0.5</span> * (A[i].y - A[t].y)) * B[i];</span><br><span class="line">            D[i] = cd(<span class="number">0.5</span> * (A[i].y + A[t].y), <span class="number">0.5</span> * (A[t].x - A[i].x)) * B[i];</span><br><span class="line">        &#125;FFT(C, s, <span class="number">-1</span>), FFT(D, s, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            q = LL(C[i].x + <span class="number">0.5</span>) % mod, w = LL(C[i].y + <span class="number">0.5</span>) % mod, e = LL(D[i].x + <span class="number">0.5</span>) % mod, r = LL(D[i].y + <span class="number">0.5</span>) % mod;</span><br><span class="line">            a[i] = (q + ((w + e) &lt;&lt; <span class="number">15</span>) + (r &lt;&lt; <span class="number">30</span>)) % mod;</span><br><span class="line">            <span class="comment">//a[i]=(q+((w+e)&lt;&lt;15)+(r&lt;&lt;30))%mod+mod;</span></span><br><span class="line">            <span class="comment">//a[i]=a[i]&gt;=mod?a[i]-mod:a[i];</span></span><br><span class="line">            <span class="comment">//此题没卡,一般是要写%mod+mod,然后再取模的。 </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-6-BSGS"><a href="#1-6-BSGS" class="headerlink" title="1.6 BSGS"></a>1.6 BSGS</h3><p>求解形如</p><script type="math/tex; mode=display">a^t \equiv b(mod \,p)</script><p>给定a,b,p，其中p是质数</p><p>求解 t</p><p>复杂度为$O(\sqrt{p})$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> myhash &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> fib = <span class="number">2654435769</span>;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> (x * fib) &gt;&gt; <span class="number">14</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*---BSGS---*/</span></span><br><span class="line"><span class="keyword">namespace</span> BSGS &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>  N = <span class="number">1e4</span> + <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> d[<span class="number">1</span>&lt;&lt;<span class="number">18</span>], nxt[N], to[N], id[N], tot;</span><br><span class="line">    <span class="keyword">int</span> stk[N], tail;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> now = myhash::hash(x);</span><br><span class="line">        <span class="keyword">if</span> (!d[now])stk[++tail] = d[now];</span><br><span class="line">        to[++tot] = x, nxt[tot] = d[now], d[now] = tot, id[tot] = i;</span><br><span class="line">    &#125;<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> now = myhash::hash(x);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = d[now]; i; i = nxt[i])</span><br><span class="line">            <span class="keyword">if</span> (to[i] == x)<span class="keyword">return</span> id[i];</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="keyword">while</span> (tail)d[stk[tail--]] = <span class="number">0</span>; tot = <span class="number">0</span>; &#125;<span class="comment">//初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> p)</span> </span>&#123; <span class="keyword">int</span> s = <span class="number">1</span>; <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>, a = a * <span class="number">1ll</span> * a % p)<span class="keyword">if</span> (b &amp; <span class="number">1</span>)s = s * <span class="number">1ll</span> * a % p; <span class="keyword">return</span> s; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">BSGS</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> p)</span> </span>&#123;<span class="comment">//求a^t ≡b (mod p)</span></span><br><span class="line">        <span class="keyword">if</span> (b == <span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(p));</span><br><span class="line">        <span class="keyword">int</span> t = qpow(a, tmp, p), x = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tmp; ++i) &#123;</span><br><span class="line">            x = x * <span class="number">1ll</span> * t % p;</span><br><span class="line">            <span class="keyword">if</span>(query(x)==<span class="number">-1</span>)Insert(x, i);</span><br><span class="line">        &#125;x = b;</span><br><span class="line">        <span class="keyword">int</span> A = qpow(a, p - <span class="number">2</span>, p);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tmp; ++i) &#123;</span><br><span class="line">            t = query(x);</span><br><span class="line">            <span class="keyword">if</span> (~t)<span class="keyword">return</span> t * tmp - i;</span><br><span class="line">            x = x * <span class="number">1ll</span> * A % p;</span><br><span class="line">        &#125;<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用前需要使用init初始化</p><h3 id="1-7-扩展BSGS"><a href="#1-7-扩展BSGS" class="headerlink" title="1.7 扩展BSGS"></a>1.7 扩展BSGS</h3><p>待填坑</p><h3 id="1-8-中国剩余定理"><a href="#1-8-中国剩余定理" class="headerlink" title="1.8 中国剩余定理"></a>1.8 中国剩余定理</h3><p>求解形如</p><script type="math/tex; mode=display">\left \{ \begin{array}{c}x \equiv a_1\,(mod\,b_1) \\x \equiv a_2\,(mod\,b_2)\\\vdots \\x \equiv a_n\,(mod\,b_n)\end{array}\right .</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*---中国剩余定理---*/</span></span><br><span class="line"><span class="keyword">namespace</span> EXCRT &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span> + <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-2</span>;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">        LL a[N], b[N];</span><br><span class="line">        LL ans, M;</span><br><span class="line">    &#125;;</span><br><span class="line">    LL x, y;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> LL <span class="title">exgcd</span><span class="params">(LL a, LL b, LL&amp; x, LL&amp; y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!b) &#123; x = <span class="number">1</span>, y = <span class="number">0</span>; <span class="keyword">return</span> a; &#125;</span><br><span class="line">        LL g = exgcd(b, a % b, y, x);</span><br><span class="line">        y -= (a / b) * x;</span><br><span class="line">        <span class="keyword">return</span> g;</span><br><span class="line">    &#125;<span class="function"><span class="keyword">inline</span> LL <span class="title">Mul</span><span class="params">(LL a, LL b, LL p)</span> </span>&#123;</span><br><span class="line">        LL d = ((<span class="keyword">long</span> <span class="keyword">double</span>)a / p * b + eps);</span><br><span class="line">        LL r = a * b - p * d;</span><br><span class="line">        <span class="keyword">return</span> r &lt; <span class="number">0</span> ? r + p : r;</span><br><span class="line">    &#125;<span class="function"><span class="keyword">inline</span> LL <span class="title">Del</span><span class="params">(LL a, LL b, LL p)</span> </span>&#123; <span class="keyword">return</span> a -= b, a &lt; <span class="number">0</span> ? a + p : a; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">CRT</span><span class="params">(node&amp; a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        a.ans = a.a[<span class="number">1</span>], a.M = a.b[<span class="number">1</span>];</span><br><span class="line">        LL c, exg, p;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;<span class="comment">//a.ans+x*a.M≡a.a[i](mod a.b[i]) </span></span><br><span class="line">            c = Del(a.a[i], a.ans, a.b[i]);<span class="comment">//x*a.M≡a.a[i]-a.ans(mod a.b[i])</span></span><br><span class="line">            exg = exgcd(a.M, a.b[i], x, y);</span><br><span class="line">            p = a.b[i] / exg;</span><br><span class="line">            <span class="keyword">if</span> (c % exg != <span class="number">0</span>) &#123; a.ans = <span class="number">-1</span>; <span class="keyword">return</span>; &#125;</span><br><span class="line">            x = Mul(x, c / exg, p);</span><br><span class="line">            a.ans += x * a.M;</span><br><span class="line">            a.M *= p;</span><br><span class="line">            a.ans = (a.ans % a.M + a.M) % a.M;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-9-矩阵树"><a href="#1-9-矩阵树" class="headerlink" title="1.9 矩阵树"></a>1.9 矩阵树</h3><p>基础应用：<br>给定一张图，求生成树个数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> wjr &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uint unsigned int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bs bitset<span class="meta-string">&lt;N&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lb(x) x&amp;-x</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line">    <span class="keyword">int</span> mod = <span class="number">998244353</span>, inv2 = <span class="number">499122177</span>, inf = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">initial</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        inv2 = (mod + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a * <span class="number">1ll</span> * b % mod; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a += b, a &gt;= mod ? a - mod : a; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a -= b, a &lt; <span class="number">0</span> ? a + mod : a; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">int</span> s = <span class="number">1</span>; <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>, a = mul(a, a))<span class="keyword">if</span> (b &amp; <span class="number">1</span>)s = mul(s, a); <span class="keyword">return</span> s; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> T <span class="title">sqr</span><span class="params">(<span class="keyword">register</span> T x)</span> </span>&#123; <span class="keyword">return</span> x * x; &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> wjr;</span><br><span class="line"><span class="comment">/*---Matrix_Tree矩阵树---*/</span></span><br><span class="line"><span class="keyword">namespace</span> Matrix_tree &#123;<span class="comment">//用于求解生成树个数 </span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">205</span>;</span><br><span class="line">    <span class="keyword">int</span> a[N][N];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123; ++a[u][u], ++a[v][v], --a[u][v], --a[v][u]; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gauss</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;<span class="comment">//如果是m*m矩阵,n=m-1,即忽略最后一行 </span></span><br><span class="line">        --n;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>, i, j, k, div, tmp;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            k = i;</span><br><span class="line">            <span class="keyword">for</span> (j = i; j &lt;= n; ++j)</span><br><span class="line">                <span class="keyword">if</span> (a[j][i]) &#123; k = j; <span class="keyword">break</span>; &#125;</span><br><span class="line">            <span class="keyword">if</span> (k != i)ans = -ans, swap(a[i], a[k]);</span><br><span class="line">            <span class="keyword">if</span> (!a[i][i])<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            div = qpow(a[i][i], mod - <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!a[j][i])<span class="keyword">continue</span>;</span><br><span class="line">                tmp = mul(div, a[j][i]);</span><br><span class="line">                <span class="keyword">for</span> (k = i; k &lt;= n; ++k)</span><br><span class="line">                    a[j][k] = del(a[j][k], mul(tmp, a[i][k]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            ans = mul(ans, a[i][i]);</span><br><span class="line">        <span class="keyword">return</span> ans &lt; <span class="number">0</span> ? ans + mod : ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">NonePrimeGauss</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;<span class="comment">//模数为非质数的求法</span></span><br><span class="line">        --n;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>, i, j, k, tmp;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                <span class="keyword">while</span> (a[j][i]) &#123;</span><br><span class="line">                    tmp = a[i][i] ? a[j][i] / a[i][i] : <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">for</span> (k = i; k &lt;= n; ++k)</span><br><span class="line">                        a[j][k] = del(a[j][k], mul(tmp, a[i][k]));</span><br><span class="line">                    ans = -ans, swap(a[i], a[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            ans = mul(ans, a[i][i]);</span><br><span class="line">        <span class="keyword">return</span> ans &lt; <span class="number">0</span> ? ans + mod : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-10-高斯消元法"><a href="#1-10-高斯消元法" class="headerlink" title="1.10 高斯消元法"></a>1.10 高斯消元法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> wjr &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uint unsigned int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bs bitset<span class="meta-string">&lt;N&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lb(x) x&amp;-x</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>, inv2 = <span class="number">499122177</span>, inf = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> eps=<span class="number">1e-6</span>;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a * <span class="number">1ll</span> * b % mod; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a += b, a &gt;= mod ? a - mod : a; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a -= b, a &lt; <span class="number">0</span> ? a + mod : a; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">int</span> s = <span class="number">1</span>; <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>, a = mul(a, a))<span class="keyword">if</span> (b &amp; <span class="number">1</span>)s = mul(s, a); <span class="keyword">return</span> s; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> T <span class="title">sqr</span><span class="params">(<span class="keyword">register</span> T x)</span> </span>&#123; <span class="keyword">return</span> x * x; &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> wjr;</span><br><span class="line"><span class="comment">/*---高斯消元---*/</span></span><br><span class="line"><span class="keyword">namespace</span> Gauss &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">105</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">matrix</span> &#123;</span><span class="comment">//整数（带取模）高斯消元</span></span><br><span class="line">        <span class="keyword">int</span> a[N][N];</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">doublematrix</span> &#123;</span><span class="comment">//小数高斯消元</span></span><br><span class="line">        <span class="keyword">double</span> a[N][N];</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Gauss</span><span class="params">(matrix&amp;x, <span class="keyword">int</span> n,<span class="keyword">int</span> m)</span> </span>&#123;<span class="comment">//n行m列 int（带取模）高斯消元</span></span><br><span class="line">        <span class="keyword">int</span> i, j, k, tmp;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            k = i;</span><br><span class="line">            <span class="keyword">for</span> (j = i; j &lt;= n; ++j)</span><br><span class="line">                <span class="keyword">if</span> (x.a[j][i]) &#123; k = j; <span class="keyword">break</span>; &#125;</span><br><span class="line">            <span class="keyword">if</span> (i != k)swap(x.a[k], x.a[i]);</span><br><span class="line">            tmp = qpow(x.a[i][i], mod - <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">for</span> (k = i; k &lt;= m; ++k)x.a[i][k] = mul(x.a[i][k], tmp);</span><br><span class="line">            <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                tmp = x.a[j][i];</span><br><span class="line">                <span class="keyword">for</span> (k = i; k &lt;= m; ++k)</span><br><span class="line">                    x.a[j][k] = del(x.a[j][k], mul(tmp, x.a[i][k]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i = n ; i ; --i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                tmp=x.a[i][j];</span><br><span class="line">                x.a[i][j]=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(k=n+<span class="number">1</span>;k&lt;=m;++k)</span><br><span class="line">                    x.a[i][k]=del(x.a[i][k],mul(x.a[j][k],tmp));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Gauss</span><span class="params">(doublematrix&amp; x, <span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;<span class="comment">//double高斯消元</span></span><br><span class="line">        <span class="keyword">int</span> i, j, k, tmp;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            k = i;</span><br><span class="line">            <span class="keyword">for</span> (j = i; j &lt;= n; ++j)</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">abs</span>(x.a[j][i])&gt;<span class="built_in">abs</span>(x.a[k][i])) k = j; </span><br><span class="line">            <span class="keyword">if</span> (i != k)swap(x.a[k], x.a[i]);</span><br><span class="line">            <span class="keyword">if</span> (x.a[i][i] &lt; <span class="number">0</span>)<span class="keyword">return</span> ;<span class="comment">//出问题了</span></span><br><span class="line">            tmp=x.a[i][i];</span><br><span class="line">            <span class="keyword">for</span> (k = i; k &lt;= m; ++k)x.a[i][k]/=tmp;</span><br><span class="line">            <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                tmp = x.a[j][i];</span><br><span class="line">                <span class="keyword">for</span> (k = i; k &lt;= m; ++k)</span><br><span class="line">                    x.a[j][k] -= tmp * x.a[i][k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i = n; i; --i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                tmp = x.a[i][j];</span><br><span class="line">                x.a[i][j] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (k = n + <span class="number">1</span>; k &lt;= m; ++k)</span><br><span class="line">                    x.a[i][k] -=  x.a[j][k]* tmp ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="1-11-莫比乌斯反演"><a href="#1-11-莫比乌斯反演" class="headerlink" title="1.11 莫比乌斯反演"></a>1.11 莫比乌斯反演</h3><ol><li>对于任意正整数 n ，$\sum_{d|n}\mu(d)=[n=1]$（这个性质非常重要，后面给出证明）</li><li>对于任意正整数 n , $\sum_{d|n}{\frac{\mu(d)}{d}}=\frac{\phi(n)}{n}$（这个性质也很重要）</li></ol><p>莫比乌斯函数求解：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> mu[maxn],pri[maxn];<span class="comment">//prime简写</span></span><br><span class="line"><span class="keyword">bool</span> f[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>]=<span class="number">1</span>;f[<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!f[i])&#123;</span><br><span class="line">            pri[++pri[<span class="number">0</span>]]=i;</span><br><span class="line">            mu[i]=<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=pri[<span class="number">0</span>]&amp;&amp;i*pri[j]&lt;=n;++j)&#123;</span><br><span class="line">            f[i*pri[j]]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%pri[j]==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">            mu[i*pri[j]]=-mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>定理：F(n)和f(n)是定义在非负整数集合上的两个函数，并且满足条件：</li></ul><script type="math/tex; mode=display">F(n)=\sum_{d|n} f(d)</script><p>​       那么存在一个结论：</p><script type="math/tex; mode=display">f(n)=\sum_{d|n}\mu(d)F(\frac{n}{d})</script><ul><li>当然，莫比乌斯反演有另外的一种形式，当F(n)和f(n)满足：<script type="math/tex; mode=display">F(n)=\sum_{n|d}f(d)</script>可以推出<script type="math/tex; mode=display">f(n)=\sum_{n|d}\mu(\frac{d}{n})F(d)</script>通常用整除分块优化复杂度。</li></ul><h3 id="1-12-狄利克雷卷积"><a href="#1-12-狄利克雷卷积" class="headerlink" title="1.12 狄利克雷卷积"></a>1.12 狄利克雷卷积</h3><ul><li><p>基本性质</p><p>一个函数卷积自己$mod$次就是$[n=1]$，卷积自己$mod+1$次就是自己</p></li><li><p>求法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dirichlet</span><span class="params">(<span class="keyword">int</span> f[],<span class="keyword">int</span> g[],<span class="keyword">int</span> ans[],<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(ans,<span class="number">0</span>,<span class="keyword">sizeof</span> ans);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;i*j&lt;=n;j++)</span><br><span class="line">            ans[i*j]+=f[i]*g[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-数据结构"><a href="#2-数据结构" class="headerlink" title="2. 数据结构"></a>2. 数据结构</h2><h3 id="2-1-双栈模拟-队列-双端队列"><a href="#2-1-双栈模拟-队列-双端队列" class="headerlink" title="2.1 双栈模拟 队列/双端队列"></a>2.1 双栈模拟 队列/双端队列</h3><ul><li>双栈模拟队列（兼容队列和双端队列）</li></ul><p>主要用途：</p><p>栈中容易维护，但是队列/双端队列中不好维护</p><p>将队列/双端队列转为栈的形式维护</p><p>复杂度O(n log n * 栈中维护复杂度)</p><hr><p>a[0]是队首栈，a[1]是队尾栈</p><ul><li><p>push：插入到栈 F 中。</p></li><li><p>pop：如果 S 非空，让 S 弹栈；否则将F中前一半的元素倒着插入S，F中只保留后一半，再在S中弹栈。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a[0]表示队首栈，a[1]表示队尾栈</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stk</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> st[N],top;</span><br><span class="line">&#125;a[<span class="number">2</span>];</span><br><span class="line"><span class="comment">//向队首/队尾压栈，压栈时一般需要维护栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> o,<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    a[o].st[++a[o].top]=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">(<span class="keyword">int</span> o)</span> </span>&#123;<span class="comment">//弹栈，兼容队列和双端队列，复杂度为O(nlogn)</span></span><br><span class="line">    <span class="keyword">if</span> (a[o].top) &#123;<span class="comment">//如果栈中有元素直接弹栈</span></span><br><span class="line">        --a[o].top;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则，将另一个栈中一半的元素倒着压入该栈并弹栈</span></span><br><span class="line">    <span class="keyword">int</span> k=!o;</span><br><span class="line">    <span class="keyword">int</span> mid=(a[k].top+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>,top=a[k].top;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=mid;i&gt;=<span class="number">1</span>;--i)push(o,a[k].st[i]);</span><br><span class="line">    a[k].top=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=mid+<span class="number">1</span>;i&lt;=top;++i)push(k,a[k].st[i]);</span><br><span class="line">    --a[o].top;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-哈希表"><a href="#2-2-哈希表" class="headerlink" title="2. 2 哈希表"></a>2. 2 哈希表</h3><h4 id="斐波那契散列法-卡常用"><a href="#斐波那契散列法-卡常用" class="headerlink" title="斐波那契散列法(卡常用)"></a>斐波那契散列法(卡常用)</h4><p>1，对于16位整数而言，这个乘数是40503 </p><p>2，对于32位整数而言，这个乘数是2654435769 </p><p>3，对于64位整数而言，这个乘数是11400714819323198485</p><p>对于常见的32位整数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> fib= <span class="number">2654435769</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> (x* fib)&gt;&gt;<span class="number">14</span>;&#125;</span><br><span class="line"><span class="comment">//根据需要&gt;&gt;p，p越大所需空间越小，也越容易产生冲突</span></span><br></pre></td></tr></table></figure><h3 id="2-3-并查集"><a href="#2-3-并查集" class="headerlink" title="2.3 并查集"></a>2.3 并查集</h3><p>合并</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    u=find(u),v=find(v);</span><br><span class="line">    <span class="keyword">if</span>(u==v)<span class="keyword">return</span>;</span><br><span class="line">    fa[u]=v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启发式合并</p><p>并查集基础上记个size</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    u=find(u),v=find(v);</span><br><span class="line">    <span class="keyword">if</span>(u==v)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(siz[u]&gt;siz[v])</span><br><span class="line">        swap(u,v);</span><br><span class="line">    fa[u]=v;</span><br><span class="line">    siz[v]+=siz[u];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于路径压缩单次合并可能造成大量修改，有时路径压缩并不适合使用。例如，在可持久化并查集、线段树分治 + 并查集中，一般使用只启发式合并的并查集。</p><hr><h4 id="带权并查集"><a href="#带权并查集" class="headerlink" title="带权并查集"></a>带权并查集</h4><p>在并查集的<strong>边上</strong>定义某种权值并维护即可。</p><h3 id="2-4-堆"><a href="#2-4-堆" class="headerlink" title="2.4 堆"></a>2.4 堆</h3><h4 id="左偏树"><a href="#左偏树" class="headerlink" title="左偏树"></a>左偏树</h4><p>不带并查集</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,v,d;<span class="comment">//左儿子，右儿子，权值，dis</span></span><br><span class="line">&#125;a[N];</span><br><span class="line"><span class="comment">//合并</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x||!y)<span class="keyword">return</span> x|y;</span><br><span class="line">    <span class="keyword">if</span>(a[x].v&gt;a[y].v)swap(x,y);</span><br><span class="line">    a[x].r=Merge(a[x].r,y);</span><br><span class="line">    <span class="keyword">if</span>(a[a[x].r].d&gt;a[a[x].l].d)</span><br><span class="line">        swap(a[x].l,a[x].r);</span><br><span class="line">    a[x].d=a[a[x].r].d+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除根节点</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    Merge(a[x].l,a[x].r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>带并查集</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,v,d;<span class="comment">//左儿子，右儿子，权值，dis</span></span><br><span class="line">&#125;a[N];</span><br><span class="line"><span class="keyword">int</span> fa[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> x==fa[x]?x:fa[x]=find(fa[x]);&#125;</span><br><span class="line"><span class="comment">//合并</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x||!y)<span class="keyword">return</span> x|y;</span><br><span class="line">    <span class="keyword">if</span>(a[x].v&gt;a[y].v)swap(x,y);</span><br><span class="line">    a[x].r=Merge(a[x].r,y);</span><br><span class="line">    <span class="keyword">if</span>(a[a[x].r].d&gt;a[a[x].l].d)</span><br><span class="line">        swap(a[x].l,a[x].r);</span><br><span class="line">    a[x].d=a[a[x].r].d+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除根节点</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k=Merge(a[x].l,a[x].r);</span><br><span class="line">    fa[x]=fa[k]=k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将堆顶是x和y的合并，注意：并不是x,y所在堆</span></span><br><span class="line"><span class="comment">//需要先find</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _Merge(<span class="keyword">int</span> x,<span class="keyword">int</span> y)&#123;</span><br><span class="line">    <span class="keyword">int</span> k=Merge(x,y);</span><br><span class="line">    fa[x]=fa[y]=k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-李超线段树"><a href="#2-5-李超线段树" class="headerlink" title="2.5 李超线段树"></a>2.5 李超线段树</h3><p>功能：给定若干个线段，求某个点的最值。</p><p>用途：</p><ul><li>$min\{A<em>x+B\}/max\{A</em>x-B\}$  其中 x 为定值，可以用于优化DP等</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">line</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> k,b;<span class="comment">//斜率和截距</span></span><br><span class="line">    <span class="keyword">int</span> id;<span class="comment">//记录线段编号</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getf</span><span class="params">(line&amp;x,<span class="keyword">int</span> pos)</span></span>&#123;<span class="keyword">return</span> x.k*pos+x.b;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">inter</span><span class="params">(line&amp;a,line&amp;b)</span></span>&#123;<span class="keyword">return</span> (a.b-b.b)/(b.k-a.k); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span>&amp; x, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> ll, <span class="keyword">int</span> rr, line&amp; k)</span> </span>&#123;<span class="comment">//[ll,rr]上的线段</span></span><br><span class="line">    <span class="keyword">if</span> (!x)x = ++cnt;</span><br><span class="line">    <span class="keyword">if</span> (rr&lt;L || ll&gt;R)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = L + R &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (ll &lt;= L &amp;&amp; R &lt;= rr) &#123;</span><br><span class="line">        <span class="keyword">double</span> fl = getf(a[x], L), fr = getf(a[x], R), ql = getf(k, L), qr = getf(k, R);</span><br><span class="line">        <span class="keyword">if</span> (!a[x].id) &#123;<span class="comment">//没有就直接插入</span></span><br><span class="line">            a[x] = k;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ql &lt;= fl &amp;&amp; qr &lt;= fr)<span class="keyword">return</span>;<span class="comment">//如果整个区间比该节点线段更劣，或者相同但编号更大</span></span><br><span class="line">        <span class="keyword">if</span> (ql &gt;= fl &amp;&amp; qr &gt;= fr) &#123;<span class="comment">//如果整个区间都比该节点线段更优</span></span><br><span class="line">            a[x] = k;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> i = inter(a[x], k);<span class="comment">//交点</span></span><br><span class="line">        <span class="keyword">if</span> (ql &gt;= fl) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt;= mid)update(lc, L, mid, ll, rr, k);</span><br><span class="line">            <span class="keyword">else</span> update(rc, mid + <span class="number">1</span>, R, ll, rr, a[x]), a[x] = k;<span class="comment">//将a[x]递归更新子区间</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; mid)update(rc, mid + <span class="number">1</span>, R, ll, rr, k);</span><br><span class="line">            <span class="keyword">else</span> update(lc, L, mid, ll, rr, a[x]), a[x] = k;<span class="comment">//将a[x]递归更新子区间</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    update(lc, L, mid, ll, rr, k);</span><br><span class="line">    update(rc, mid + <span class="number">1</span>, R, ll, rr, k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查询的话根据需要，用所有包含pos的区间更新答案</span></span><br></pre></td></tr></table></figure><h3 id="2-6-吉斯林线段树"><a href="#2-6-吉斯林线段树" class="headerlink" title="2.6 吉斯林线段树"></a>2.6 吉斯林线段树</h3><p>功能：</p><p>对区间取min或max，求区间最值/区间和。</p><hr><p>线段树每个节点记录最大值，次大值，最大值个数，标记。</p><ol><li>如果 $MAX\leq t$，显然这个 是没有意义的，直接返回；</li><li>如果$Se &lt; t \leq Max$ ，那么这个 就能更新当前区间中的最大值。于是我们让区间和加上 ，然后更新 为 ，并打一个标记。</li><li>如果 $t\leq Se$，那么这时你发现你不知道有多少个数涉及到更新的问题。于是我们的策略就是，暴力递归向下操作。然后上传信息。</li></ol><p>势能分析法可得复杂度是O(mlogn)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    sum[x]=sum[lc]+sum[rc];</span><br><span class="line">    <span class="keyword">if</span> (mx[lc] == mx[rc]) &#123;</span><br><span class="line">        mx[x]=mx[lc];</span><br><span class="line">        se[x]=max(se[lc],se[rc]);</span><br><span class="line">        cnt[x]=cnt[lc]+cnt[rc];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (mx[lc] &gt; mx[rc]) &#123;</span><br><span class="line">        mx[x]=mx[lc];</span><br><span class="line">        se[x]=max(se[lc],mx[rc]);</span><br><span class="line">        cnt[x]=cnt[lc];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        mx[x]=mx[rc];</span><br><span class="line">        se[x]=max(mx[lc],se[rc]);</span><br><span class="line">        cnt[x]=cnt[rc];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushr</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(mx[x]&lt;=v)<span class="keyword">return</span>;</span><br><span class="line">    sum[x]+=(v-mx[x])*<span class="number">1ll</span>*cnt[x];</span><br><span class="line">    tag[x]=mx[x]=v;</span><br><span class="line">&#125;<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tag[x] != -inf) &#123;</span><br><span class="line">        pushr(lc,tag[x]);</span><br><span class="line">        pushr(rc,tag[x]);</span><br><span class="line">        tag[x]=-inf;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span>&amp; x, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    x=++tot;</span><br><span class="line">    tag[x]=-inf;</span><br><span class="line">    <span class="keyword">if</span> (L == R) &#123;</span><br><span class="line">        mx[x]=sum[x]=b[L];</span><br><span class="line">        cnt[x]=<span class="number">1</span>;</span><br><span class="line">        se[x]=-inf;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="keyword">int</span> mid=L+R&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    build(lc,L,mid);</span><br><span class="line">    build(rc,mid+<span class="number">1</span>,R);</span><br><span class="line">    pushup(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> ll, <span class="keyword">int</span> rr, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(mx[x]&lt;=v)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (ll &lt;= L &amp;&amp; R &lt;= rr&amp;&amp;se[x]&lt;v) <span class="keyword">return</span> pushr(x,v);</span><br><span class="line">    <span class="keyword">int</span> mid=L+R&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    pushdown(x);</span><br><span class="line">    <span class="keyword">if</span>(ll&lt;=mid)update(lc,L,mid,ll,rr,v);</span><br><span class="line">    <span class="keyword">if</span>(rr&gt;mid) update(rc,mid+<span class="number">1</span>,R,ll,rr,v);</span><br><span class="line">    pushup(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-7-K-D-tree"><a href="#2-7-K-D-tree" class="headerlink" title="2.7 K-D tree"></a>2.7 K-D tree</h3><p>k维n个点求 最近点对/最远点对，k远点对，k近点对等（k不能很大）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*---KD-Tree---*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">sqr</span><span class="params">(T&amp;x)</span></span>&#123;<span class="keyword">return</span> x*x;&#125;</span><br><span class="line"><span class="keyword">namespace</span> KDT &#123; </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>, M = N &lt;&lt; <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lc ch[x][0]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rc ch[x][1]</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pnt</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> x[<span class="number">2</span>];</span><br><span class="line">    &#125;a[N];</span><br><span class="line">    <span class="keyword">int</span> opt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span> </span><br><span class="line">        <span class="keyword">int</span> dis; </span><br><span class="line">        node(<span class="keyword">int</span> a = <span class="number">0</span>) &#123; </span><br><span class="line">            dis = a; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> node&amp; other)<span class="keyword">const</span> &#123; <span class="keyword">return</span> dis &gt; other.dis; &#125; </span><br><span class="line">    &#125;;<span class="comment">//小根堆 </span></span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;node&gt;q;</span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">register</span> pnt a, <span class="keyword">register</span> pnt b)</span> </span>&#123; <span class="keyword">return</span> a.x[opt] &lt; b.x[opt]; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(pnt a, pnt b)</span> </span>&#123; <span class="keyword">return</span> sqr(a.x[<span class="number">0</span>] - b.x[<span class="number">0</span>]) + sqr(a.x[<span class="number">1</span>] - b.x[<span class="number">1</span>]); &#125;</span><br><span class="line">    <span class="keyword">int</span> ch[M][<span class="number">2</span>], minn[M][<span class="number">2</span>], maxn[M][<span class="number">2</span>], cnt;</span><br><span class="line">    pnt*d[M];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp;x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i)</span><br><span class="line">            maxn[x][i] = minn[x][i] = d[x]-&gt;x[i];</span><br><span class="line">        <span class="keyword">if</span> (lc)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i)</span><br><span class="line">                maxn[x][i] = max(maxn[x][i], maxn[lc][i]), </span><br><span class="line">                minn[x][i] = min(minn[x][i], minn[lc][i]);</span><br><span class="line">        <span class="keyword">if</span> (rc)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i)</span><br><span class="line">                maxn[x][i] = max(maxn[x][i], maxn[rc][i]), </span><br><span class="line">                minn[x][i] = min(minn[x][i], minn[rc][i]);</span><br><span class="line">    &#125;<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (L &gt; R)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> x = ++cnt; </span><br><span class="line">        opt = k;</span><br><span class="line">        <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        nth_element(a + L, a + mid, a + R + <span class="number">1</span>, cmp);</span><br><span class="line">        d[x] = &amp;a[mid];</span><br><span class="line">        lc = build(L, mid - <span class="number">1</span>, k ^ <span class="number">1</span>), rc = build(mid + <span class="number">1</span>, R, k ^ <span class="number">1</span>);</span><br><span class="line">        pushup(x);</span><br><span class="line">    &#125;<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">mindis</span><span class="params">(pnt&amp;a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sqr(max(a.x[<span class="number">0</span>]-maxn[b][<span class="number">0</span>],<span class="number">0</span>)+max(minn[b][<span class="number">0</span>]-a.x[<span class="number">0</span>],<span class="number">0</span>))+sqr(max(a.x[<span class="number">1</span>]-maxn[b][<span class="number">1</span>],<span class="number">0</span>)+max(minn[b][<span class="number">1</span>]-a.x[<span class="number">1</span>],<span class="number">0</span>));</span><br><span class="line">    &#125;<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">maxdis</span><span class="params">(pnt&amp;a, <span class="keyword">int</span> b)</span> </span>&#123;<span class="comment">//最远距离</span></span><br><span class="line">        <span class="keyword">return</span> max(sqr(maxn[b][<span class="number">0</span>] - a.x[<span class="number">0</span>]), sqr(minn[b][<span class="number">0</span>] - a.x[<span class="number">0</span>])) + max(sqr(maxn[b][<span class="number">1</span>] - a.x[<span class="number">1</span>]), sqr(minn[b][<span class="number">1</span>] - a.x[<span class="number">1</span>]));</span><br><span class="line">     &#125;<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">kqueryMax</span><span class="params">(<span class="keyword">int</span> x, pnt&amp;O)</span> </span>&#123;<span class="comment">//k远点对查询</span></span><br><span class="line">         <span class="keyword">if</span>(!x)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> dl = -inf, dr = -inf;</span><br><span class="line">     <span class="keyword">if</span> (lc)dl = maxdis(O, lc);</span><br><span class="line">        <span class="keyword">if</span> (rc)dr = maxdis(O, rc);</span><br><span class="line">        <span class="keyword">if</span> (d[x] != &amp;O) &#123;</span><br><span class="line">            <span class="keyword">int</span> dis = f(*d[x], O);</span><br><span class="line">            <span class="keyword">if</span> (q.top().dis &lt; dis)</span><br><span class="line">                q.pop(), q.push(dis);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dl &gt; dr) &#123; </span><br><span class="line">            <span class="keyword">if</span> (q.top().dis &lt; dl)kqueryMax(lc, O); </span><br><span class="line">            <span class="keyword">if</span> (q.top().dis &lt; dr)kqueryMax(rc, O); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; </span><br><span class="line">            <span class="keyword">if</span> (q.top().dis &lt; dr)kqueryMax(rc, O); </span><br><span class="line">            <span class="keyword">if</span> (q.top().dis &lt; dl)kqueryMax(lc, O); </span><br><span class="line">        &#125;</span><br><span class="line">     &#125;<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">queryMin</span><span class="params">(<span class="keyword">int</span> x, pnt&amp;O)</span> </span>&#123;<span class="comment">//最近距离</span></span><br><span class="line">         <span class="keyword">if</span> (!x)<span class="keyword">return</span>;</span><br><span class="line">         <span class="keyword">int</span> dl = inf, dr = inf;</span><br><span class="line">         <span class="keyword">if</span> (lc)dl = mindis(O, lc);</span><br><span class="line">         <span class="keyword">if</span> (rc)dr = mindis(O, rc);</span><br><span class="line">         <span class="keyword">if</span> (d[x] != &amp;O)<span class="comment">//不是相同的点</span></span><br><span class="line">             ans = min(ans, f(*d[x], O));</span><br><span class="line">         <span class="keyword">if</span> (dl &lt; dr) &#123;</span><br><span class="line">             <span class="keyword">if</span> (dl &lt; ans)queryMin(lc, O);</span><br><span class="line">             <span class="keyword">if</span> (dr &lt; ans)queryMin(rc, O);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="keyword">if</span> (dr &lt; ans)queryMin(rc, O);</span><br><span class="line">             <span class="keyword">if</span> (dl &lt; ans)queryMin(lc, O);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">queryMax</span><span class="params">(<span class="keyword">int</span> x, pnt&amp; O)</span> </span>&#123;<span class="comment">//最远距离</span></span><br><span class="line">         <span class="keyword">if</span> (!x)<span class="keyword">return</span>;</span><br><span class="line">         <span class="keyword">int</span> dl = -inf, dr = -inf;</span><br><span class="line">         <span class="keyword">if</span> (lc)dl = maxdis(O, lc);</span><br><span class="line">         <span class="keyword">if</span> (rc)dr = maxdis(O, rc);</span><br><span class="line">         <span class="keyword">if</span> (d[x] != &amp;O)<span class="comment">//不是相同的点</span></span><br><span class="line">             ans = max(ans, f(*d[x], O));</span><br><span class="line">         <span class="keyword">if</span> (dl &gt; dr) &#123;</span><br><span class="line">             <span class="keyword">if</span> (ans &lt; dl)queryMax(lc, O);</span><br><span class="line">             <span class="keyword">if</span> (ans &lt; dr)queryMax(rc, O);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="keyword">if</span> (ans &lt; dr)queryMax(rc, O);</span><br><span class="line">             <span class="keyword">if</span> (ans &lt; dl)queryMax(lc, O);</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> lc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> rc </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意事项：</p><p>1.这是int类型的点，坐标是double的话改一下即可</p><p>2.单次查询复杂度最坏是O(n)</p><p>3.k远点对需要现在最小堆丢入2k个 0，k近点对即丢入2k个inf</p><h2 id="3-字符串"><a href="#3-字符串" class="headerlink" title="3.字符串"></a>3.字符串</h2><h3 id="3-1-KMP"><a href="#3-1-KMP" class="headerlink" title="3.1 KMP"></a>3.1 KMP</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*---KMP---*/</span></span><br><span class="line"><span class="keyword">namespace</span> KMP &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span> + <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> nxt[N],n;</span><br><span class="line">    <span class="keyword">char</span> s[N];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">getnxt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">-1</span>;</span><br><span class="line">        nxt[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span>(j==<span class="number">-1</span>||s[i]==s[j])</span><br><span class="line">                nxt[++i]=++j;</span><br><span class="line">            <span class="keyword">else</span> j=nxt[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">KMP</span><span class="params">(<span class="keyword">char</span>* g, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; n &amp;&amp; i &lt; m) &#123;</span><br><span class="line">            <span class="keyword">if</span>(j==<span class="number">-1</span>||s[j]==g[i])</span><br><span class="line">                ++i,++j;</span><br><span class="line">            <span class="keyword">else</span> j=nxt[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-SA"><a href="#3-2-SA" class="headerlink" title="3.2 SA"></a>3.2 SA</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*---SA后缀数组---*/</span></span><br><span class="line"><span class="keyword">namespace</span> SA &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span> + <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> tax[N], sa[N], rk[N], tp[N];</span><br><span class="line">    <span class="keyword">int</span> h[N], bit[N], s[<span class="number">30</span>];</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">int</span> Min[N][<span class="number">19</span>];</span><br><span class="line">    <span class="comment">//h为height数组,Min用于RMQ</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;<span class="comment">//预处理 </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)bit[i] = bit[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        s[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= bit[n]; ++i)s[i] = s[i - <span class="number">1</span>] &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">qsort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="built_in">memset</span>(tax + <span class="number">1</span>, <span class="number">0</span>, m &lt;&lt; <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i)++tax[rk[i]];</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; ++i)tax[i] += tax[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (i = n; i; --i)sa[tax[rk[tp[i]]]--] = tp[i];</span><br><span class="line">    &#125;<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">suffix_sort</span><span class="params">(<span class="keyword">register</span> <span class="keyword">char</span>* s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i, j, p;</span><br><span class="line">        n = <span class="built_in">strlen</span>(s + <span class="number">1</span>), m = <span class="number">26</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i)rk[i] = s[i] - <span class="string">&#x27;a&#x27;</span>, tp[i] = i;</span><br><span class="line">        qsort();</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>, p = <span class="number">0</span>; p &lt; n; m = p, i &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            p = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= i; ++j)tp[++p] = n - i + j;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n; ++j)<span class="keyword">if</span> (sa[j] &gt; i)tp[++p] = sa[j] - i;</span><br><span class="line">            qsort(), swap(tp, rk);</span><br><span class="line">            rk[sa[<span class="number">1</span>]] = p = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">2</span>; j &lt;= n; ++j)</span><br><span class="line">                rk[sa[j]] = (tp[sa[j]] == tp[sa[j - <span class="number">1</span>]] &amp;&amp; tp[sa[j] + i] == tp[sa[j - <span class="number">1</span>] + i]) ? p : ++p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">register</span> <span class="keyword">char</span>* s)</span> </span>&#123;</span><br><span class="line">        suffix_sort(s);</span><br><span class="line">        <span class="keyword">int</span> i, j, k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (k)--k;</span><br><span class="line">            j = sa[rk[i] - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">while</span> (s[i + k] == s[j + k])++k;</span><br><span class="line">            h[rk[i]] = k;</span><br><span class="line">        &#125;<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i)Min[i][<span class="number">0</span>] = h[i];</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= bit[n]; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> p = s[j - <span class="number">1</span>], q = s[j];</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n - q + <span class="number">1</span>; ++i)</span><br><span class="line">                Min[i][j] = min(Min[i][j - <span class="number">1</span>], Min[i + p][j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-Manacher"><a href="#3-3-Manacher" class="headerlink" title="3.3 Manacher"></a>3.3 Manacher</h3><p>求出一个字符串每个位置的最长回文子串</p><p>$p[i]$表示从$i$ 向两侧延伸（当然要保证两侧对应位置相等）的最大长度。</p><p>为了处理方便，我们把原串每两个字符之间加一个（不包含在原串中的）<code>#</code>，开头加一个 <code>$</code>。</p><p>这样得到的回文串长度就保证是奇数了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Manacher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mx=<span class="number">0</span>,id;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;n ; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(mx&gt;i)p[i]=min(p[id*<span class="number">2</span>-i],p[id]+id-i);</span><br><span class="line">        <span class="keyword">else</span> p[i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=p[i]&amp;&amp;s[i+p[i]]==s[i-p[i]])++p[i];</span><br><span class="line">        <span class="keyword">if</span> (p[i] + i &gt; mx) &#123;</span><br><span class="line">            mx=p[i]+i;</span><br><span class="line">            id=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-随机化"><a href="#4-随机化" class="headerlink" title="4.随机化"></a>4.随机化</h2><h3 id="4-1-随机数"><a href="#4-1-随机数" class="headerlink" title="4.1 随机数"></a>4.1 随机数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"><span class="function">mt19937 <span class="title">mt_rand</span><span class="params">(time(<span class="number">0</span>))</span></span>;</span><br><span class="line">mt_rand();</span><br></pre></td></tr></table></figure><h3 id="4-2-模拟退火"><a href="#4-2-模拟退火" class="headerlink" title="4.2 模拟退火"></a>4.2 模拟退火</h3><p>对于答案更优的就接受，对于答案更劣的概率接受</p><p>假设当前温度为Temp，则接受的概率为$e^{\frac{\Delta f}{Temp}}(\Delta f&lt;0)$</p><p>其中有几个需要注意的点：</p><ul><li>初始点的选取对算法结果有一定的影响，最好是多次运行对结果进行综合判断。</li><li>在算法运行初期，温度下降快，避免接受过多的差结果。当运行时间增加，温度下降减缓，以便于更快稳定结果。</li><li>当迭代次数增加到一定次数时，结果可能已经达到稳定，但是距离算法结束还有一段时间。在设计程序时应该加入适当的输出条件，满足输出条件即可结束程序。</li></ul><p>降温可以每次乘以一个$tmp,tmp\in [0.95,0.99]$</p><p>或者自定义温度函数以使得算法更优。</p><p>（模拟退火乱搞过了ECFinal题）</p><h2 id="5-动态规划"><a href="#5-动态规划" class="headerlink" title="5.动态规划"></a>5.动态规划</h2><h3 id="5-1-多重背包"><a href="#5-1-多重背包" class="headerlink" title="5.1 多重背包"></a>5.1 多重背包</h3><p>用二进制分组优化</p><p>例如：</p><ul><li>6=1+2+3</li><li>8=1+2+4+1</li><li>18=1+2+4+8+3</li><li>31=1+2+4+8+16</li></ul><p>对于$k_i+1$不是2的整次幂，最后需要添加一个$k_i-2^{\lfloor log_2(k_i+1)\rfloor}+1$的物品</p><p>拆分后用01背包做即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">  <span class="keyword">int</span> c = <span class="number">1</span>, p, h, k;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; p &gt;&gt; h &gt;&gt; k;</span><br><span class="line">  <span class="keyword">while</span> (k - c &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    k -= c;</span><br><span class="line">    <span class="built_in">list</span>[++index].w = c * p;</span><br><span class="line">    <span class="built_in">list</span>[index].v = c * h;</span><br><span class="line">    c *= <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">list</span>[++index].w = p * k;</span><br><span class="line">  <span class="built_in">list</span>[index].v = h * k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-混合背包"><a href="#5-2-混合背包" class="headerlink" title="5.2 混合背包"></a>5.2 混合背包</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (循环物品种类) &#123;</span><br><span class="line">  <span class="keyword">if</span> (是 <span class="number">0</span> - <span class="number">1</span> 背包)</span><br><span class="line">    套用 <span class="number">0</span> - <span class="number">1</span> 背包代码;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (是完全背包)</span><br><span class="line">    套用完全背包代码;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (是多重背包)</span><br><span class="line">    套用多重背包代码;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>01背包是从大到小更新，完全背包从小到大更新，多重背包转化为01背包。</p><h3 id="5-3-二维费用背包"><a href="#5-3-二维费用背包" class="headerlink" title="5.3 二维费用背包"></a>5.3 二维费用背包</h3><p>多开一维进行转移即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &gt;= mi; i--)    <span class="comment">// 对经费进行一层枚举</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = t; j &gt;= ti; j--)  <span class="comment">// 对时间进行一层枚举</span></span><br><span class="line">      dp[i][j] = max(dp[i][j], dp[i - mi][j - ti] + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-4-分组背包"><a href="#5-4-分组背包" class="headerlink" title="5.4 分组背包"></a>5.4 分组背包</h3><p>所谓分组背包，就是将物品分组，每组的物品相互冲突，最多只能选一个物品放进去。</p><p>这种题怎么想呢？其实是从「在所有物品中选择一件」变成了「从当前组中选择一件」，于是就对每一组进行一次 0-1 背包就可以了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= ts; k++)          <span class="comment">// 循环每一组</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &gt;= <span class="number">0</span>; i--)         <span class="comment">// 循环背包容量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt[k]; j++)  <span class="comment">// 循环该组的每一个物品</span></span><br><span class="line">      <span class="keyword">if</span> (i &gt;= w[t[k][j]])</span><br><span class="line">        dp[i] = max(dp[i],dp[i - w[t[k][j]]] + c[t[k][j]]);  <span class="comment">// 像0-1背包一样状态转移</span></span><br></pre></td></tr></table></figure><p>即对于每一组只能取0/1件，因此从大到小枚举背包容量</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-数论&quot;&gt;&lt;a href=&quot;#1-数论&quot; class=&quot;headerlink&quot; title=&quot;1.数论&quot;&gt;&lt;/a&gt;1.数论&lt;/h2&gt;&lt;h3 id=&quot;1-1-与取模有关的函数&quot;&gt;&lt;a href=&quot;#1-1-与取模有关的函数&quot; class=&quot;headerlink&quot; title=&quot;1.1 与取模有关的函数&quot;&gt;&lt;/a&gt;1.1 与取模有关的函数&lt;/h3&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;namespace&lt;/span&gt; wjr &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; ull unsigned long long&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; uint unsigned int&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; bs bitset&lt;span class=&quot;meta-string&quot;&gt;&amp;lt;N&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; lb(x) x&amp;amp;-x&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; db;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; LL;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; mod = &lt;span class=&quot;number&quot;&gt;998244353&lt;/span&gt;, inv2 = &lt;span class=&quot;number&quot;&gt;499122177&lt;/span&gt;, inf = &lt;span class=&quot;number&quot;&gt;1e9&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;initial&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        inv2 = (mod + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) &amp;gt;&amp;gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;mul&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; b)&lt;/span&gt; &lt;/span&gt;&amp;#123; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; a * &lt;span class=&quot;number&quot;&gt;1ll&lt;/span&gt; * b % mod; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; b)&lt;/span&gt; &lt;/span&gt;&amp;#123; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; a += b, a &amp;gt;= mod ? a - mod : a; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;del&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; b)&lt;/span&gt; &lt;/span&gt;&amp;#123; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; a -= b, a &amp;lt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; ? a + mod : a; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;qpow&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; b)&lt;/span&gt; &lt;/span&gt;&amp;#123; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; s = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (; b; b &amp;gt;&amp;gt;= &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, a = mul(a, a))&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (b &amp;amp; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)s = mul(s, a); &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; s; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;typename&lt;/span&gt; T&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;inline&lt;/span&gt; T &lt;span class=&quot;title&quot;&gt;sqr&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;register&lt;/span&gt; T x)&lt;/span&gt; &lt;/span&gt;&amp;#123; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; x * x; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;span class=&quot;keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;namespace&lt;/span&gt; wjr;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="算法" scheme="https://wjr-z.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>FST模板</title>
    <link href="https://wjr-z.com/FST%E6%A8%A1%E6%9D%BF/"/>
    <id>https://wjr-z.com/FST%E6%A8%A1%E6%9D%BF/</id>
    <published>2021-03-30T12:47:21.000Z</published>
    <updated>2021-03-30T13:05:17.608Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>可用于求</p><script type="math/tex; mode=display">C[T]=\sum a[S]*b[T \oplus S]</script><p>逻辑运算符为异或</p><p>也可以写成</p><script type="math/tex; mode=display">C[k]=\sum_{i\&j=0\\i|j=k}a[i]*[j]</script><span id="more"></span><p>如果只有 $i | j=k$</p><p>那么就是求</p><script type="math/tex; mode=display">C[i|j]=\sum a[i]*b[j]</script><p>因为还有个$i\&amp;j=0$的限制</p><p>所以还需要$ctz[i]+ctz[j]=ctz[k]$，其中$ctz[i]$表示i中1的个数</p><p>这样的话将原数组$a[1&lt;&lt;N]$拆成 $A[N][1&lt; &lt; N]$即可</p><p>$A[ctz[i]][i]=a[i]$初始化</p><p>然后再跑FWT即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> wjr &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lb(x) x&amp;-x</span></span><br><span class="line">    <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">9</span>,inv2,inf=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">initial</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        inv2=(mod+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a * <span class="number">1ll</span> * b % mod; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a += b, a &gt;= mod ? a - mod : a; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a -= b, a &lt; <span class="number">0</span> ? a + mod : a; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">int</span> s = <span class="number">1</span>; <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>, a = mul(a, a))<span class="keyword">if</span> (b &amp; <span class="number">1</span>)s = mul(s, a); <span class="keyword">return</span> s; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> T <span class="title">sqr</span><span class="params">(<span class="keyword">register</span> T x)</span> </span>&#123; <span class="keyword">return</span> x * x; &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> wjr;</span><br><span class="line"><span class="keyword">namespace</span> FST &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1</span>&lt;&lt;<span class="number">20</span>;</span><br><span class="line">    <span class="keyword">int</span> ctz[N];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">initial</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ctz[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        ctz[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; ++i) &#123;</span><br><span class="line">            ctz[i]=ctz[i^(i&amp;-i)]+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">maintain</span><span class="params">(<span class="keyword">int</span>&amp; n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> q = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (q &lt; n)</span><br><span class="line">            q &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        n = q;</span><br><span class="line">    &#125;<span class="function"><span class="keyword">void</span> <span class="title">FWT_or</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> n, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> step, s, i, j;</span><br><span class="line">        <span class="keyword">for</span> (step = <span class="number">1</span>, s = <span class="number">2</span>; step &lt; n; step &lt;&lt;= <span class="number">1</span>, s &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i += s)</span><br><span class="line">                <span class="keyword">for</span> (j = i; j &lt; i + step; ++j)</span><br><span class="line">                    a[j + step] = ~p ? add(a[j + step], a[j]) : del(a[j + step], a[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FST</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> n,<span class="keyword">int</span>*b,<span class="keyword">int</span> m,<span class="keyword">int</span>*c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> A[<span class="number">21</span>][<span class="number">1</span>&lt;&lt;<span class="number">20</span>],B[<span class="number">21</span>][<span class="number">1</span>&lt;&lt;<span class="number">20</span>],C[<span class="number">21</span>][<span class="number">1</span>&lt;&lt;<span class="number">20</span>];</span><br><span class="line">        <span class="comment">//没考虑初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">            A[ctz[i]][i]=a[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i)</span><br><span class="line">            B[ctz[i]][i]=b[i];</span><br><span class="line">        <span class="keyword">int</span> len=max(n,m);</span><br><span class="line">        maintain(len);</span><br><span class="line">        <span class="keyword">int</span> lim=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((<span class="number">1</span>&lt;&lt;lim)&lt;len)</span><br><span class="line">            ++lim;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=lim;++i)</span><br><span class="line">            FWT_or(A[i],len,<span class="number">1</span>), FWT_or(B[i], len, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= lim; ++i) </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=i;++j)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; len; ++k) </span><br><span class="line">                    C[i][k]=add(C[i][k],mul(A[j][k],B[i-j][k]));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=lim;++i)</span><br><span class="line">            FWT_or(C[i],len,<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;lim);++i)</span><br><span class="line">            c[i]=C[ctz[i]][i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案即是$C[ctz[i]][i]$</p><p>我已经封装好了</p><p>传入数组a及大小，数组b及大小，以及接受答案的数组c即可</p><p>这是需要进行取模的代码，模数如有变动请修改参数 mod 以及 inv2 (inv2=(mod+1)&gt;&gt;1)</p><p>如果不需要取模的话请自行进行修改，inv2即除以2。</p><p>请自行初始化数组a和b！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;可用于求&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
C[T]=\sum a[S]*b[T \oplus S]&lt;/script&gt;&lt;p&gt;逻辑运算符为异或&lt;/p&gt;
&lt;p&gt;也可以写成&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
C[k]=\sum_{i\&amp;j=0\\i|j=k}a[i]*[j]&lt;/script&gt;</summary>
    
    
    
    
    <category term="FST" scheme="https://wjr-z.com/tags/FST/"/>
    
    <category term="快速子集变换" scheme="https://wjr-z.com/tags/%E5%BF%AB%E9%80%9F%E5%AD%90%E9%9B%86%E5%8F%98%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>FWT模板</title>
    <link href="https://wjr-z.com/FWT%E6%A8%A1%E6%9D%BF/"/>
    <id>https://wjr-z.com/FWT%E6%A8%A1%E6%9D%BF/</id>
    <published>2021-03-30T12:47:10.000Z</published>
    <updated>2021-03-30T12:57:43.275Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="FWT（快速沃尔什变换）"><a href="#FWT（快速沃尔什变换）" class="headerlink" title="FWT（快速沃尔什变换）"></a>FWT（快速沃尔什变换）</h2><p>可用于求解形如</p><script type="math/tex; mode=display">C[i\oplus j]=\sum_{i}\sum_{j}a[i]*b[j]</script><p>的式子</p><p>其中运算符可以取 异或（^)，或（|），与（&amp;）</p><p>证明在此省略，在此只给出封装过后的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> wjr &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>, inv2 = <span class="number">499122177</span>, inf = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a * <span class="number">1ll</span> * b % mod; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a += b, a &gt;= mod ? a - mod : a; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a -= b, a &lt; <span class="number">0</span> ? a + mod : a; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">int</span> s = <span class="number">1</span>; <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>, a = mul(a, a))<span class="keyword">if</span> (b &amp; <span class="number">1</span>)s = mul(s, a); <span class="keyword">return</span> s; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> T <span class="title">sqr</span><span class="params">(<span class="keyword">register</span> T x)</span> </span>&#123; <span class="keyword">return</span> x * x; &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> wjr;</span><br><span class="line"><span class="keyword">namespace</span> FWT &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1</span>&lt;&lt;<span class="number">20</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">maintain</span><span class="params">(<span class="keyword">int</span>&amp; n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> q=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(q&lt;n)</span><br><span class="line">            q&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">        n=q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FWT_and</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> n, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> step, s, i, j;</span><br><span class="line">        <span class="keyword">for</span> (step = <span class="number">1</span>, s = <span class="number">2</span>; step &lt; n; step &lt;&lt;= <span class="number">1</span>, s &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i += s)</span><br><span class="line">                <span class="keyword">for</span> (j = i; j &lt; i + step; ++j)</span><br><span class="line">                    a[j] = ~p ? add(a[j], a[j + step]) : del(a[j], a[j + step]);</span><br><span class="line">    &#125;<span class="function"><span class="keyword">void</span> <span class="title">FWT_or</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> n, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> step, s, i, j;</span><br><span class="line">        <span class="keyword">for</span> (step = <span class="number">1</span>, s = <span class="number">2</span>; step &lt; n; step &lt;&lt;= <span class="number">1</span>, s &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i += s)</span><br><span class="line">                <span class="keyword">for</span> (j = i; j &lt; i + step; ++j)</span><br><span class="line">                    a[j + step] = ~p ? add(a[j + step], a[j]) : del(a[j + step], a[j]);</span><br><span class="line">    &#125;<span class="function"><span class="keyword">void</span> <span class="title">FWT_xor</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> n, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> step, s, i, j, x;</span><br><span class="line">        <span class="keyword">for</span> (step = <span class="number">1</span>, s = <span class="number">2</span>; step &lt; n; step &lt;&lt;= <span class="number">1</span>, s &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i += s)</span><br><span class="line">                <span class="keyword">for</span> (j = i; j &lt; i + step; ++j) &#123;</span><br><span class="line">                    x = a[j];</span><br><span class="line">                    a[j] = add(a[j], a[j + step]);</span><br><span class="line">                    a[j + step] = del(x, a[j + step]);</span><br><span class="line">                    <span class="keyword">if</span> (~p)<span class="keyword">continue</span>;</span><br><span class="line">                    a[j] = mul(a[j], inv2);</span><br><span class="line">                    a[j + step] = mul(a[j + step], inv2);</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FWTAND</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> n,<span class="keyword">int</span>* b,<span class="keyword">int</span> m,<span class="keyword">int</span>*c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> A[N],B[N];</span><br><span class="line">        <span class="keyword">int</span> len=max(n,m);</span><br><span class="line">        maintain(len);</span><br><span class="line">        <span class="built_in">memcpy</span>(A,a,<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*len);</span><br><span class="line">        <span class="built_in">memcpy</span>(B,b,<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*len);</span><br><span class="line">        FWT_and(A,len,<span class="number">1</span>);</span><br><span class="line">        FWT_and(B,len,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i)</span><br><span class="line">            A[i]=mul(A[i],B[i]);</span><br><span class="line">        FWT_and(A,len,<span class="number">-1</span>);</span><br><span class="line">        len=max(n,m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i)</span><br><span class="line">            c[i]=A[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FWTOR</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> n, <span class="keyword">int</span>* b, <span class="keyword">int</span> m, <span class="keyword">int</span>* c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> A[N], B[N];</span><br><span class="line">        <span class="keyword">int</span> len = max(n, m);</span><br><span class="line">        maintain(len);</span><br><span class="line">        <span class="built_in">memcpy</span>(A, a, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * len);</span><br><span class="line">        <span class="built_in">memcpy</span>(B, b, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * len);</span><br><span class="line">        FWT_or(A, len, <span class="number">1</span>);</span><br><span class="line">        FWT_or(B, len, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">            A[i] = mul(A[i], B[i]);</span><br><span class="line">        FWT_or(A, len, <span class="number">-1</span>);</span><br><span class="line">        len = max(n, m);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">            c[i] = A[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FWTXOR</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> n, <span class="keyword">int</span>* b, <span class="keyword">int</span> m, <span class="keyword">int</span>* c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> A[N], B[N];</span><br><span class="line">        <span class="keyword">int</span> len = max(n, m);</span><br><span class="line">        maintain(len);</span><br><span class="line">        <span class="built_in">memcpy</span>(A, a, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * len);</span><br><span class="line">        <span class="built_in">memcpy</span>(B, b, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * len);</span><br><span class="line">        FWT_xor(A, len, <span class="number">1</span>);</span><br><span class="line">        FWT_xor(B, len, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">            A[i] = mul(A[i], B[i]);</span><br><span class="line">        FWT_xor(A, len, <span class="number">-1</span>);</span><br><span class="line">        len = max(n, m);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">            c[i] = A[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是需要进行取模的代码，模数如有变动请修改参数 mod 以及 inv2 (inv2=(mod+1)&gt;&gt;1)</p><p>如果不需要取模的话请自行进行修改，inv2即除以2。</p><p>使用方法：</p><p>传入 a 数组及大小，b数组及大小，接受答案的数组 c</p><p>注意，需要初始化 a，b 数组</p><p>对于$len=2^k,len\geq n且2^{k-1}&lt;n$，将a数组从第 n 位到 len-1 位置为0</p><p>对于b同理</p><p>这是因为快速变换等都只能跑2的整次幂，因此需要初始化（其实是我懒，没有封装初始化）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="FWT" scheme="https://wjr-z.com/tags/FWT/"/>
    
    <category term="快速沃尔什变换" scheme="https://wjr-z.com/tags/%E5%BF%AB%E9%80%9F%E6%B2%83%E5%B0%94%E4%BB%80%E5%8F%98%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>Qt 内存文件映射</title>
    <link href="https://wjr-z.com/Qt-%E5%86%85%E5%AD%98%E6%96%87%E4%BB%B6%E6%98%A0%E5%B0%84/"/>
    <id>https://wjr-z.com/Qt-%E5%86%85%E5%AD%98%E6%96%87%E4%BB%B6%E6%98%A0%E5%B0%84/</id>
    <published>2021-03-28T13:39:33.000Z</published>
    <updated>2021-03-30T13:18:24.981Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>其实很简单</p><p>Qt都封装好了</p><p>映射一个文件：</p><span id="more"></span><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">QFile file;</span><br><span class="line">file.setFileName(path);<span class="comment">//设置文件路径</span></span><br><span class="line">file.open(QIODevice::ReadOnly);<span class="comment">//只读，读写为ReadWrite</span></span><br><span class="line"><span class="keyword">int</span> len=file.size();</span><br><span class="line">uchar*ptr=file.<span class="built_in">map</span>(<span class="number">0</span>,len);<span class="comment">//ptr即为文件字符串</span></span><br><span class="line"><span class="keyword">if</span>(!ptr)&#123;</span><br><span class="line">    len=<span class="number">0</span>;</span><br><span class="line">    file.close();</span><br><span class="line">    ptr=<span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">uchar*tail=ptr+len;<span class="comment">//尾指针</span></span><br></pre></td></tr></table></figure><p>读取文件（和从字符串中读取没任何区别）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QString <span class="title">QuickFile::QStringLine</span><span class="params">()</span></span>&#123;<span class="comment">//读取一行</span></span><br><span class="line">    QString s=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span>(ptr&lt;tail&amp;&amp;*ptr!=<span class="string">&#x27;\r&#x27;</span>&amp;&amp;*ptr!=<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        s.push_back(*ptr++);</span><br><span class="line">    <span class="keyword">if</span>(*ptr==<span class="string">&#x27;\r&#x27;</span>)++ptr;</span><br><span class="line">    <span class="keyword">if</span>(*ptr==<span class="string">&#x27;\n&#x27;</span>)++ptr;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其余读取操作请自行完善</p><p>下面附上我封装好的读取文件类</p><h4 id="quickfile-h"><a href="#quickfile-h" class="headerlink" title="quickfile.h"></a>quickfile.h</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MYFILE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYFILE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QFile&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QuickFile</span>&#123;</span><span class="comment">//读入的文件</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    QFile file;</span><br><span class="line">    uchar*ptr,*tail;</span><br><span class="line">    QuickFile();</span><br><span class="line">    ~QuickFile();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">QuickFileRead</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;path,<span class="keyword">const</span> <span class="keyword">int</span> &amp;MinSize=<span class="number">0</span>,<span class="keyword">const</span> <span class="keyword">int</span>&amp;MaxSize=<span class="number">-1</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">QString <span class="title">QStringAll</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">QString <span class="title">QStringLine</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">IntAll</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">IntLine</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// MYFILE_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="quickfile-cpp"><a href="#quickfile-cpp" class="headerlink" title="quickfile.cpp"></a>quickfile.cpp</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;quickfile.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;function.h&quot;</span></span></span><br><span class="line">QuickFile::QuickFile()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">QuickFile::~QuickFile()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickFile::QuickFileRead</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;path,<span class="keyword">const</span> <span class="keyword">int</span> &amp;MinSize,<span class="keyword">const</span> <span class="keyword">int</span>&amp;MaxSize)</span></span>&#123;</span><br><span class="line">    file.setFileName(QString::fromLocal8Bit(path.data()));</span><br><span class="line">    file.open(QIODevice::ReadOnly);</span><br><span class="line">    len=file.size();</span><br><span class="line">    <span class="keyword">if</span>(~MaxSize&amp;&amp;(len&lt;MinSize||len&gt;MaxSize))&#123;</span><br><span class="line">        len=<span class="number">0</span>;</span><br><span class="line">        file.close();</span><br><span class="line">        ptr=<span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ptr=file.<span class="built_in">map</span>(<span class="number">0</span>,len);</span><br><span class="line">    <span class="keyword">if</span>(!ptr)&#123;</span><br><span class="line">        len=<span class="number">0</span>;</span><br><span class="line">        file.close();</span><br><span class="line">        ptr=<span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    tail=ptr+len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickFile::close</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(len)file.unmap(ptr);</span><br><span class="line">    file.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">QString <span class="title">QuickFile::QStringAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">    QString s=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span>(ptr&lt;tail)</span><br><span class="line">        s.push_back(*ptr++);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">QString <span class="title">QuickFile::QStringLine</span><span class="params">()</span></span>&#123;</span><br><span class="line">    QString s=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span>(ptr&lt;tail&amp;&amp;*ptr!=<span class="string">&#x27;\r&#x27;</span>&amp;&amp;*ptr!=<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        s.push_back(*ptr++);</span><br><span class="line">    <span class="keyword">if</span>(*ptr==<span class="string">&#x27;\r&#x27;</span>)++ptr;</span><br><span class="line">    <span class="keyword">if</span>(*ptr==<span class="string">&#x27;\n&#x27;</span>)++ptr;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QuickFile::IntAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(ptr&lt;tail)</span><br><span class="line">        s=(s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+(*(ptr++)-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QuickFile::IntLine</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(ptr&lt;tail&amp;&amp;*ptr!=<span class="string">&#x27;\r&#x27;</span>&amp;&amp;*ptr!=<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        s=(s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+(*(ptr++)-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(*ptr==<span class="string">&#x27;\r&#x27;</span>)++ptr;</span><br><span class="line">    <span class="keyword">if</span>(*ptr==<span class="string">&#x27;\n&#x27;</span>)++ptr;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="使用方法："><a href="#使用方法：" class="headerlink" title="使用方法："></a>使用方法：</h3><p>QuickFileRead:</p><p>读取路径为path，文件大小在[MinSize,MaxSize]（不在的话len=0,ptr=nullptr，即文件置为空）之间的文件，MaxSize=-1即无限制。</p><p>ptr指针即为文件内容指针,uchar类型。</p><p>读取完后需要用close()进行关闭</p><p>close:</p><p>关闭读取的文件以及映射</p><p>QStringAll:</p><p>返回文件剩余内容，类型为QString</p><p>ptr移至尾指针tail</p><p>QStringLine:</p><p>返回一行，类型为QString</p><p>ptr移至下一行</p><p>IntAll:</p><p>返回文件剩余内容，类型为int</p><p>ptr移至尾指针tail</p><p>IntLine:</p><p>返回一行，类型为int</p><p>ptr移至下一行</p><p>为啥要用文件内容映射？</p><p>使用这个可以减少I/O操作，并且对于性能提升有好处</p><p>同时降低了程序内存使用（节省了接收文件内容所需要的字符数组）</p><p>对于快速写入，我暂时用不上，因此没写</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;其实很简单&lt;/p&gt;
&lt;p&gt;Qt都封装好了&lt;/p&gt;
&lt;p&gt;映射一个文件：&lt;/p&gt;</summary>
    
    
    
    
    <category term="Qt" scheme="https://wjr-z.com/tags/Qt/"/>
    
    <category term="内存文件映射" scheme="https://wjr-z.com/tags/%E5%86%85%E5%AD%98%E6%96%87%E4%BB%B6%E6%98%A0%E5%B0%84/"/>
    
  </entry>
  
  <entry>
    <title>2019-2020 ICPC Asia Hong Kong Regional Contest J.Junior Mathematician</title>
    <link href="https://wjr-z.com/Junior-Mathematician/"/>
    <id>https://wjr-z.com/Junior-Mathematician/</id>
    <published>2021-03-10T15:11:29.000Z</published>
    <updated>2021-03-10T15:24:03.161Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="数位DP题"><a href="#数位DP题" class="headerlink" title="数位DP题"></a>数位DP题</h3><span id="more"></span><p>此题可以选择从高位到低位转移或者低位到高位转移，我两种都试了一下，其实差不多。</p><p>最简单的方法是记$dp[i][j][k][l]$表示转移到第$i$位（从高到低或者从低到高）$x\%m==j$并且$f(x)\%m==k$并且各位数字和$\%m==l$的方案数<br/></p><p>不过这样空间和时间复杂度都太高了</p><p>不难发现可以将第二维和第三维合并，即$dp[i][j][k]$表示转移到第$i$位且$(x-f(x))\%m==0$且各位数字和$\%m==l$的方案数<br/></p><p>转移方程并不是难点。</p><p>对于数位DP，想降低错误率，尽量减少调试时间或者不调试，建议用<strong>记忆化搜索</strong>，递推虽然会快一些但是记忆化更容易写。</p><h4 id="记忆化搜索版本："><a href="#记忆化搜索版本：" class="headerlink" title="记忆化搜索版本："></a>记忆化搜索版本：</h4><p>基本写完调了一下就过了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">5050</span>,M=<span class="number">61</span>,mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> dp[N][M][M],q[N],a[N],len1,len2,m;</span><br><span class="line"><span class="keyword">char</span> s[N],g[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    q[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=len2;++i)</span><br><span class="line">        q[i]=(q[i<span class="number">-1</span>]*<span class="number">10</span>)%m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> s, <span class="keyword">int</span> p, <span class="keyword">int</span> lim)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!now)<span class="keyword">return</span> s==<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(!lim&amp;&amp;~dp[now][s][p])<span class="keyword">return</span> dp[now][s][p];</span><br><span class="line">    <span class="keyword">int</span> Max=lim?a[now]:<span class="number">9</span>;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= Max; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u=((s+q[now]*i-i*p)%m+m)%m,v=(p+i)%m;</span><br><span class="line">        ans=((ans+dfs(now<span class="number">-1</span>,u,v,lim&amp;i==Max))%mod+mod)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!lim)dp[now][s][p]=ans;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getans</span><span class="params">(<span class="keyword">char</span>* s,<span class="keyword">int</span> len,<span class="keyword">bool</span> gg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len;++i)</span><br><span class="line">        a[i]=s[len-i+<span class="number">1</span>]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (gg) &#123;</span><br><span class="line">        --a[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                a[i] += <span class="number">10</span>;</span><br><span class="line">                --a[i + <span class="number">1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!a[len])--len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dfs(len,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">&#125;<span class="keyword">int</span> T;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%s%d&quot;</span>,s+<span class="number">1</span>,g+<span class="number">1</span>,&amp;m);</span><br><span class="line">        len1=<span class="built_in">strlen</span>(s+<span class="number">1</span>),len2=<span class="built_in">strlen</span>(g+<span class="number">1</span>);</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len2;++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;++j)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;m;++k)</span><br><span class="line">                    dp[i][j][k]=<span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,(getans(g,len2,<span class="number">0</span>)-getans(s,len1,<span class="number">1</span>)+mod)%mod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="递推版本："><a href="#递推版本：" class="headerlink" title="递推版本："></a>递推版本：</h4><p>写完还调试了半天才过qwq</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">5010</span>,M=<span class="number">62</span>,mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> f[N][M][M],g[N][M][M];</span><br><span class="line"><span class="keyword">int</span> a[N],q[N],len;</span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="keyword">char</span> s[N],h[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    q[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">5000</span>;++i)</span><br><span class="line">        q[i]=(q[i<span class="number">-1</span>]*<span class="number">10</span>)%m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getans</span><span class="params">(<span class="keyword">char</span>*s,<span class="keyword">bool</span> gg)</span> </span>&#123;</span><br><span class="line">    len=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len;++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;++j)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;m;++k)</span><br><span class="line">                f[i][j][k]=g[i][j][k]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len;++i)</span><br><span class="line">        a[i]=s[len-i+<span class="number">1</span>]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (gg) &#123;</span><br><span class="line">        --a[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                a[i]+=<span class="number">10</span>;</span><br><span class="line">                --a[i+<span class="number">1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!a[len])--len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        ++f[<span class="number">1</span>][i%m][i%m];</span><br><span class="line">        <span class="keyword">if</span>(i&lt;=a[<span class="number">1</span>])++g[<span class="number">1</span>][i%m][i%m];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= len; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;++j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; m; ++k) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; <span class="number">10</span>; ++p) &#123;</span><br><span class="line">                    <span class="keyword">int</span> u=((j + q[i] * p - k * p)%m+m)%m,v=(k+p)%m;</span><br><span class="line">                    f[i][u][v]=(f[i][u][v]+f[i<span class="number">-1</span>][j][k])%mod;</span><br><span class="line">                    <span class="keyword">if</span>(p&lt;a[i])</span><br><span class="line">                        g[i][u][v]=(g[i][u][v]+f[i<span class="number">-1</span>][j][k])%mod;</span><br><span class="line">                    <span class="keyword">if</span>(p==a[i])</span><br><span class="line">                        g[i][u][v]=(g[i][u][v]+g[i<span class="number">-1</span>][j][k])%mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i)</span><br><span class="line">        ans=(ans+g[len][<span class="number">0</span>][i])%mod;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%s%d&quot;</span>,s+<span class="number">1</span>,h+<span class="number">1</span>,&amp;m);</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">int</span> u=getans(s,<span class="number">1</span>),v=getans(h,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,((v-u)%mod+mod)%mod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;数位DP题&quot;&gt;&lt;a href=&quot;#数位DP题&quot; class=&quot;headerlink&quot; title=&quot;数位DP题&quot;&gt;&lt;/a&gt;数位DP题&lt;/h3&gt;</summary>
    
    
    
    
    <category term="ICPC" scheme="https://wjr-z.com/tags/ICPC/"/>
    
    <category term="数位DP" scheme="https://wjr-z.com/tags/%E6%95%B0%E4%BD%8DDP/"/>
    
  </entry>
  
  <entry>
    <title>QtCreator开启-O编译优化的方式</title>
    <link href="https://wjr-z.com/QtCreator%E5%BC%80%E5%90%AF-O%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E7%9A%84%E6%96%B9%E5%BC%8F/"/>
    <id>https://wjr-z.com/QtCreator%E5%BC%80%E5%90%AF-O%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E7%9A%84%E6%96%B9%E5%BC%8F/</id>
    <published>2021-03-06T11:24:06.000Z</published>
    <updated>2021-03-30T12:50:13.056Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>首先，编译优化必须是在Release模式下进行，保证程序没有任何bug的条件下进行执行。</p><p>如果程序开了编译优化，部分错误不会报错且debug会出问题，因此需要在没有bug后再进行优化</p><p>编译优化能极大提升程序的运行效率，级别越高速度越快，但是对代码健壮性要求也越高！</p><span id="more"></span><p>选择编译release模式，在pro文件根据优化的需要添加下面的语句：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QMAKE_CXXFLAGS_RELEASE += -O        # Release -O</span><br><span class="line">QMAKE_CXXFLAGS_RELEASE += -O1       # Release -O1</span><br><span class="line">QMAKE_CXXFLAGS_RELEASE += -O2       # Release -O2</span><br><span class="line">QMAKE_CXXFLAGS_RELEASE += -O3       # Release -O3</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;首先，编译优化必须是在Release模式下进行，保证程序没有任何bug的条件下进行执行。&lt;/p&gt;
&lt;p&gt;如果程序开了编译优化，部分错误不会报错且debug会出问题，因此需要在没有bug后再进行优化&lt;/p&gt;
&lt;p&gt;编译优化能极大提升程序的运行效率，级别越高速度越快，但是对代码健壮性要求也越高！&lt;/p&gt;</summary>
    
    
    
    
    <category term="Qt" scheme="https://wjr-z.com/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>LOJ6515 「雅礼集训 2018 Day10」贪玩蓝月</title>
    <link href="https://wjr-z.com/LOJ6515%E8%B4%AA%E7%8E%A9%E8%93%9D%E6%9C%88/"/>
    <id>https://wjr-z.com/LOJ6515%E8%B4%AA%E7%8E%A9%E8%93%9D%E6%9C%88/</id>
    <published>2021-03-03T09:18:36.000Z</published>
    <updated>2021-03-03T09:56:17.848Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><span class="exturl" data-url="aHR0cHM6Ly9vaS13aWtpLm9yZy9kcy9xdWV1ZS8jXzM=">前置知识&amp;wiki题解<i class="fa fa-external-link-alt"></i></span></p><span id="more"></span><p>此题如果是栈的形式，则非常好维护DP<br>因为删除栈顶DP不变，栈顶增加元素只用$O(p)$修改DP<br/><br>因此就用到到了<strong>双栈模拟队列</strong></p><h2 id="双栈模拟队列"><a href="#双栈模拟队列" class="headerlink" title="双栈模拟队列"></a>双栈模拟队列</h2><p>设 F , S 分别是队尾和队首的栈，支持 push（在队尾插入），pop（在队首弹出）操作：</p><ul><li>push：插入到栈 F 中。</li><li>pop：如果 S 非空，让 S 弹栈；否则把 F 的元素倒过来压到 S 中（其实就是一个一个弹出插入，做完后是首位颠倒的），然后再让 S 弹栈。</li></ul><p>容易证明，每个元素只会进入/转移/弹出一次，均摊复杂度$O(1)$ 。</p><h2 id="双栈模拟双端队列"><a href="#双栈模拟双端队列" class="headerlink" title="双栈模拟双端队列"></a>双栈模拟双端队列</h2><p>与双栈模拟队列相似，仅pop改变</p><ul><li>pop时，若栈为空，将另一个栈（设元素大小为siz)的前$\frac{siz+1}{2}$倒着压入该栈并弹出一个<br>这样到下一次pop时为空最少需要$\frac{siz}{2}$次pop<br/><br>这样的话均摊复杂度是$O(1)$的</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>设 $f[i,j]$ 表示前 i 个二元组，余数为 j 的最大价值</p><script type="math/tex; mode=display">f[i][j]=max(f[i-1][j],f[i-1][(j-w_i+p)\%p]+v_j)</script><p>用双栈模拟队列即可很容易的分别维护队首和队尾的 f<br>询问可用单调队列优化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> w,v;</span><br><span class="line">    node(<span class="keyword">int</span> a = <span class="number">0</span>, <span class="keyword">int</span> b = <span class="number">0</span>) &#123;</span><br><span class="line">        w=a,v=b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">5e4</span>+<span class="number">10</span>,M=<span class="number">505</span>;</span><br><span class="line"><span class="keyword">int</span> m,p;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">int</span> _(<span class="keyword">int</span> x) &#123; <span class="keyword">return</span> (x + p) % p; &#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stk</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> dp[N][M], top;</span><br><span class="line">    node st[N];</span><br><span class="line">    stk() &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">500</span>;++i)</span><br><span class="line">            dp[<span class="number">0</span>][i]=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p; ++i) &#123;</span><br><span class="line">            dp[top][i]=dp[top<span class="number">-1</span>][i];</span><br><span class="line">            <span class="keyword">int</span> k=_(i-st[top].w);</span><br><span class="line">            <span class="keyword">if</span>(~dp[top<span class="number">-1</span>][k])</span><br><span class="line">                dp[top][i]=max(dp[top][i],dp[top<span class="number">-1</span>][k]+st[top].v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;a[<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> o,node x)</span> </span>&#123;</span><br><span class="line">    a[o].st[++a[o].top]=x;</span><br><span class="line">    a[o].update();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">(<span class="keyword">int</span> o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a[o].top) &#123;</span><br><span class="line">        --a[o].top;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="keyword">int</span> k=!o;</span><br><span class="line">    <span class="keyword">int</span> mid=(a[k].top+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>,top=a[k].top;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=mid;i&gt;=<span class="number">1</span>;--i)push(o,a[k].st[i]);</span><br><span class="line">    a[k].top=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=mid+<span class="number">1</span>;i&lt;=top;++i)push(k,a[k].st[i]);</span><br><span class="line">    --a[o].top;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> q[N],ql,qr;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    ql=<span class="number">1</span>,qr=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> k1=a[<span class="number">0</span>].top,k2=a[<span class="number">1</span>].top;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l - p + <span class="number">1</span>; i &lt;= r - p + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x=a[<span class="number">1</span>].dp[k2][_(i)];</span><br><span class="line">        <span class="keyword">while</span>(ql&lt;=qr&amp;&amp;a[<span class="number">1</span>].dp[k2][q[qr]]&lt;=x)--qr;</span><br><span class="line">        q[++qr]=_(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = p - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(ql&lt;=qr&amp;&amp;~a[<span class="number">0</span>].dp[k1][i]&amp;&amp;~a[<span class="number">1</span>].dp[k2][q[ql]])</span><br><span class="line">            ans=max(ans,a[<span class="number">0</span>].dp[k1][i]+a[<span class="number">1</span>].dp[k2][q[ql]]);</span><br><span class="line">        <span class="keyword">if</span>(ql&lt;=qr&amp;&amp;_(l-i)==q[ql])++ql;</span><br><span class="line">        <span class="keyword">int</span> x=a[<span class="number">1</span>].dp[k2][_(r-i+<span class="number">1</span>)];</span><br><span class="line">        <span class="keyword">while</span>(ql&lt;=qr&amp;&amp;a[<span class="number">1</span>].dp[k2][q[qr]]&lt;=x)--qr;</span><br><span class="line">        q[++qr]=_(r-i+<span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> kase;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;kase);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;m,&amp;p);</span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> v,w;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d&quot;</span>,s,&amp;w,&amp;v);</span><br><span class="line">        <span class="keyword">int</span> o=s[<span class="number">1</span>]==<span class="string">&#x27;F&#x27;</span>?<span class="number">0</span>:<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">&#x27;I&#x27;</span>)push(o,node(_(w),v));</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">&#x27;D&#x27;</span>)pop(o);</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,query(w,v));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://oi-wiki.org/ds/queue/#_3&quot;&gt;前置知识&amp;amp;wiki题解&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="数据结构" scheme="https://wjr-z.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="双端队列" scheme="https://wjr-z.com/tags/%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97/"/>
    
    <category term="单调队列" scheme="https://wjr-z.com/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
    
    <category term="双栈模拟队列" scheme="https://wjr-z.com/tags/%E5%8F%8C%E6%A0%88%E6%A8%A1%E6%8B%9F%E9%98%9F%E5%88%97/"/>
    
    <category term="DP" scheme="https://wjr-z.com/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>快速查找文件代码</title>
    <link href="https://wjr-z.com/%E5%BF%AB%E9%80%9F%E6%9F%A5%E6%89%BE%E6%96%87%E4%BB%B6%E4%BB%A3%E7%A0%81/"/>
    <id>https://wjr-z.com/%E5%BF%AB%E9%80%9F%E6%9F%A5%E6%89%BE%E6%96%87%E4%BB%B6%E4%BB%A3%E7%A0%81/</id>
    <published>2021-02-24T04:56:42.000Z</published>
    <updated>2021-03-30T12:50:28.407Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="Update-at-2021-3-28"><a href="#Update-at-2021-3-28" class="headerlink" title="Update at 2021.3.28"></a>Update at 2021.3.28</h3><h4 id="使用了Qt进行了可视化"><a href="#使用了Qt进行了可视化" class="headerlink" title="使用了Qt进行了可视化"></a>使用了Qt进行了可视化</h4><p>现在界面是这样的</p><span id="more"></span><p><img data-src="https://tu.sunpma.com/imgs/2021/03/ce21e6de21837bd3.png" alt=""></p><p>对于搜索速度以及磁盘利用率进行了进一步优化</p><p>并且新增一些小功能</p><ul><li><p>每一页显示100个结果，并且可以通过点击“文件内容”，“路径”，“大小”进行递增、递减排序-</p></li><li><p>支持大小写敏感</p></li></ul><p>暂不支持正则表达式，并且没有建立索引。</p><p>对于查找文件内容的速度我还是较为自信的。</p><p>搜索1G以内文件的某个文件内容，10s内基本是稳的吧。</p><p>不过因为多线程可能导致任务分配不均，所以可能导致效率在最坏情况变为最优的两倍。</p><p>尝试过解决，解决方案严格的均分任务，但是效果不佳，于是暂时放弃该方案。</p><p>可以来提提建议！</p><p>需要源码或者可运行程序的评论留言。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;Update-at-2021-3-28&quot;&gt;&lt;a href=&quot;#Update-at-2021-3-28&quot; class=&quot;headerlink&quot; title=&quot;Update at 2021.3.28&quot;&gt;&lt;/a&gt;Update at 2021.3.28&lt;/h3&gt;&lt;h4 id=&quot;使用了Qt进行了可视化&quot;&gt;&lt;a href=&quot;#使用了Qt进行了可视化&quot; class=&quot;headerlink&quot; title=&quot;使用了Qt进行了可视化&quot;&gt;&lt;/a&gt;使用了Qt进行了可视化&lt;/h4&gt;&lt;p&gt;现在界面是这样的&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux安装php-fpm</title>
    <link href="https://wjr-z.com/Linux%E5%AE%89%E8%A3%85php-fpm/"/>
    <id>https://wjr-z.com/Linux%E5%AE%89%E8%A3%85php-fpm/</id>
    <published>2021-02-22T01:41:41.000Z</published>
    <updated>2021-02-24T06:39:24.777Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>主要参考文章：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc1MjI5NC9hcnRpY2xlL2RldGFpbHMvOTAxODE4MDU=">Linux安装PHP-FPM<i class="fa fa-external-link-alt"></i></span></p><p>跟着做的时候踩坑了，在此记录下踩的坑，并排坑。</p><p>注：参考文章于2019年5月发布！</p><span id="more"></span><h2 id="安装编译环境"><a href="#安装编译环境" class="headerlink" title="安装编译环境"></a>安装编译环境</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum -y install epel-release</span><br><span class="line">yum -y install gcc automake autoconf libtool make gcc-c++ glibc libmcrypt-devel mhash-devel libxslt-devel libjpeg libjpeg-devel libpng libpng-devel freetype freetype-devel libxml2 libxml2-devel zlib zlib-devel glibc glibc-devel glib2 glib2-devel bzip2 bzip2-devel ncurses ncurses-devel curl curl-devel e2fsprogs e2fsprogs-devel krb5 krb5-devel libidn libidn-devel openssl openssl-devel libmcrypt mcrypt mhash  php-mcrypt</span><br></pre></td></tr></table></figure><h2 id="下载php版本包"><a href="#下载php版本包" class="headerlink" title="下载php版本包"></a>下载php版本包</h2><p>php官方地址：<span class="exturl" data-url="aHR0cHM6Ly93d3cucGhwLm5ldC9yZWxlYXNlcy8=">https://www.php.net/releases/<i class="fa fa-external-link-alt"></i></span><br>本次安装环境的版本包为php5.6，可以选择更高版本下载<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget http:&#x2F;&#x2F;cn2.php.net&#x2F;distributions&#x2F;php-5.6.24.tar.gz</span><br><span class="line">tar zvxf php-5.6.24.tar.gz</span><br><span class="line">cd php-5.6.24</span><br></pre></td></tr></table></figure></p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>php编译过程中，如果要php支持相应的功能，需要先安装对应的组件，然后再编译。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;php  --enable-fpm --with-mcrypt --enable-mbstring --disable-pdo --with-curl --disable-debug  --disable-rpath --enable-inline-optimization --with-bz2  --with-zlib --enable-sockets --enable-sysvsem --enable-sysvshm --enable-pcntl --enable-mbregex --with-mhash --enable-zip --with-pcre-regex --with-mysql --with-mysqli </span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><br>此处可能会出现一些错误<br>例如：</p><h3 id="错误一"><a href="#错误一" class="headerlink" title="错误一"></a>错误一</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PHP configure: error: mcrypt.h not found. Please reinstall libmcrypt.</span><br></pre></td></tr></table></figure><h3 id="错误二"><a href="#错误二" class="headerlink" title="错误二"></a>错误二</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Don&#39;t know how to define struct flock on this system, set --enable-opcache&#x3D;no</span><br></pre></td></tr></table></figure><p>对于第一个，解决方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget ftp:&#x2F;&#x2F;mcrypt.hellug.gr&#x2F;pub&#x2F;crypto&#x2F;mcrypt&#x2F;attic&#x2F;libmcrypt&#x2F;libmcrypt-2.5.7.tar.gz</span><br><span class="line">tar -zxvf libmcrypt-2.5.7.tar.gz</span><br><span class="line">cd libmcrypt-2.5.7</span><br><span class="line">.&#x2F;configure  --prefix&#x3D;&#x2F;usr&#x2F;local</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><br>(可以选择更高版本的进行下载，但是我为了方便(lan)就没有改)</p><p>对于第二个，解决方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;ld.so.conf.d&#x2F;local.conf     # 编辑库文件</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;lib                       # 添加该行</span><br><span class="line">:wq                                  # 保存退出</span><br><span class="line">ldconfig -v                          # 使之生效</span><br></pre></td></tr></table></figure></p><p>有的人可能会出现 make 时出错，这个应该是因为你编译时出错导致的，因此上述问题解决后重新 make &amp;&amp; make install 即可</p><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>复制配置文件，对其中一些代码进行修改，可根据需要开启php中的功能<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cp php.ini-development &#x2F;usr&#x2F;local&#x2F;php&#x2F;php.ini</span><br><span class="line">cp &#x2F;usr&#x2F;local&#x2F;php&#x2F;etc&#x2F;php-fpm.conf.default &#x2F;usr&#x2F;local&#x2F;php&#x2F;etc&#x2F;php-fpm.conf</span><br><span class="line">cp sapi&#x2F;fpm&#x2F;php-fpm &#x2F;usr&#x2F;local&#x2F;bin</span><br></pre></td></tr></table></figure><br>修改php-fpm.conf配置文件，使用www用户和www用户组运行（我为了方便用了我之前创建的其他用户组，注意此处不能用root）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;usr&#x2F;local&#x2F;php&#x2F;etc&#x2F;php-fpm.conf</span><br><span class="line">#修改为以下</span><br><span class="line">; Unix user&#x2F;group of processes</span><br><span class="line">; Note: The user is mandatory. If the group is not set, the default user&#39;s group</span><br><span class="line">;       will be used.</span><br><span class="line">user &#x3D; www</span><br><span class="line">group &#x3D; www</span><br></pre></td></tr></table></figure></p><p>修改php.ini，根据需求开启需要的php功能<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;usr&#x2F;local&#x2F;php&#x2F;php.ini</span><br><span class="line">#############################</span><br><span class="line">display_errors &#x3D; On</span><br><span class="line">display_startup_errors &#x3D; On</span><br><span class="line">error_prepend_string &#x3D; &quot;&lt;br&gt;&lt;font color&#x3D;#ff0000&gt;&quot;</span><br><span class="line">error_append_string &#x3D; &quot;&lt;&#x2F;font&gt;&lt;br&gt;&lt;br&gt;&quot;</span><br><span class="line">fastcgi.impersonate &#x3D; 1</span><br><span class="line">date.timezone &#x3D; asia&#x2F;Shanghai</span><br><span class="line">extension&#x3D;php_mysql.dll</span><br><span class="line">extension&#x3D;php_gd2.dll</span><br><span class="line">extension&#x3D;php_mbstring.dll</span><br></pre></td></tr></table></figure></p><h2 id="官方提醒"><a href="#官方提醒" class="headerlink" title="官方提醒"></a>官方提醒</h2><p>需要着重提醒的是，如果文件不存在，则阻止 Nginx 将请求发送到后端的 PHP-FPM 模块， 以避免遭受恶意脚本注入的攻击。<br>将 php.ini 文件中的配置项 cgi.fix_pathinfo 设置为 0 。<br>打开 php.ini，定位到 cgi.fix_pathinfo= 并将其修改为如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;usr&#x2F;local&#x2F;php&#x2F;php.ini</span><br><span class="line">##########################</span><br><span class="line">cgi.fix_pathinfo&#x3D;0</span><br></pre></td></tr></table></figure></p><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;local&#x2F;bin&#x2F;php-fpm</span><br><span class="line">#查看是否运行</span><br><span class="line">netstat -anop | grep php</span><br></pre></td></tr></table></figure><p>出现以下界面表示正常运行：<br><img data-src="https://img-blog.csdnimg.cn/20190513161843862.png" alt=""></p><h2 id="Nginx添加PHP支持"><a href="#Nginx添加PHP支持" class="headerlink" title="Nginx添加PHP支持"></a>Nginx添加PHP支持</h2><p>Nginx的配置文件中已经给出了模板，将root修改为网站目录即可，参考如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">location ~ .php$ &#123;</span><br><span class="line">root html；  #网站程序目录，根据需求修改</span><br><span class="line">fastcgi_pass 127.0.0.1:9000；</span><br><span class="line">fastcgi_index index.php；</span><br><span class="line">fastcgi_param SCRIPT_FILENAME &#x2F;html$fastcgi_script_name；  #&#x2F;html 为网站程序目录</span><br><span class="line">include fastcgi_params；</span><br><span class="line">fastcgi_param   SCRIPT_NAME        $fastcgi_script_name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Apache添加PHP支持"><a href="#Apache添加PHP支持" class="headerlink" title="Apache添加PHP支持"></a>Apache添加PHP支持</h2><p>若是要使用apache，编译时候需加上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--with-apxs2&#x3D;&#x2F;usr&#x2F;local&#x2F;apache&#x2F;bin&#x2F;apxs</span><br><span class="line">#apxs路径自行确认，如果是yum安装，没有找到apxs需要安装下httpd-devel组件</span><br></pre></td></tr></table></figure></p><p>在httpd.conf添加以下配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LoadModule php5_module modules&#x2F;libphp5.so</span><br><span class="line">##########################################</span><br><span class="line">&lt;FilesMatch \.php$&gt;</span><br><span class="line">    SetHandler application&#x2F;x-httpd-php</span><br><span class="line">&lt;&#x2F;FilesMatch&gt;</span><br></pre></td></tr></table></figure></p><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>访问80端口出现以下表示php配置完成。<br><img data-src="https://img-blog.csdnimg.cn/20190513182736115.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc1MjI5NA==,size_16,color_FFFFFF,t_70" alt=""></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;主要参考文章：&lt;a href=&quot;https://blog.csdn.net/weixin_41752294/article/details/90181805&quot;&gt;Linux安装PHP-FPM&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;跟着做的时候踩坑了，在此记录下踩的坑，并排坑。&lt;/p&gt;
&lt;p&gt;注：参考文章于2019年5月发布！&lt;/p&gt;</summary>
    
    
    
    
    <category term="Linux" scheme="https://wjr-z.com/tags/Linux/"/>
    
    <category term="php" scheme="https://wjr-z.com/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>已学知识点汇总</title>
    <link href="https://wjr-z.com/%E5%B7%B2%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/"/>
    <id>https://wjr-z.com/%E5%B7%B2%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/</id>
    <published>2021-02-21T06:32:50.000Z</published>
    <updated>2021-02-21T06:49:30.165Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="已学知识点："><a href="#已学知识点：" class="headerlink" title="已学知识点："></a>已学知识点：</h2><h3 id="本博客内写过讲解的："><a href="#本博客内写过讲解的：" class="headerlink" title="本博客内写过讲解的："></a>本博客内写过讲解的：</h3><span id="more"></span><ul><li><a href="https://wjr-z.com/Linear%20basis/">线性基</a></li><li><a href="https://wjr-z.com/Linear%20sieve/">线性筛</a></li><li><a href="https://wjr-z.com/KMP/">KMP</a></li><li><a href="https://wjr-z.com/SAM">SAM</a></li><li><a href="http://wjr-z.com/FFT">FFT</a></li><li><a href="https://wjr-z.com/Minimum%20Steiner%20tree/">最小斯坦纳树</a></li><li><a href="https://wjr-z.com/莫比乌斯反演学习/">莫比乌斯反演</a><h3 id="本博客内尚未写过讲解的（待填坑）："><a href="#本博客内尚未写过讲解的（待填坑）：" class="headerlink" title="本博客内尚未写过讲解的（待填坑）："></a>本博客内尚未写过讲解的（待填坑）：</h3></li><li><a href="https://wjr-z.com">树状数组</a></li><li><a href="https://wjr-z.com">线段树</a></li><li><a href="https://wjr-z.com">树链剖分</a></li><li><a href="https://wjr-z.com">splay</a></li><li><a href="https://wjr-z.com">DP</a></li><li><span class="exturl" data-url="aHR0cHM6Ly93anItei9jb20=">单调队列<i class="fa fa-external-link-alt"></i></span></li><li><a href="https://wjr-z.com">二分</a></li><li><a href="https://wjr-z.com">点分治</a></li><li><a href="https://wjr-z.com">树上倍增</a></li><li><a href="https://wjr-z.com">RMQ</a></li><li><a href="https://wjr-z.com">LCT</a></li></ul><h2 id="准备学习的知识点："><a href="#准备学习的知识点：" class="headerlink" title="准备学习的知识点："></a>准备学习的知识点：</h2><ul><li>KD-tree</li><li></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;已学知识点：&quot;&gt;&lt;a href=&quot;#已学知识点：&quot; class=&quot;headerlink&quot; title=&quot;已学知识点：&quot;&gt;&lt;/a&gt;已学知识点：&lt;/h2&gt;&lt;h3 id=&quot;本博客内写过讲解的：&quot;&gt;&lt;a href=&quot;#本博客内写过讲解的：&quot; class=&quot;headerlink&quot; title=&quot;本博客内写过讲解的：&quot;&gt;&lt;/a&gt;本博客内写过讲解的：&lt;/h3&gt;</summary>
    
    
    
    
    <category term="汇总" scheme="https://wjr-z.com/tags/%E6%B1%87%E6%80%BB/"/>
    
  </entry>
  
</feed>
